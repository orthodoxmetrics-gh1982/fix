#!/usr/bin/env node

/**
 * Phase 1: Database Schema & Core Infrastructure
 * Step 3: Create TypeScript interfaces for OCR mapping types
 */

const fs = require('fs').promises;
const path = require('path');

const TYPESCRIPT_INTERFACES = `/**
 * TypeScript Interfaces for OCR Field Mapping System
 * Generated by Phase 1 setup script
 */

// Field Configuration Interface
export interface FieldConfig {
  ocr_label: string;           // Label detected in OCR text
  target_column: string;       // Target database column name
  required: boolean;           // Whether field is required
  validation?: string;         // Validation regex or type ('date', 'email', etc.)
  format?: string;            // Format string for output
  concat_with?: string[];     // Other fields to concatenate with
  transform?: 'uppercase' | 'lowercase' | 'titlecase' | 'trim';
  default_value?: string;     // Default value if not found
  confidence_threshold?: number; // Minimum confidence required
}

// Complete Field Configuration for a Record Type
export interface RecordFieldConfig {
  fields: FieldConfig[];
  settings: {
    auto_insert_threshold: number;        // Confidence % for auto-insertion
    require_manual_review: string[];      // Fields that always need review
    confidence_warning_threshold: number; // Show warning below this %
    allow_partial_insert: boolean;        // Allow inserting incomplete records
  };
}

// OCR Job Metadata (matches database structure)
export interface OcrJobMetadata {
  id: number;
  church_id: number;
  filename: string;
  original_filename?: string;
  file_path: string;
  file_size: number;
  mime_type: string;
  status: 'pending' | 'processing' | 'completed' | 'failed';
  record_type: 'baptism' | 'marriage' | 'funeral';
  language: string;
  ocr_result?: string;
  extracted_entities?: any;
  confidence_score?: number;
  entity_confidence?: number;
  needs_review?: boolean;
  detected_language?: string;
  created_at: string;
  updated_at: string;
}

// Mapped Fields Result
export interface MappedFieldResult {
  field: string;
  value: string;
  confidence: number;
  source_text?: string;        // Original OCR text snippet
  validation_passed: boolean;
  error_message?: string;
}

// OCR Processing Log Entry
export interface OcrProcessingLog {
  id: number;
  church_id: number;
  ocr_job_id: number;
  record_type: 'baptism' | 'marriage' | 'funeral';
  filename: string;
  status: 'pending' | 'processing' | 'completed' | 'failed' | 'transferred';
  user_id?: number;
  started_at?: string;
  completed_at?: string;
  error_message?: string;
  processing_metadata?: any;
  confidence_score?: number;
  created_at: string;
  updated_at: string;
}

// OCR Review Queue Entry
export interface OcrReviewQueueEntry {
  id: number;
  church_id: number;
  ocr_job_id: number;
  processing_log_id: number;
  record_type: 'baptism' | 'marriage' | 'funeral';
  filename: string;
  original_filename?: string;
  extracted_text?: string;
  mapped_fields?: MappedFieldResult[];
  confidence_avg?: number;
  status: 'pending_review' | 'in_review' | 'approved' | 'rejected' | 'needs_correction';
  priority: 'low' | 'normal' | 'high' | 'urgent';
  assigned_to?: number;
  reviewed_by?: number;
  reviewed_at?: string;
  approval_notes?: string;
  correction_data?: any;
  auto_insertable: boolean;
  created_at: string;
  updated_at: string;
}

// OCR Job Transfer Entry  
export interface OcrJobTransfer {
  id: number;
  church_id: number;
  source_ocr_job_id: number;
  processing_log_id?: number;
  review_queue_id?: number;
  transfer_status: 'pending' | 'in_progress' | 'completed' | 'failed' | 'cancelled';
  transfer_type: 'auto' | 'manual' | 'batch';
  source_database: string;
  target_table?: string;
  record_type: 'baptism' | 'marriage' | 'funeral';
  transferred_data?: any;
  target_record_id?: number;
  transfer_started_at?: string;
  transfer_completed_at?: string;
  error_message?: string;
  retry_count: number;
  initiated_by?: number;
  created_at: string;
  updated_at: string;
}

// OCR Text Processing Result
export interface OcrTextProcessingResult {
  raw_text: string;
  mapped_fields: MappedFieldResult[];
  confidence_avg: number;
  validation_errors: string[];
  auto_insertable: boolean;
  requires_review: boolean;
  processing_notes: string[];
}

// API Response Types
export interface OcrJobsResponse {
  jobs: OcrJobMetadata[];
  pagination: {
    page: number;
    limit: number;
    total: number;
    pages: number;
  };
}

export interface FieldConfigResponse {
  id: number;
  church_id: number;
  record_type: string;
  field_config: RecordFieldConfig;
  created_at: string;
  updated_at: string;
  is_active: boolean;
  version: number;
  description?: string;
}

// Request Types
export interface CreateFieldConfigRequest {
  church_id: number;
  record_type: 'baptism' | 'marriage' | 'funeral';
  field_config: RecordFieldConfig;
  description?: string;
}

export interface ProcessOcrJobRequest {
  ocr_job_id: number;
  church_id: number;
  force_reprocess?: boolean;
  skip_auto_insert?: boolean;
}

export interface ReviewQueueUpdateRequest {
  status: 'approved' | 'rejected' | 'needs_correction';
  approval_notes?: string;
  correction_data?: any;
  corrected_fields?: MappedFieldResult[];
}

// Utility Types
export type RecordType = 'baptism' | 'marriage' | 'funeral';
export type OcrJobStatus = 'pending' | 'processing' | 'completed' | 'failed';
export type ReviewStatus = 'pending_review' | 'in_review' | 'approved' | 'rejected' | 'needs_correction';
export type TransferStatus = 'pending' | 'in_progress' | 'completed' | 'failed' | 'cancelled';

// Database Table Names
export const TABLE_NAMES = {
  OCR_FIELD_CONFIGURATIONS: 'ocr_field_configurations',
  OCR_PROCESSING_LOG: 'ocr_processing_log',
  OCR_REVIEW_QUEUE: 'ocr_review_queue',
  OCR_JOB_TRANSFERS: 'ocr_job_transfers',
  BAPTISM_RECORDS: 'baptism_records',
  MARRIAGE_RECORDS: 'marriage_records',
  FUNERAL_RECORDS: 'funeral_records'
} as const;

// Default Field Configurations
export const DEFAULT_BAPTISM_FIELDS: FieldConfig[] = [
  {
    ocr_label: "Name",
    target_column: "full_name",
    required: true,
    validation: "^[A-Za-z\\\\s]{2,100}$",
    transform: "titlecase"
  },
  {
    ocr_label: "Date of Birth",
    target_column: "birth_date", 
    required: true,
    validation: "date",
    format: "YYYY-MM-DD"
  },
  {
    ocr_label: "Date of Baptism",
    target_column: "baptism_date",
    required: true,
    validation: "date", 
    format: "YYYY-MM-DD"
  },
  {
    ocr_label: "Father",
    target_column: "father_name",
    required: false,
    validation: "^[A-Za-z\\\\s]{0,100}$",
    transform: "titlecase"
  },
  {
    ocr_label: "Mother", 
    target_column: "mother_name",
    required: false,
    validation: "^[A-Za-z\\\\s]{0,100}$",
    transform: "titlecase"
  },
  {
    ocr_label: "Godparent",
    target_column: "godparent_name",
    required: false,
    validation: "^[A-Za-z\\\\s]{0,100}$",
    transform: "titlecase"
  },
  {
    ocr_label: "Clergy",
    target_column: "clergy",
    required: false,
    validation: "^[A-Za-z\\\\s\\\\.]{0,100}$",
    transform: "titlecase"
  }
];

export const DEFAULT_MARRIAGE_FIELDS: FieldConfig[] = [
  {
    ocr_label: "Groom Name",
    target_column: "groom_name",
    required: true,
    validation: "^[A-Za-z\\\\s]{2,100}$",
    transform: "titlecase"
  },
  {
    ocr_label: "Bride Name", 
    target_column: "bride_name",
    required: true,
    validation: "^[A-Za-z\\\\s]{2,100}$", 
    transform: "titlecase"
  },
  {
    ocr_label: "Marriage Date",
    target_column: "marriage_date",
    required: true,
    validation: "date",
    format: "YYYY-MM-DD"
  },
  {
    ocr_label: "Witness 1",
    target_column: "witness1_name",
    required: false,
    validation: "^[A-Za-z\\\\s]{0,100}$",
    transform: "titlecase"
  },
  {
    ocr_label: "Witness 2",
    target_column: "witness2_name", 
    required: false,
    validation: "^[A-Za-z\\\\s]{0,100}$",
    transform: "titlecase"
  },
  {
    ocr_label: "Clergy",
    target_column: "clergy",
    required: false,
    validation: "^[A-Za-z\\\\s\\\\.]{0,100}$",
    transform: "titlecase"
  }
];

export const DEFAULT_FUNERAL_FIELDS: FieldConfig[] = [
  {
    ocr_label: "Name",
    target_column: "full_name",
    required: true,
    validation: "^[A-Za-z\\\\s]{2,100}$",
    transform: "titlecase"
  },
  {
    ocr_label: "Date of Death",
    target_column: "death_date",
    required: true,
    validation: "date",
    format: "YYYY-MM-DD"
  },
  {
    ocr_label: "Date of Funeral",
    target_column: "funeral_date",
    required: true,
    validation: "date",
    format: "YYYY-MM-DD"
  },
  {
    ocr_label: "Age",
    target_column: "age_at_death",
    required: false,
    validation: "^\\\\d{1,3}$"
  },
  {
    ocr_label: "Clergy",
    target_column: "clergy", 
    required: false,
    validation: "^[A-Za-z\\\\s\\\\.]{0,100}$",
    transform: "titlecase"
  }
];
`;

async function createTypeScriptInterfaces() {
  try {
    console.log('üìù PHASE 1 - Step 3: Creating TypeScript interfaces...');
    console.log('================================================================================');
    
    // Create types directory if it doesn't exist
    const typesDir = path.join(__dirname, '..', 'types');
    
    try {
      await fs.access(typesDir);
      console.log('üìÅ Types directory exists');
    } catch {
      await fs.mkdir(typesDir, { recursive: true });
      console.log('üìÅ Created types directory');
    }
    
    // Write the interfaces file
    const interfacesPath = path.join(typesDir, 'ocrTypes.ts');
    await fs.writeFile(interfacesPath, TYPESCRIPT_INTERFACES);
    
    console.log(`‚úÖ Created TypeScript interfaces: ${interfacesPath}`);
    
    // Count the interfaces/types created
    const interfaceCount = (TYPESCRIPT_INTERFACES.match(/export interface/g) || []).length;
    const typeCount = (TYPESCRIPT_INTERFACES.match(/export type/g) || []).length;
    const constCount = (TYPESCRIPT_INTERFACES.match(/export const/g) || []).length;
    
    console.log(`üìä Generated:`);
    console.log(`   - ${interfaceCount} interfaces`);
    console.log(`   - ${typeCount} type aliases`);
    console.log(`   - ${constCount} constant definitions`);
    
    // Create a sample utility file for working with the types
    const utilityCode = `/**
 * Utility functions for OCR Field Mapping
 * Generated by Phase 1 setup script
 */

import {
  FieldConfig,
  RecordFieldConfig, 
  MappedFieldResult,
  OcrTextProcessingResult,
  RecordType,
  DEFAULT_BAPTISM_FIELDS,
  DEFAULT_MARRIAGE_FIELDS,
  DEFAULT_FUNERAL_FIELDS
} from './ocrTypes';

/**
 * Get default field configuration for a record type
 */
export function getDefaultFieldConfig(recordType: RecordType): FieldConfig[] {
  switch (recordType) {
    case 'baptism':
      return DEFAULT_BAPTISM_FIELDS;
    case 'marriage':
      return DEFAULT_MARRIAGE_FIELDS;
    case 'funeral':
      return DEFAULT_FUNERAL_FIELDS;
    default:
      throw new Error(\`Unknown record type: \${recordType}\`);
  }
}

/**
 * Validate a field value against its configuration
 */
export function validateField(value: string, config: FieldConfig): { valid: boolean; error?: string } {
  if (config.required && (!value || value.trim() === '')) {
    return { valid: false, error: 'Field is required' };
  }
  
  if (value && config.validation) {
    if (config.validation === 'date') {
      const dateRegex = /^\\d{4}-\\d{2}-\\d{2}$/;
      if (!dateRegex.test(value)) {
        return { valid: false, error: 'Invalid date format (expected YYYY-MM-DD)' };
      }
      const date = new Date(value);
      if (isNaN(date.getTime())) {
        return { valid: false, error: 'Invalid date' };
      }
    } else if (config.validation === 'email') {
      const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;
      if (!emailRegex.test(value)) {
        return { valid: false, error: 'Invalid email format' };
      }
    } else {
      // Treat as regex
      try {
        const regex = new RegExp(config.validation);
        if (!regex.test(value)) {
          return { valid: false, error: 'Value does not match required format' };
        }
      } catch (error) {
        console.warn(\`Invalid regex in field config: \${config.validation}\`);
      }
    }
  }
  
  return { valid: true };
}

/**
 * Transform field value according to configuration
 */
export function transformFieldValue(value: string, config: FieldConfig): string {
  if (!value) return value;
  
  let transformed = value;
  
  if (config.transform) {
    switch (config.transform) {
      case 'uppercase':
        transformed = transformed.toUpperCase();
        break;
      case 'lowercase':
        transformed = transformed.toLowerCase();
        break;
      case 'titlecase':
        transformed = transformed.toLowerCase().replace(/\\b\\w/g, l => l.toUpperCase());
        break;
      case 'trim':
        transformed = transformed.trim();
        break;
    }
  }
  
  return transformed;
}

/**
 * Calculate average confidence from mapped fields
 */
export function calculateAverageConfidence(mappedFields: MappedFieldResult[]): number {
  if (mappedFields.length === 0) return 0;
  
  const totalConfidence = mappedFields.reduce((sum, field) => sum + field.confidence, 0);
  return Math.round(totalConfidence / mappedFields.length);
}

/**
 * Check if OCR result is auto-insertable based on configuration
 */
export function isAutoInsertable(
  mappedFields: MappedFieldResult[],
  config: RecordFieldConfig
): boolean {
  const avgConfidence = calculateAverageConfidence(mappedFields);
  
  // Check overall confidence threshold
  if (avgConfidence < config.settings.auto_insert_threshold) {
    return false;
  }
  
  // Check if any required field is missing or has validation errors
  const requiredFields = config.fields.filter(f => f.required);
  for (const requiredField of requiredFields) {
    const mappedField = mappedFields.find(f => f.field === requiredField.target_column);
    if (!mappedField || !mappedField.validation_passed) {
      return false;
    }
  }
  
  // Check if any field requires manual review
  for (const fieldName of config.settings.require_manual_review) {
    const mappedField = mappedFields.find(f => f.field === fieldName);
    if (mappedField) {
      return false; // Has a field that requires manual review
    }
  }
  
  return true;
}

/**
 * Generate a processing result summary
 */
export function generateProcessingResult(
  rawText: string,
  mappedFields: MappedFieldResult[],
  config: RecordFieldConfig
): OcrTextProcessingResult {
  const avgConfidence = calculateAverageConfidence(mappedFields);
  const validationErrors: string[] = [];
  const processingNotes: string[] = [];
  
  // Collect validation errors
  mappedFields.forEach(field => {
    if (!field.validation_passed && field.error_message) {
      validationErrors.push(\`\${field.field}: \${field.error_message}\`);
    }
  });
  
  // Check for missing required fields
  const requiredFields = config.fields.filter(f => f.required);
  requiredFields.forEach(reqField => {
    const found = mappedFields.find(f => f.field === reqField.target_column);
    if (!found) {
      validationErrors.push(\`Missing required field: \${reqField.target_column}\`);
    }
  });
  
  const autoInsertable = isAutoInsertable(mappedFields, config);
  const requiresReview = !autoInsertable || 
    avgConfidence < config.settings.confidence_warning_threshold ||
    validationErrors.length > 0;
  
  if (avgConfidence < config.settings.confidence_warning_threshold) {
    processingNotes.push(\`Low confidence: \${avgConfidence}% (threshold: \${config.settings.confidence_warning_threshold}%)\`);
  }
  
  if (validationErrors.length > 0) {
    processingNotes.push(\`\${validationErrors.length} validation error(s) found\`);
  }
  
  return {
    raw_text: rawText,
    mapped_fields: mappedFields,
    confidence_avg: avgConfidence,
    validation_errors: validationErrors,
    auto_insertable: autoInsertable,
    requires_review: requiresReview,
    processing_notes: processingNotes
  };
}
`;
    
    const utilityPath = path.join(typesDir, 'ocrUtils.ts');
    await fs.writeFile(utilityPath, utilityCode);
    
    console.log(`‚úÖ Created utility functions: ${utilityPath}`);
    
    console.log('\n================================================================================');
    console.log('üìù TypeScript Interface Creation Complete!');
    console.log('üìÅ Files created:');
    console.log(`   - ${interfacesPath}`);
    console.log(`   - ${utilityPath}`);
    console.log('\nüìù Next step: Run phase1-create-db-utilities.js to create database connection utilities');
    console.log('================================================================================');
    
  } catch (error) {
    console.error('‚ùå TypeScript interface creation failed:', error.message);
    process.exit(1);
  }
}

// Run interface creation
createTypeScriptInterfaces().catch(console.error);
