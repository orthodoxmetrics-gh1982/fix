/**
 * Field Configuration Service
 * Handles OCR field mapping configurations for churches
 * Generated by Phase 1 setup script
 */

import {
  FieldConfig,
  RecordFieldConfig,
  FieldConfigResponse,
  CreateFieldConfigRequest,
  RecordType,
  TABLE_NAMES
} from '../types/ocrTypes';
import { executeRecordsQuery, withRecordsTransaction } from './dbConnections';

/**
 * Get field configuration for a church and record type
 */
export async function getFieldConfig(
  churchId: number,
  recordType: RecordType
): Promise<RecordFieldConfig | null> {
  try {
    const [rows] = await executeRecordsQuery<FieldConfigResponse>(
      `SELECT * FROM ${TABLE_NAMES.OCR_FIELD_CONFIGURATIONS} 
       WHERE church_id = ? AND record_type = ? AND is_active = TRUE
       ORDER BY version DESC LIMIT 1`,
      [churchId, recordType]
    );
    
    if (rows.length === 0) {
      return null;
    }
    
    return rows[0].field_config;
  } catch (error) {
    console.error('Error getting field config:', error);
    throw error;
  }
}

/**
 * Create or update field configuration
 */
export async function saveFieldConfig(
  request: CreateFieldConfigRequest
): Promise<number> {
  return await withRecordsTransaction(async (connection) => {
    // Deactivate existing configs for this church/record type
    await connection.execute(
      `UPDATE ${TABLE_NAMES.OCR_FIELD_CONFIGURATIONS} 
       SET is_active = FALSE, updated_at = CURRENT_TIMESTAMP
       WHERE church_id = ? AND record_type = ?`,
      [request.church_id, request.record_type]
    );
    
    // Get next version number
    const [versionRows] = await connection.execute(
      `SELECT COALESCE(MAX(version), 0) + 1 as next_version 
       FROM ${TABLE_NAMES.OCR_FIELD_CONFIGURATIONS}
       WHERE church_id = ? AND record_type = ?`,
      [request.church_id, request.record_type]
    );
    
    const nextVersion = versionRows[0].next_version;
    
    // Insert new configuration
    const [result] = await connection.execute(
      `INSERT INTO ${TABLE_NAMES.OCR_FIELD_CONFIGURATIONS} 
       (church_id, record_type, field_config, description, version, is_active) 
       VALUES (?, ?, ?, ?, ?, TRUE)`,
      [
        request.church_id,
        request.record_type,
        JSON.stringify(request.field_config),
        request.description,
        nextVersion
      ]
    );
    
    return result.insertId;
  });
}

/**
 * Get all field configurations for a church
 */
export async function getChurchFieldConfigs(churchId: number): Promise<FieldConfigResponse[]> {
  const [rows] = await executeRecordsQuery<FieldConfigResponse>(
    `SELECT * FROM ${TABLE_NAMES.OCR_FIELD_CONFIGURATIONS}
     WHERE church_id = ? AND is_active = TRUE
     ORDER BY record_type, version DESC`,
    [churchId]
  );
  
  return rows;
}

/**
 * Get field configuration history
 */
export async function getFieldConfigHistory(
  churchId: number,
  recordType: RecordType
): Promise<FieldConfigResponse[]> {
  const [rows] = await executeRecordsQuery<FieldConfigResponse>(
    `SELECT * FROM ${TABLE_NAMES.OCR_FIELD_CONFIGURATIONS}
     WHERE church_id = ? AND record_type = ?
     ORDER BY version DESC`,
    [churchId, recordType]
  );
  
  return rows;
}

/**
 * Delete field configuration (soft delete - mark as inactive)
 */
export async function deleteFieldConfig(configId: number): Promise<void> {
  await executeRecordsQuery(
    `UPDATE ${TABLE_NAMES.OCR_FIELD_CONFIGURATIONS}
     SET is_active = FALSE, updated_at = CURRENT_TIMESTAMP
     WHERE id = ?`,
    [configId]
  );
}
