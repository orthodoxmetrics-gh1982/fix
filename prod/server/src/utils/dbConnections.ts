/**
 * Cross-Database Connection Utilities for OCR System
 * Handles connections between orthodoxmetrics_db ↔ ssppoc_records_db ↔ orthodoxmetrics_ocr_db
 * Generated by Phase 1 setup script
 */

import mysql from 'mysql2/promise';
import { promisePool as centralPool } from '@/config/db';

// Database Configuration
const DB_CONFIG = {
  host: 'localhost',
  user: 'orthodoxapps',
  password: 'Summerof1982@!',
  charset: 'utf8mb4',
  connectionLimit: 10,
  acquireTimeout: 60000,
  timeout: 60000
};

// Connection pools for each database
let recordsPool: mysql.Pool | null = null;
let ocrPool: mysql.Pool | null = null;

/**
 * Get connection pool for Records Database (ssppoc_records_db)
 */
export function getRecordsDbPool(): mysql.Pool {
  if (!recordsPool) {
    recordsPool = mysql.createPool({
      ...DB_CONFIG,
      database: 'ssppoc_records_db'
    });
  }
  return recordsPool;
}

/**
 * Get connection pool for OCR Processing Database (orthodoxmetrics_ocr_db)
 */
export function getOcrDbPool(): mysql.Pool {
  if (!ocrPool) {
    ocrPool = mysql.createPool({
      ...DB_CONFIG,
      database: process.env.OCR_DATABASE || 'orthodoxmetrics_ocr_db'
    });
  }
  return ocrPool;
}

/**
 * Get single connection to Records Database
 */
export async function getRecordsDbConnection(): Promise<mysql.PoolConnection> {
  const pool = getRecordsDbPool();
  return await pool.getConnection();
}

/**
 * Get single connection to OCR Database  
 */
export async function getOcrDbConnection(): Promise<mysql.PoolConnection> {
  const pool = getOcrDbPool();
  return await pool.getConnection();
}

/**
 * Execute query on Records Database
 */
export async function executeRecordsQuery<T = any>(
  query: string, 
  params: any[] = []
): Promise<[T[], mysql.FieldPacket[]]> {
  const pool = getRecordsDbPool();
  return await pool.execute(query, params) as [T[], mysql.FieldPacket[]];
}

/**
 * Execute query on OCR Database
 */
export async function executeOcrQuery<T = any>(
  query: string,
  params: any[] = []
): Promise<[T[], mysql.FieldPacket[]]> {
  const pool = getOcrDbPool();
  return await pool.execute(query, params) as [T[], mysql.FieldPacket[]];
}

/**
 * Execute query on Central Database (orthodoxmetrics_db)
 */
export async function executeCentralQuery<T = any>(
  query: string,
  params: any[] = []
): Promise<[T[], mysql.FieldPacket[]]> {
  return await centralPool.execute(query, params) as [T[], mysql.FieldPacket[]];
}

/**
 * Transaction wrapper for Records Database
 */
export async function withRecordsTransaction<T>(
  callback: (connection: mysql.PoolConnection) => Promise<T>
): Promise<T> {
  const connection = await getRecordsDbConnection();
  
  try {
    await connection.beginTransaction();
    const result = await callback(connection);
    await connection.commit();
    return result;
  } catch (error) {
    await connection.rollback();
    throw error;
  } finally {
    connection.release();
  }
}

/**
 * Transaction wrapper for OCR Database
 */
export async function withOcrTransaction<T>(
  callback: (connection: mysql.PoolConnection) => Promise<T>
): Promise<T> {
  const connection = await getOcrDbConnection();
  
  try {
    await connection.beginTransaction();
    const result = await callback(connection);
    await connection.commit();
    return result;
  } catch (error) {
    await connection.rollback();
    throw error;
  } finally {
    connection.release();
  }
}

/**
 * Cross-database transaction (Records + OCR)
 */
export async function withCrossDbTransaction<T>(
  callback: (recordsConn: mysql.PoolConnection, ocrConn: mysql.PoolConnection) => Promise<T>
): Promise<T> {
  const recordsConnection = await getRecordsDbConnection();
  const ocrConnection = await getOcrDbConnection();
  
  try {
    await recordsConnection.beginTransaction();
    await ocrConnection.beginTransaction();
    
    const result = await callback(recordsConnection, ocrConnection);
    
    await recordsConnection.commit();
    await ocrConnection.commit();
    
    return result;
  } catch (error) {
    await recordsConnection.rollback();
    await ocrConnection.rollback();
    throw error;
  } finally {
    recordsConnection.release();
    ocrConnection.release();
  }
}

/**
 * Get church information from central database
 */
export async function getChurchInfo(churchId: number): Promise<any> {
  const [rows] = await executeCentralQuery(
    'SELECT * FROM churches WHERE id = ?',
    [churchId]
  );
  
  if (rows.length === 0) {
    throw new Error(`Church not found: ${churchId}`);
  }
  
  return rows[0];
}

/**
 * Validate user permissions for OCR operations
 */
export async function validateUserPermissions(
  userId: number, 
  action: string,
  churchId?: number
): Promise<boolean> {
  try {
    // Get user role and permissions
    const [userRows] = await executeCentralQuery(
      `SELECT u.*, ur.role_name 
       FROM orthodoxmetrics_db.users u 
       LEFT JOIN user_roles ur ON u.role_id = ur.id 
       WHERE u.id = ?`,
      [userId]
    );
    
    if (userRows.length === 0) {
      return false;
    }
    
    const user = userRows[0];
    
    // Super admin can do everything
    if (user.email === 'superadmin@orthodoxmetrics.com') {
      return true;
    }
    
    // Check church-specific permissions if churchId provided
    if (churchId) {
      const [permRows] = await executeCentralQuery(
        `SELECT * FROM church_permissions 
         WHERE user_id = ? AND church_id = ? AND permission_type = ?`,
        [userId, churchId, action]
      );
      
      if (permRows.length > 0) {
        return true;
      }
    }
    
    // Check role-based permissions
    const rolePermissions: Record<string, string[]> = {
      'admin': ['ocr_upload', 'ocr_review', 'ocr_approve', 'ocr_configure'],
      'clergy': ['ocr_upload', 'ocr_review', 'ocr_approve'],
      'volunteer': ['ocr_upload']
    };
    
    const allowedActions = rolePermissions[user.role_name] || [];
    return allowedActions.includes(action);
    
  } catch (error) {
    console.error('Permission validation error:', error);
    return false;
  }
}

/**
 * Test all database connections
 */
export async function testConnections(): Promise<{ success: boolean; results: any }> {
  const results = {
    central: { connected: false, error: null },
    records: { connected: false, error: null },
    ocr: { connected: false, error: null }
  };
  
  try {
    // Test central database
    const [centralRows] = await executeCentralQuery('SELECT 1 as test');
    results.central.connected = true;
  } catch (error) {
    results.central.error = error.message;
  }
  
  try {
    // Test records database
    const [recordsRows] = await executeRecordsQuery('SELECT 1 as test');
    results.records.connected = true;
  } catch (error) {
    results.records.error = error.message;
  }
  
  try {
    // Test OCR database
    const [ocrRows] = await executeOcrQuery('SELECT 1 as test');
    results.ocr.connected = true;
  } catch (error) {
    results.ocr.error = error.message;
  }
  
  const success = results.central.connected && results.records.connected && results.ocr.connected;
  
  return { success, results };
}

/**
 * Close all database connections
 */
export async function closeAllConnections(): Promise<void> {
  const promises = [];
  
  if (recordsPool) {
    promises.push(recordsPool.end());
    recordsPool = null;
  }
  
  if (ocrPool) {
    promises.push(ocrPool.end());
    ocrPool = null;
  }
  
  await Promise.all(promises);
}

// Graceful shutdown
process.on('SIGINT', async () => {
  await closeAllConnections();
  process.exit(0);
});

process.on('SIGTERM', async () => {
  await closeAllConnections(); 
  process.exit(0);
});
