import React, { useState, useRef, useCallback, useEffect } from 'react';
import {
  Card,
  CardContent,
  Typography,
  Button,
  TextField,
  FormControl,
  FormLabel,
  Tabs,
  Tab,
  Box,
  Alert,
  Chip,
  Paper,
  Divider,
  Stack,
  IconButton,
  Tooltip,
  Switch,
  FormControlLabel,
  List,
  ListItem,
  ListItemText,
  ListItemIcon,
  ListItemSecondaryAction,
  Accordion,
  AccordionSummary,
  AccordionDetails,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  CircularProgress
} from '@mui/material';
import BigBookConsolePage from './BigBookConsolePage';
import { BigBookConsoleSettings, defaultSettings } from './BigBookSettings';
import EncryptedStoragePanel from './EncryptedStoragePanel';
import QuestionnairePreview from './QuestionnairePreview';
import OMAIDiscoveryPanel from './OMAIDiscoveryPanel';
import TSXComponentInstallWizard from './TSXComponentInstallWizard';
import RegistryManagementPanel from './RegistryManagementPanel';
import {
  Upload as UploadIcon,
  PlayArrow as PlayIcon,
  Stop as StopIcon,
  Delete as Trash2Icon,
  Settings as SettingsIcon,
  Description as FileTextIcon,
  Code as CodeIcon,
  Storage as DatabaseIcon,
  Terminal as TerminalIcon,
  Save as SaveIcon,
  Refresh as RefreshCwIcon,
  CloudUpload as CloudUploadIcon,
  FolderOpen as FolderOpenIcon,
  Article as ArticleIcon,
  Javascript as JavaScriptIcon,
  Code as ShellScriptIcon,
  Code as PythonIcon,
  ExpandMore as ExpandMoreIcon,
  Extension as AddonIcon,
  Article as DocIcon,
  Tune as ConfigIcon,
  Archive as DataIcon,
  Visibility as ViewIcon,
  Html as HtmlIcon,
  Css as CssIcon,
  DataObject as JsonIcon,
  Code as XmlIcon,
  Image as ImageIcon,
  VideoFile as VideoIcon,
  AudioFile as AudioIcon,
  Archive as ArchiveIcon,
  PictureAsPdf as PdfIcon,
  TextSnippet as TextIcon
} from '@mui/icons-material';

interface FileUpload {
  id: string;
  name: string;
  type: 'sql' | 'script' | 'markdown' | 'javascript' | 'shell' | 'python' | 'html' | 'css' | 'json' | 'xml' | 'text' | 'image' | 'video' | 'audio' | 'archive' | 'pdf' | 'other';
  content: string;
  size: number;
  uploadedAt: Date;
  status: 'pending' | 'uploaded' | 'error';
  extension: string;
  mimeType?: string;
  encryptedPath?: string; // Path in encrypted storage
  originalName?: string; // Original filename
  isQuestionnaire?: boolean; // Flag for questionnaire files
  questionnaireMetadata?: {
    id: string;
    fileName: string;
    title: string;
    description: string;
    ageGroup: string;
    type: string;
    version: string;
    author: string;
    estimatedDuration: number;
    questions: any[];
    metadata: any;
  };
}

interface ConsoleOutput {
  id: string;
  timestamp: Date;
  type: 'info' | 'success' | 'error' | 'warning' | 'command';
  message: string;
  details?: string;
}

interface BigBookSettings {
  databaseUser: string;
  databasePassword: string;
  useSudo: boolean;
  sudoPassword: string;
  defaultDatabase: string;
  scriptTimeout: number;
  maxFileSize: number;
}

const OMBigBook: React.FC = () => {
  const [activeTab, setActiveTab] = useState(0);
  const [uploadedFiles, setUploadedFiles] = useState<FileUpload[]>([]);
  const [consoleOutput, setConsoleOutput] = useState<ConsoleOutput[]>([]);
  const [isExecuting, setIsExecuting] = useState(false);
  const [selectedFile, setSelectedFile] = useState<FileUpload | null>(null);
  const [showSettings, setShowSettings] = useState(false);
  const [settings, setSettings] = useState<BigBookSettings>({
    databaseUser: 'root',
    databasePassword: '',
    useSudo: true,
    sudoPassword: '',
    defaultDatabase: 'omai_db',
    scriptTimeout: 30000,
    maxFileSize: 10485760 // 10MB
  });
  const [consoleSettings, setConsoleSettings] = useState<BigBookConsoleSettings>(defaultSettings);
  const [questionnairePreviewOpen, setQuestionnairePreviewOpen] = useState(false);
  const [previewFile, setPreviewFile] = useState<FileUpload | null>(null);
  const [registries, setRegistries] = useState<any>(null);
  const [registriesLoading, setRegistriesLoading] = useState(false);
  const [registriesError, setRegistriesError] = useState<string | null>(null);
  const [tsxWizardOpen, setTsxWizardOpen] = useState(false);
  const [tsxFile, setTsxFile] = useState<File | null>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);
  const consoleRef = useRef<HTMLDivElement>(null);

  // Auto-scroll console to bottom
  const scrollToBottom = useCallback(() => {
    if (consoleRef.current) {
      consoleRef.current.scrollTop = consoleRef.current.scrollHeight;
    }
  }, []);

  React.useEffect(() => {
    scrollToBottom();
  }, [consoleOutput, scrollToBottom]);

  // Load registries when tab is opened
  useEffect(() => {
    if (activeTab === 5) {
      loadRegistries();
    }
  }, [activeTab]);

  // Load registries function
  const loadRegistries = async () => {
    setRegistriesLoading(true);
    setRegistriesError(null);
    
    try {
      const response = await fetch('/api/bigbook/registries', {
        credentials: 'include'
      });
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      const result = await response.json();
      
      if (result.success) {
        setRegistries(result.registries);
      } else {
        throw new Error(result.error || 'Failed to load registries');
      }
    } catch (error) {
      setRegistriesError(error instanceof Error ? error.message : 'Unknown error');
      addConsoleMessage('error', `Failed to load registries: ${error instanceof Error ? error.message : 'Unknown error'}`);
    } finally {
      setRegistriesLoading(false);
    }
  };

  // Toggle item status
  const toggleItemStatus = async (type: string, id: string, enabled: boolean) => {
    try {
      const response = await fetch(`/api/bigbook/toggle-item/${type}/${id}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ enabled }),
        credentials: 'include'
      });
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      const result = await response.json();
      
      if (result.success) {
        // Update local registry state
        setRegistries((prev: any) => ({
          ...prev,
          [type]: {
            ...prev[type],
            items: {
              ...prev[type].items,
              [id]: result.item
            }
          }
        }));
        
        addConsoleMessage('success', `Item ${enabled ? 'enabled' : 'disabled'}: ${result.item.name || result.item.displayName || id}`);
      } else {
        throw new Error(result.error || 'Failed to toggle item');
      }
    } catch (error) {
      addConsoleMessage('error', `Failed to toggle item: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  };

  // Add console message
  const addConsoleMessage = (type: ConsoleOutput['type'], message: string, details?: string) => {
    const newMessage: ConsoleOutput = {
      id: Date.now().toString(),
      timestamp: new Date(),
      type,
      message,
      details
    };
    setConsoleOutput(prev => [...prev, newMessage]);
  };

  // Handle file drop
  const handleFileDrop = useCallback(async (e: React.DragEvent) => {
    e.preventDefault();
    const files = Array.from(e.dataTransfer.files);
    
    for (const file of files) {
      try {
        const extension = file.name.split('.').pop()?.toLowerCase() || '';
        
        // Special handling for Parish Map zip files
        if (extension === 'zip' && (
          file.name.toLowerCase().includes('parish-map') || 
          file.name.toLowerCase().includes('parishmap') ||
          file.name.toLowerCase() === '_workspace_dist_parish-map.zip'
        )) {
          addConsoleMessage('info', `üó∫Ô∏è Parish Map zip detected: ${file.name}. Starting auto-installation...`);
          
          try {
            const formData = new FormData();
            formData.append('parishMapZip', file);
            
            const response = await fetch('/api/bigbook/upload-parish-map', {
              method: 'POST',
              body: formData,
              credentials: 'include'
            });
            
            const result = await response.json();
            
            if (result.success) {
              addConsoleMessage('success', `üéâ Parish Map installed successfully!`);
              addConsoleMessage('info', `üìç Component: ${result.addon.displayName}`);
              addConsoleMessage('info', `üîó Available at: orthodoxmetrics.com${result.addon.route}`);
              addConsoleMessage('info', `üìù Updated Big Book Components Index`);
              addConsoleMessage('success', `üß© Added to sidebar navigation under "Components" section`);
              addConsoleMessage('info', `üîÑ Refresh the page to see the new menu item in the sidebar`);
              
              // Add link to visit the component
              setTimeout(() => {
                addConsoleMessage('info', `Click here to visit: ${window.location.origin}${result.addon.route}`);
              }, 1000);
              
            } else {
              addConsoleMessage('error', `‚ùå Parish Map installation failed: ${result.error}`);
            }
          } catch (error) {
            addConsoleMessage('error', `‚ùå Parish Map installation error: ${error instanceof Error ? error.message : 'Unknown error'}`);
          }
          
          continue; // Skip normal file processing for parish map zips
        }
        
        // Special handling for .tsx component files
        if (extension === 'tsx') {
          addConsoleMessage('info', `üß© TSX Component detected: ${file.name}. Opening installation wizard...`);
          setTsxFile(file);
          setTsxWizardOpen(true);
          continue; // Skip normal file processing for tsx files
        }
        
        // Centralized file processing using new ingestion system
        const supportedTypes = ['.zip', '.js', '.json', '.md', '.sh'];
        if (!supportedTypes.includes(`.${extension}`)) {
          // Fallback to encrypted storage for unsupported types
          const reader = new FileReader();
          reader.onload = async (e) => {
            const content = e.target?.result as string;
            const fileType = getFileTypeFromExtension(extension);
            
            // Create temporary file object
            const tempFile: FileUpload = {
              id: Date.now().toString() + Math.random(),
              name: file.name,
              type: fileType,
              content,
              size: file.size,
              uploadedAt: new Date(),
              status: 'pending',
              extension,
              mimeType: file.type
            };
            
            setUploadedFiles(prev => [...prev, tempFile]);
            addConsoleMessage('info', `Uploading to encrypted storage: ${file.name} (${fileType})`);
            
            // Upload to encrypted storage (fallback)
            try {
              const response = await fetch('/api/bigbook/upload', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                  fileName: file.name,
                  content,
                  fileType
                }),
              });

              const result = await response.json();
              
              if (result.success) {
                setUploadedFiles(prev => prev.map(f => 
                  f.id === tempFile.id 
                    ? { 
                        ...f, 
                        status: 'uploaded',
                        encryptedPath: result.encryptedPath,
                        originalName: result.originalName,
                        isQuestionnaire: result.isQuestionnaire || false,
                        questionnaireMetadata: result.questionnaireMetadata || undefined
                      }
                    : f
                ));
                const fileTypeMessage = result.isQuestionnaire 
                  ? `questionnaire (${result.questionnaireMetadata?.title || 'Unknown'})`
                  : 'file';
                addConsoleMessage('success', `${fileTypeMessage} uploaded to encrypted storage: ${file.name}`);
                
                if (result.isQuestionnaire) {
                  addConsoleMessage('info', `Questionnaire detected: ${result.questionnaireMetadata?.ageGroup || 'Unknown age group'} - ${result.questionnaireMetadata?.estimatedDuration || 0} minutes`);
                }
              } else {
                setUploadedFiles(prev => prev.map(f => 
                  f.id === tempFile.id ? { ...f, status: 'error' } : f
                ));
                addConsoleMessage('error', `Upload failed: ${file.name} - ${result.error}`);
              }
            } catch (error) {
              setUploadedFiles(prev => prev.map(f => 
                f.id === tempFile.id ? { ...f, status: 'error' } : f
              ));
              addConsoleMessage('error', `Upload error: ${file.name} - ${error instanceof Error ? error.message : 'Unknown error'}`);
            }
          };
          
          reader.readAsText(file);
          continue;
        }
        
        // Use centralized ingestion system for supported file types
        const fileTypeIcons: Record<string, string> = {
          zip: 'üì¶',
          js: '‚ö°',
          json: '‚öôÔ∏è',
          md: 'üìù',
          sh: 'üîß'
        };
        
        const fileIcon = fileTypeIcons[extension] || 'üìÑ';
        addConsoleMessage('info', `${fileIcon} Processing ${extension.toUpperCase()} file: ${file.name}`);
        
        try {
          const formData = new FormData();
          formData.append('file', file);
          
          // Add OMAI notification flag if user wants it
          const notifyOMAI = extension === 'md' || extension === 'js'; // Auto-notify for docs and code
          if (notifyOMAI) {
            formData.append('notifyOMAI', 'true');
          }
          
          addConsoleMessage('info', `üîÑ Sending to centralized ingestion system...`);
          
          const response = await fetch('/api/bigbook/ingest-file', {
            method: 'POST',
            body: formData,
            credentials: 'include'
          });
          
          addConsoleMessage('info', `üì° Response status: ${response.status} ${response.statusText}`);
          
          if (!response.ok) {
            const errorText = await response.text();
            addConsoleMessage('error', `‚ùå HTTP Error ${response.status}: ${errorText}`);
            
            if (response.status === 401) {
              addConsoleMessage('error', `üîê Authentication failed. Please refresh page and try again.`);
              addConsoleMessage('info', `üí° Tip: Make sure you're logged in as super_admin`);
            }
            continue;
          }
          
          const result = await response.json();
          
          if (result.success) {
            const { result: ingestionResult } = result;
            
            addConsoleMessage('success', `‚úÖ ${ingestionResult.message}`);
            addConsoleMessage('info', `üìÇ Type: ${ingestionResult.type}/${ingestionResult.category}`);
            
            // Add type-specific messages
            switch (ingestionResult.type) {
              case 'addon':
                addConsoleMessage('info', `üß© Component available at: ${ingestionResult.item?.route || 'N/A'}`);
                if (ingestionResult.item?.enabled) {
                  addConsoleMessage('success', `‚úÖ Component enabled and ready to use`);
                } else {
                  addConsoleMessage('warning', `‚ö†Ô∏è Component requires manual enable in registry`);
                }
                break;
              case 'doc':
                addConsoleMessage('info', `üìñ Document: ${ingestionResult.item?.title || ingestionResult.item?.name}`);
                if (ingestionResult.item?.webPath) {
                  addConsoleMessage('info', `üîó Web path: ${ingestionResult.item.webPath}`);
                }
                break;
              case 'script':
                addConsoleMessage('info', `üîß Script stored and made executable`);
                addConsoleMessage('warning', `‚ö†Ô∏è Script requires manual enable for security`);
                break;
              case 'config':
                addConsoleMessage('info', `‚öôÔ∏è Configuration active and available`);
                break;
              case 'data':
                addConsoleMessage('info', `üíæ Data archived for manual processing`);
                break;
            }
            
            // Show registry update info
            if (result.registries) {
              const registryNames = Object.keys(result.registries);
              addConsoleMessage('info', `üìä Updated registries: ${registryNames.join(', ')}`);
            }
            
            // OMAI notification status
            if (notifyOMAI) {
              addConsoleMessage('info', `üß† OMAI notified for learning`);
            }
            
          } else {
            addConsoleMessage('error', `‚ùå Ingestion failed: ${result.error}`);
            if (result.debug) {
              addConsoleMessage('info', `üîç Debug info: ${JSON.stringify(result.debug)}`);
            }
          }
          
        } catch (error) {
          addConsoleMessage('error', `‚ùå Ingestion error: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
      } catch (error) {
        addConsoleMessage('error', `File processing error: ${file.name} - ${error instanceof Error ? error.message : 'Unknown error'}`);
      }
    }
  }, []);

  const handleDragOver = (e: React.DragEvent) => {
    e.preventDefault();
  };

  const handleFileInputChange = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const files = Array.from(e.target.files || []);
    
    for (const file of files) {
      try {
        const extension = file.name.split('.').pop()?.toLowerCase() || '';
        
        // Special handling for Parish Map zip files
        if (extension === 'zip' && (
          file.name.toLowerCase().includes('parish-map') || 
          file.name.toLowerCase().includes('parishmap') ||
          file.name.toLowerCase() === '_workspace_dist_parish-map.zip'
        )) {
          addConsoleMessage('info', `üó∫Ô∏è Parish Map zip selected: ${file.name}. Starting auto-installation...`);
          
          try {
            const formData = new FormData();
            formData.append('parishMapZip', file);
            
            addConsoleMessage('info', `üîÑ Sending request to /api/bigbook/upload-parish-map...`);
            
            const response = await fetch('/api/bigbook/upload-parish-map', {
              method: 'POST',
              body: formData,
              credentials: 'include',
              headers: {
                // Don't set Content-Type for FormData - let browser set it with boundary
              }
            });
            
            addConsoleMessage('info', `üì° Response status: ${response.status} ${response.statusText}`);
            
            if (!response.ok) {
              const errorText = await response.text();
              addConsoleMessage('error', `‚ùå HTTP Error ${response.status}: ${errorText}`);
              
              if (response.status === 401) {
                addConsoleMessage('error', `üîê Authentication failed. Please refresh page and try again.`);
                addConsoleMessage('info', `üí° Tip: Make sure you're logged in as super_admin`);
              }
              return;
            }
            
            const result = await response.json();
            
            if (result.success) {
              addConsoleMessage('success', `üéâ Parish Map installed successfully!`);
              addConsoleMessage('info', `üìç Component: ${result.addon.displayName}`);
              addConsoleMessage('info', `üîó Available at: orthodoxmetrics.com${result.addon.route}`);
              addConsoleMessage('info', `üìù Updated Big Book Components Index`);
              addConsoleMessage('success', `üß© Added to sidebar navigation under "Components" section`);
              addConsoleMessage('info', `üîÑ Refresh the page to see the new menu item in the sidebar`);
              
              // Add link to visit the component
              setTimeout(() => {
                addConsoleMessage('info', `Click here to visit: ${window.location.origin}${result.addon.route}`);
              }, 1000);
              
            } else {
              addConsoleMessage('error', `‚ùå Parish Map installation failed: ${result.error}`);
              if (result.debug) {
                addConsoleMessage('info', `üîç Debug info: ${JSON.stringify(result.debug)}`);
              }
            }
          } catch (error) {
            addConsoleMessage('error', `‚ùå Parish Map installation error: ${error instanceof Error ? error.message : 'Unknown error'}`);
            console.error('Parish Map upload error:', error);
          }
          
          continue; // Skip normal file processing for parish map zips
        }
        
        // Special handling for .tsx component files
        if (extension === 'tsx') {
          addConsoleMessage('info', `üß© TSX Component detected: ${file.name}. Opening installation wizard...`);
          setTsxFile(file);
          setTsxWizardOpen(true);
          continue; // Skip normal file processing for tsx files
        }
        
        // Centralized file processing using new ingestion system
        const supportedTypes = ['.zip', '.js', '.json', '.md', '.sh'];
        if (!supportedTypes.includes(`.${extension}`)) {
          // Fallback to encrypted storage for unsupported types
          const reader = new FileReader();
          reader.onload = async (e) => {
            const content = e.target?.result as string;
            const fileType = getFileTypeFromExtension(extension);
            
            // Create temporary file object
            const tempFile: FileUpload = {
              id: Date.now().toString() + Math.random(),
              name: file.name,
              type: fileType,
              content,
              size: file.size,
              uploadedAt: new Date(),
              status: 'pending',
              extension,
              mimeType: file.type
            };
            
            setUploadedFiles(prev => [...prev, tempFile]);
            addConsoleMessage('info', `Uploading to encrypted storage: ${file.name} (${fileType})`);
            
            // Upload to encrypted storage (fallback)
            try {
              const response = await fetch('/api/bigbook/upload', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                  fileName: file.name,
                  content,
                  fileType
                }),
              });

              const result = await response.json();
              
              if (result.success) {
                setUploadedFiles(prev => prev.map(f => 
                  f.id === tempFile.id 
                    ? { 
                        ...f, 
                        status: 'uploaded',
                        encryptedPath: result.encryptedPath,
                        originalName: result.originalName,
                        isQuestionnaire: result.isQuestionnaire || false,
                        questionnaireMetadata: result.questionnaireMetadata || undefined
                      }
                    : f
                ));
                const fileTypeMessage = result.isQuestionnaire 
                  ? `questionnaire (${result.questionnaireMetadata?.title || 'Unknown'})`
                  : 'file';
                addConsoleMessage('success', `${fileTypeMessage} uploaded to encrypted storage: ${file.name}`);
                
                if (result.isQuestionnaire) {
                  addConsoleMessage('info', `Questionnaire detected: ${result.questionnaireMetadata?.ageGroup || 'Unknown age group'} - ${result.questionnaireMetadata?.estimatedDuration || 0} minutes`);
                }
              } else {
                setUploadedFiles(prev => prev.map(f => 
                  f.id === tempFile.id ? { ...f, status: 'error' } : f
                ));
                addConsoleMessage('error', `Upload failed: ${file.name} - ${result.error}`);
              }
            } catch (error) {
              setUploadedFiles(prev => prev.map(f => 
                f.id === tempFile.id ? { ...f, status: 'error' } : f
              ));
              addConsoleMessage('error', `Upload error: ${file.name} - ${error instanceof Error ? error.message : 'Unknown error'}`);
            }
          };
          
          reader.readAsText(file);
          continue;
        }
        
        // Use centralized ingestion system for supported file types
        const fileTypeIcons: Record<string, string> = {
          zip: 'üì¶',
          js: '‚ö°',
          json: '‚öôÔ∏è',
          md: 'üìù',
          sh: 'üîß'
        };
        
        const fileIcon = fileTypeIcons[extension] || 'üìÑ';
        addConsoleMessage('info', `${fileIcon} Processing ${extension.toUpperCase()} file: ${file.name}`);
        
        try {
          const formData = new FormData();
          formData.append('file', file);
          
          // Add OMAI notification flag if user wants it
          const notifyOMAI = extension === 'md' || extension === 'js'; // Auto-notify for docs and code
          if (notifyOMAI) {
            formData.append('notifyOMAI', 'true');
          }
          
          addConsoleMessage('info', `üîÑ Sending to centralized ingestion system...`);
          
          const response = await fetch('/api/bigbook/ingest-file', {
            method: 'POST',
            body: formData,
            credentials: 'include'
          });
          
          addConsoleMessage('info', `üì° Response status: ${response.status} ${response.statusText}`);
          
          if (!response.ok) {
            const errorText = await response.text();
            addConsoleMessage('error', `‚ùå HTTP Error ${response.status}: ${errorText}`);
            
            if (response.status === 401) {
              addConsoleMessage('error', `üîê Authentication failed. Please refresh page and try again.`);
              addConsoleMessage('info', `üí° Tip: Make sure you're logged in as super_admin`);
            }
            continue;
          }
          
          const result = await response.json();
          
          if (result.success) {
            const { result: ingestionResult } = result;
            
            addConsoleMessage('success', `‚úÖ ${ingestionResult.message}`);
            addConsoleMessage('info', `üìÇ Type: ${ingestionResult.type}/${ingestionResult.category}`);
            
            // Add type-specific messages
            switch (ingestionResult.type) {
              case 'addon':
                addConsoleMessage('info', `üß© Component available at: ${ingestionResult.item?.route || 'N/A'}`);
                if (ingestionResult.item?.enabled) {
                  addConsoleMessage('success', `‚úÖ Component enabled and ready to use`);
                } else {
                  addConsoleMessage('warning', `‚ö†Ô∏è Component requires manual enable in registry`);
                }
                break;
              case 'doc':
                addConsoleMessage('info', `üìñ Document: ${ingestionResult.item?.title || ingestionResult.item?.name}`);
                if (ingestionResult.item?.webPath) {
                  addConsoleMessage('info', `üîó Web path: ${ingestionResult.item.webPath}`);
                }
                break;
              case 'script':
                addConsoleMessage('info', `üîß Script stored and made executable`);
                addConsoleMessage('warning', `‚ö†Ô∏è Script requires manual enable for security`);
                break;
              case 'config':
                addConsoleMessage('info', `‚öôÔ∏è Configuration active and available`);
                break;
              case 'data':
                addConsoleMessage('info', `üíæ Data archived for manual processing`);
                break;
            }
            
            // Show registry update info
            if (result.registries) {
              const registryNames = Object.keys(result.registries);
              addConsoleMessage('info', `üìä Updated registries: ${registryNames.join(', ')}`);
            }
            
            // OMAI notification status
            if (notifyOMAI) {
              addConsoleMessage('info', `üß† OMAI notified for learning`);
            }
            
          } else {
            addConsoleMessage('error', `‚ùå Ingestion failed: ${result.error}`);
            if (result.debug) {
              addConsoleMessage('info', `üîç Debug info: ${JSON.stringify(result.debug)}`);
            }
          }
          
        } catch (error) {
          addConsoleMessage('error', `‚ùå Ingestion error: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
      } catch (error) {
        addConsoleMessage('error', `File processing error: ${file.name} - ${error instanceof Error ? error.message : 'Unknown error'}`);
      }
    }
  };

  // Get file type from extension
  const getFileTypeFromExtension = (extension: string): FileUpload['type'] => {
    switch (extension) {
      case 'sql':
        return 'sql';
      case 'md':
      case 'markdown':
        return 'markdown';
      case 'js':
      case 'jsx':
      case 'ts':
      case 'tsx':
        return 'javascript';
      case 'sh':
      case 'bash':
      case 'zsh':
        return 'shell';
      case 'py':
      case 'python':
        return 'python';
      case 'html':
      case 'htm':
        return 'html';
      case 'css':
      case 'scss':
      case 'sass':
        return 'css';
      case 'json':
        return 'json';
      case 'xml':
        return 'xml';
      case 'txt':
      case 'log':
        return 'text';
      case 'jpg':
      case 'jpeg':
      case 'png':
      case 'gif':
      case 'svg':
      case 'webp':
        return 'image';
      case 'mp4':
      case 'avi':
      case 'mov':
      case 'wmv':
        return 'video';
      case 'mp3':
      case 'wav':
      case 'ogg':
        return 'audio';
      case 'zip':
      case 'tar':
      case 'gz':
      case 'rar':
        return 'archive';
      case 'pdf':
        return 'pdf';
      default:
        return 'other';
    }
  };

  const executeFile = async (file: FileUpload) => {
    setIsExecuting(true);
    addConsoleMessage('command', `Executing: ${file.name}`);
    
    try {
      // If file is in encrypted storage, retrieve it first
      let content = file.content;
      if (file.encryptedPath) {
        try {
          const retrieveResponse = await fetch(`/api/bigbook/storage/file/${file.id}?encryptedPath=${encodeURIComponent(file.encryptedPath)}`);
          const retrieveResult = await retrieveResponse.json();
          
          if (retrieveResult.success) {
            content = retrieveResult.content;
          } else {
            throw new Error(`Failed to retrieve file from encrypted storage: ${retrieveResult.error}`);
          }
        } catch (retrieveError) {
          addConsoleMessage('error', `Failed to retrieve file from encrypted storage: ${file.name}`, retrieveError instanceof Error ? retrieveError.message : 'Unknown error');
          setIsExecuting(false);
          return;
        }
      }
      
      const response = await fetch('/api/bigbook/execute', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          fileId: file.id,
          fileName: file.name,
          content: content,
          type: file.type,
          settings
        }),
      });

      const result = await response.json();
      
      if (result.success) {
        addConsoleMessage('success', `Execution completed: ${file.name}`, result.output);
      } else {
        addConsoleMessage('error', `Execution failed: ${file.name}`, result.error);
      }
    } catch (error) {
      addConsoleMessage('error', `Execution error: ${file.name}`, error instanceof Error ? error.message : 'Unknown error');
    } finally {
      setIsExecuting(false);
    }
  };

  const removeFile = async (fileId: string) => {
    const file = uploadedFiles.find(f => f.id === fileId);
    
    if (file?.encryptedPath) {
      try {
        const response = await fetch(`/api/bigbook/storage/file/${fileId}?encryptedPath=${encodeURIComponent(file.encryptedPath)}`, {
          method: 'DELETE',
        });
        
        const result = await response.json();
        
        if (result.success) {
          setUploadedFiles(prev => prev.filter(f => f.id !== fileId));
          addConsoleMessage('success', `File removed from encrypted storage: ${file.name}`);
        } else {
          addConsoleMessage('error', `Failed to remove file from encrypted storage: ${file.name} - ${result.error}`);
        }
      } catch (error) {
        addConsoleMessage('error', `Error removing file from encrypted storage: ${file.name} - ${error instanceof Error ? error.message : 'Unknown error'}`);
      }
    } else {
      // Remove from local list only
      setUploadedFiles(prev => prev.filter(f => f.id !== fileId));
      addConsoleMessage('info', 'File removed from list');
    }
  };

  const clearConsole = () => {
    setConsoleOutput([]);
  };

  const saveSettings = async () => {
    try {
      const response = await fetch('/api/bigbook/settings', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(settings),
      });

      if (response.ok) {
        addConsoleMessage('success', 'Settings saved successfully');
        setShowSettings(false);
      } else {
        addConsoleMessage('error', 'Failed to save settings');
      }
    } catch (error) {
      addConsoleMessage('error', 'Error saving settings');
    }
  };

  // Handle questionnaire preview
  const handleQuestionnairePreview = (file: FileUpload) => {
    if (!file.isQuestionnaire) {
      addConsoleMessage('warning', 'File is not a questionnaire');
      return;
    }
    setPreviewFile(file);
    setQuestionnairePreviewOpen(true);
    addConsoleMessage('info', `Opening questionnaire preview: ${file.questionnaireMetadata?.title || file.name}`);
  };

  // Handle questionnaire submission
  const handleQuestionnaireSubmit = async (submission: any) => {
    try {
      addConsoleMessage('info', `Submitting questionnaire responses: ${submission.questionnaireTitle}`);
      
      const response = await fetch('/api/bigbook/submit-response', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(submission),
      });

      const result = await response.json();
      
      if (result.success) {
        addConsoleMessage('success', `Questionnaire submitted successfully (${result.action}): ${submission.questionnaireTitle}`, 
          `Response ID: ${result.responseId}\nResponses: ${submission.responses.length} answers`);
      } else {
        addConsoleMessage('error', `Failed to submit questionnaire: ${result.error}`);
      }
    } catch (error) {
      addConsoleMessage('error', `Error submitting questionnaire: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  };

  // Get file icon
  const getFileIcon = (type: string) => {
    switch (type) {
      case 'sql':
        return <DatabaseIcon />;
      case 'markdown':
        return <ArticleIcon />;
      case 'javascript':
        return <JavaScriptIcon />;
      case 'shell':
        return <ShellScriptIcon />;
      case 'python':
        return <PythonIcon />;
      case 'html':
        return <HtmlIcon />;
      case 'css':
        return <CssIcon />;
      case 'json':
        return <JsonIcon />;
      case 'xml':
        return <XmlIcon />;
      case 'text':
        return <TextIcon />;
      case 'image':
        return <ImageIcon />;
      case 'video':
        return <VideoIcon />;
      case 'audio':
        return <AudioIcon />;
      case 'archive':
        return <ArchiveIcon />;
      case 'pdf':
        return <PdfIcon />;
      case 'script':
        return <CodeIcon />;
      default:
        return <FileTextIcon />;
    }
  };

  // Get file type chip color
  const getFileTypeChip = (type: string) => {
    switch (type) {
      case 'sql':
        return <Chip label="SQL" size="small" color="primary" />;
      case 'markdown':
        return <Chip label="Markdown" size="small" color="info" />;
      case 'javascript':
        return <Chip label="JavaScript" size="small" color="warning" />;
      case 'shell':
        return <Chip label="Shell" size="small" color="success" />;
      case 'python':
        return <Chip label="Python" size="small" color="secondary" />;
      case 'html':
        return <Chip label="HTML" size="small" color="error" />;
      case 'css':
        return <Chip label="CSS" size="small" color="info" />;
      case 'json':
        return <Chip label="JSON" size="small" color="warning" />;
      case 'xml':
        return <Chip label="XML" size="small" color="secondary" />;
      case 'text':
        return <Chip label="Text" size="small" color="default" />;
      case 'image':
        return <Chip label="Image" size="small" color="success" />;
      case 'video':
        return <Chip label="Video" size="small" color="error" />;
      case 'audio':
        return <Chip label="Audio" size="small" color="info" />;
      case 'archive':
        return <Chip label="Archive" size="small" color="warning" />;
      case 'pdf':
        return <Chip label="PDF" size="small" color="error" />;
      case 'script':
        return <Chip label="Script" size="small" color="secondary" />;
      default:
        return <Chip label="Other" size="small" color="default" />;
    }
  };

  const handleTabChange = (event: React.SyntheticEvent, newValue: number) => {
    setActiveTab(newValue);
  };

  return (
    <Box sx={{ p: 3 }}>
      <Stack direction="row" justifyContent="space-between" alignItems="center" sx={{ mb: 3 }}>
        <Box>
          <Typography variant="h4" component="h1" gutterBottom>
            OM Big Book
          </Typography>
          <Typography variant="body1" color="text.secondary">
            Import, manage, and execute all types of files and documents
          </Typography>
        </Box>
        <Button
          variant="outlined"
          startIcon={<SettingsIcon />}
          onClick={() => setShowSettings(!showSettings)}
        >
          Settings
        </Button>
      </Stack>

      <Paper sx={{ width: '100%' }}>
                <Tabs value={activeTab} onChange={handleTabChange} sx={{ borderBottom: 1, borderColor: 'divider' }}>
          <Tab label="Imports & Scripts" />
          <Tab label="File Console" />
          <Tab label="Console" />
          <Tab label="OMAI Discovery" />
          <Tab label="Encrypted Storage" />
          <Tab label="Registry Management" />
        </Tabs>

        <Box sx={{ p: 3 }}>
          {activeTab === 0 && (
            <Stack spacing={3}>
              {/* Settings Panel */}
              {showSettings && (
                <Card>
                  <CardContent>
                    <Typography variant="h6" gutterBottom sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                      <SettingsIcon />
                      Big Book Settings
                    </Typography>
                                         <Stack spacing={3}>
                       <Box sx={{ display: 'flex', gap: 2, flexWrap: 'wrap' }}>
                         <TextField
                           sx={{ flex: 1, minWidth: 250 }}
                           label="Database User"
                           value={settings.databaseUser}
                           onChange={(e) => setSettings(prev => ({ ...prev, databaseUser: e.target.value }))}
                           placeholder="root"
                         />
                         <TextField
                           sx={{ flex: 1, minWidth: 250 }}
                           type="password"
                           label="Database Password"
                           value={settings.databasePassword}
                           onChange={(e) => setSettings(prev => ({ ...prev, databasePassword: e.target.value }))}
                           placeholder="Enter database password"
                         />
                       </Box>
                       <Box sx={{ display: 'flex', gap: 2, flexWrap: 'wrap' }}>
                         <TextField
                           sx={{ flex: 1, minWidth: 250 }}
                           label="Default Database"
                           value={settings.defaultDatabase}
                           onChange={(e) => setSettings(prev => ({ ...prev, defaultDatabase: e.target.value }))}
                           placeholder="omai_db"
                         />
                         <TextField
                           sx={{ flex: 1, minWidth: 250 }}
                           type="number"
                           label="Script Timeout (ms)"
                           value={settings.scriptTimeout}
                           onChange={(e) => setSettings(prev => ({ ...prev, scriptTimeout: parseInt(e.target.value) }))}
                         />
                       </Box>
                       <FormControlLabel
                         control={
                           <Switch
                             checked={settings.useSudo}
                             onChange={(e) => setSettings(prev => ({ ...prev, useSudo: e.target.checked }))}
                           />
                         }
                         label="Use Sudo for Script Execution"
                       />
                       {settings.useSudo && (
                         <TextField
                           fullWidth
                           type="password"
                           label="Sudo Password"
                           value={settings.sudoPassword}
                           onChange={(e) => setSettings(prev => ({ ...prev, sudoPassword: e.target.value }))}
                           placeholder="Enter sudo password"
                         />
                       )}
                       <Button
                         variant="contained"
                         startIcon={<SaveIcon />}
                         onClick={saveSettings}
                       >
                         Save Settings
                       </Button>
                     </Stack>
                  </CardContent>
                </Card>
              )}

              {/* File Upload Area */}
              <Card>
                <CardContent>
                  <Typography variant="h6" gutterBottom>
                    File Upload
                  </Typography>
                  <Box
                    sx={{
                      border: '2px dashed',
                      borderColor: 'grey.300',
                      borderRadius: 2,
                      p: 4,
                      textAlign: 'center',
                      cursor: 'pointer',
                      '&:hover': {
                        borderColor: 'primary.main',
                        backgroundColor: 'action.hover'
                      }
                    }}
                    onDrop={handleFileDrop}
                    onDragOver={handleDragOver}
                    onClick={() => fileInputRef.current?.click()}
                  >
                    <CloudUploadIcon sx={{ fontSize: 48, color: 'grey.500', mb: 2 }} />
                    <Typography variant="h6" gutterBottom>
                      Drop files here or click to upload
                    </Typography>
                    <Typography variant="body2" color="text.secondary">
                      Supports all file types: .md, .js, .sh, .py, .sql, .html, .css, .json, .xml, .txt, .pdf, images, videos, audio, archives (max 10MB)
                    </Typography>
                    <Typography variant="body2" color="primary.main" sx={{ mt: 1, fontWeight: 'bold' }}>
                      üó∫Ô∏è Special: Drop Parish Map .zip files for auto-installation!
                    </Typography>
                    <input
                      ref={fileInputRef}
                      type="file"
                      multiple
                      accept=".md,.js,.jsx,.ts,.tsx,.sh,.bash,.py,.sql,.html,.htm,.css,.scss,.sass,.json,.xml,.txt,.log,.pdf,.jpg,.jpeg,.png,.gif,.svg,.webp,.mp4,.avi,.mov,.wmv,.mp3,.wav,.ogg,.zip,.tar,.gz,.rar"
                      onChange={handleFileInputChange}
                      style={{ display: 'none' }}
                    />
                  </Box>
                </CardContent>
              </Card>

              {/* Uploaded Files List */}
              {uploadedFiles.length > 0 && (
                <Card>
                  <CardContent>
                    <Typography variant="h6" gutterBottom>
                      Uploaded Files
                    </Typography>
                    <List>
                      {uploadedFiles.map((file) => (
                        <ListItem key={file.id} divider>
                          <ListItemIcon>
                            {getFileIcon(file.type)}
                          </ListItemIcon>
                          <ListItemText
                            primary={file.name}
                            secondary={`${(file.size / 1024).toFixed(1)} KB ‚Ä¢ ${file.uploadedAt.toLocaleString()}`}
                          />
                          <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                            {getFileTypeChip(file.type)}
                            <Tooltip title="Execute">
                              <IconButton
                                onClick={() => executeFile(file)}
                                disabled={isExecuting}
                                color="primary"
                              >
                                <PlayIcon />
                              </IconButton>
                            </Tooltip>
                            <Tooltip title="Remove">
                              <IconButton
                                onClick={() => removeFile(file.id)}
                                color="error"
                              >
                                <Trash2Icon />
                              </IconButton>
                            </Tooltip>
                          </Box>
                        </ListItem>
                      ))}
                    </List>
                  </CardContent>
                </Card>
              )}
            </Stack>
          )}

          {activeTab === 1 && (
            <BigBookConsolePage
              files={uploadedFiles}
              consoleOutput={consoleOutput}
              isExecuting={isExecuting}
              onFileSelect={setSelectedFile}
              onFileExecute={executeFile}
              onFileDelete={removeFile}
              onQuestionnairePreview={handleQuestionnairePreview}
              onClearConsole={clearConsole}
              selectedFile={selectedFile}
            />
          )}

          {activeTab === 2 && (
            <Box>
              <Stack direction="row" justifyContent="space-between" alignItems="center" sx={{ mb: 2 }}>
                <Typography variant="h6">
                  Console Output
                </Typography>
                <Button
                  variant="outlined"
                  startIcon={<RefreshCwIcon />}
                  onClick={clearConsole}
                  size="small"
                >
                  Clear Console
                </Button>
              </Stack>
              
              <Paper
                ref={consoleRef}
                sx={{
                  height: 400,
                  overflow: 'auto',
                  p: 2,
                  backgroundColor: '#1e1e1e',
                  color: '#ffffff',
                  fontFamily: 'monospace',
                  fontSize: '0.875rem'
                }}
              >
                {consoleOutput.length === 0 ? (
                  <Typography color="grey.500" textAlign="center">
                    No console output yet. Upload and execute files to see results.
                  </Typography>
                ) : (
                  consoleOutput.map((output) => (
                    <Box key={output.id} sx={{ mb: 1 }}>
                      <Typography
                        component="span"
                        sx={{
                          color: output.type === 'error' ? '#ff6b6b' :
                                 output.type === 'success' ? '#51cf66' :
                                 output.type === 'warning' ? '#ffd43b' :
                                 output.type === 'command' ? '#74c0fc' : '#ffffff',
                          fontWeight: output.type === 'command' ? 'bold' : 'normal'
                        }}
                      >
                        [{output.timestamp.toLocaleTimeString()}] {output.message}
                      </Typography>
                      {output.details && (
                        <Typography
                          component="div"
                          sx={{
                            color: '#adb5bd',
                            ml: 2,
                            mt: 0.5,
                            whiteSpace: 'pre-wrap'
                          }}
                        >
                          {output.details}
                        </Typography>
                      )}
                    </Box>
                  ))
                )}
              </Paper>
            </Box>
          )}

          {activeTab === 3 && (
            <OMAIDiscoveryPanel />
          )}

          {activeTab === 4 && (
            <EncryptedStoragePanel />
          )}

          {activeTab === 5 && (
            <RegistryManagementPanel 
              registriesLoading={registriesLoading}
              registriesError={registriesError}
              registries={registries}
              loadRegistries={loadRegistries}
              toggleItemStatus={toggleItemStatus}
            />
          )}
        </Box>
      </Paper>

      {/* Questionnaire Preview Modal */}
      <QuestionnairePreview
        open={questionnairePreviewOpen}
        onClose={() => {
          setQuestionnairePreviewOpen(false);
          setPreviewFile(null);
        }}
        file={previewFile}
        onSubmit={handleQuestionnaireSubmit}
      />

      {/* TSX Component Installation Wizard */}
      <TSXComponentInstallWizard
        open={tsxWizardOpen}
        onClose={() => {
          setTsxWizardOpen(false);
          setTsxFile(null);
        }}
        file={tsxFile}
        onInstallComplete={(result) => {
          addConsoleMessage('success', `Component installation completed: ${result.componentName}`);
          if (result.previewUrl) {
            addConsoleMessage('info', `Preview available at: ${result.previewUrl}`);
          }
        }}
        onConsoleMessage={addConsoleMessage}
      />
    </Box>
  );


};

export default OMBigBook; 