/**
 * Utility functions for OCR Field Mapping
 * Generated by Phase 1 setup script
 */

import {
  FieldConfig,
  RecordFieldConfig, 
  MappedFieldResult,
  OcrTextProcessingResult,
  RecordType,
  DEFAULT_BAPTISM_FIELDS,
  DEFAULT_MARRIAGE_FIELDS,
  DEFAULT_FUNERAL_FIELDS
} from './ocrTypes';

/**
 * Get default field configuration for a record type
 */
export function getDefaultFieldConfig(recordType: RecordType): FieldConfig[] {
  switch (recordType) {
    case 'baptism':
      return DEFAULT_BAPTISM_FIELDS;
    case 'marriage':
      return DEFAULT_MARRIAGE_FIELDS;
    case 'funeral':
      return DEFAULT_FUNERAL_FIELDS;
    default:
      throw new Error(`Unknown record type: ${recordType}`);
  }
}

/**
 * Validate a field value against its configuration
 */
export function validateField(value: string, config: FieldConfig): { valid: boolean; error?: string } {
  if (config.required && (!value || value.trim() === '')) {
    return { valid: false, error: 'Field is required' };
  }
  
  if (value && config.validation) {
    if (config.validation === 'date') {
      const dateRegex = /^\d{4}-\d{2}-\d{2}$/;
      if (!dateRegex.test(value)) {
        return { valid: false, error: 'Invalid date format (expected YYYY-MM-DD)' };
      }
      const date = new Date(value);
      if (isNaN(date.getTime())) {
        return { valid: false, error: 'Invalid date' };
      }
    } else if (config.validation === 'email') {
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      if (!emailRegex.test(value)) {
        return { valid: false, error: 'Invalid email format' };
      }
    } else {
      // Treat as regex
      try {
        const regex = new RegExp(config.validation);
        if (!regex.test(value)) {
          return { valid: false, error: 'Value does not match required format' };
        }
      } catch (error) {
        console.warn(`Invalid regex in field config: ${config.validation}`);
      }
    }
  }
  
  return { valid: true };
}

/**
 * Transform field value according to configuration
 */
export function transformFieldValue(value: string, config: FieldConfig): string {
  if (!value) return value;
  
  let transformed = value;
  
  if (config.transform) {
    switch (config.transform) {
      case 'uppercase':
        transformed = transformed.toUpperCase();
        break;
      case 'lowercase':
        transformed = transformed.toLowerCase();
        break;
      case 'titlecase':
        transformed = transformed.toLowerCase().replace(/\b\w/g, l => l.toUpperCase());
        break;
      case 'trim':
        transformed = transformed.trim();
        break;
    }
  }
  
  return transformed;
}

/**
 * Calculate average confidence from mapped fields
 */
export function calculateAverageConfidence(mappedFields: MappedFieldResult[]): number {
  if (mappedFields.length === 0) return 0;
  
  const totalConfidence = mappedFields.reduce((sum, field) => sum + field.confidence, 0);
  return Math.round(totalConfidence / mappedFields.length);
}

/**
 * Check if OCR result is auto-insertable based on configuration
 */
export function isAutoInsertable(
  mappedFields: MappedFieldResult[],
  config: RecordFieldConfig
): boolean {
  const avgConfidence = calculateAverageConfidence(mappedFields);
  
  // Check overall confidence threshold
  if (avgConfidence < config.settings.auto_insert_threshold) {
    return false;
  }
  
  // Check if any required field is missing or has validation errors
  const requiredFields = config.fields.filter(f => f.required);
  for (const requiredField of requiredFields) {
    const mappedField = mappedFields.find(f => f.field === requiredField.target_column);
    if (!mappedField || !mappedField.validation_passed) {
      return false;
    }
  }
  
  // Check if any field requires manual review
  for (const fieldName of config.settings.require_manual_review) {
    const mappedField = mappedFields.find(f => f.field === fieldName);
    if (mappedField) {
      return false; // Has a field that requires manual review
    }
  }
  
  return true;
}

/**
 * Generate a processing result summary
 */
export function generateProcessingResult(
  rawText: string,
  mappedFields: MappedFieldResult[],
  config: RecordFieldConfig
): OcrTextProcessingResult {
  const avgConfidence = calculateAverageConfidence(mappedFields);
  const validationErrors: string[] = [];
  const processingNotes: string[] = [];
  
  // Collect validation errors
  mappedFields.forEach(field => {
    if (!field.validation_passed && field.error_message) {
      validationErrors.push(`${field.field}: ${field.error_message}`);
    }
  });
  
  // Check for missing required fields
  const requiredFields = config.fields.filter(f => f.required);
  requiredFields.forEach(reqField => {
    const found = mappedFields.find(f => f.field === reqField.target_column);
    if (!found) {
      validationErrors.push(`Missing required field: ${reqField.target_column}`);
    }
  });
  
  const autoInsertable = isAutoInsertable(mappedFields, config);
  const requiresReview = !autoInsertable || 
    avgConfidence < config.settings.confidence_warning_threshold ||
    validationErrors.length > 0;
  
  if (avgConfidence < config.settings.confidence_warning_threshold) {
    processingNotes.push(`Low confidence: ${avgConfidence}% (threshold: ${config.settings.confidence_warning_threshold}%)`);
  }
  
  if (validationErrors.length > 0) {
    processingNotes.push(`${validationErrors.length} validation error(s) found`);
  }
  
  return {
    raw_text: rawText,
    mapped_fields: mappedFields,
    confidence_avg: avgConfidence,
    validation_errors: validationErrors,
    auto_insertable: autoInsertable,
    requires_review: requiresReview,
    processing_notes: processingNotes
  };
}
