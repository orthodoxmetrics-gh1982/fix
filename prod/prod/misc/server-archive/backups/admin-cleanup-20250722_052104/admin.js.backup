// server/routes/admin.js
const express = require('express');
const { promisePool } = require('../../config/db');
const bcrypt = require('bcrypt');
const { 
    canManageUser, 
    canPerformDestructiveOperation, 
    canChangeRole,
    isRootSuperAdmin,
    logUnauthorizedAttempt,
    ROOT_SUPERADMIN_EMAIL
} = require('../middleware/userAuthorization');

const router = express.Router();

// Middleware to check if user is admin or super_admin
const requireAdmin = async (req, res, next) => {
    console.log('ðŸ”’ requireAdmin middleware - checking session...');
    console.log('   Session ID:', req.sessionID);
    console.log('   Session exists:', !!req.session);
    console.log('   Session user exists:', !!req.session?.user);
    console.log('   Session user:', req.session?.user);
    console.log('   Request headers (cookie):', req.headers.cookie);
    console.log('   User Agent:', req.headers['user-agent']);

    // ðŸ”§ ENHANCED DEBUG: Check session store directly
    if (req.sessionID && req.sessionStore) {
        try {
            const sessionData = await new Promise((resolve, reject) => {
                req.sessionStore.get(req.sessionID, (err, session) => {
                    if (err) reject(err);
                    else resolve(session);
                });
            });
            console.log('   Session from store:', sessionData);
        } catch (storeErr) {
            console.log('   Session store error:', storeErr.message);
        }
    }

    if (!req.session || !req.session.user) {
        console.log('âŒ No authenticated user found');
        return res.status(401).json({
            success: false,
            message: 'Authentication required',
            debug: {
                sessionExists: !!req.session,
                sessionId: req.sessionID,
                hasCookie: !!req.headers.cookie,
                timestamp: new Date().toISOString()
            }
        });
    }

    const userRole = req.session.user.role;
    console.log('   User role:', userRole);

    if (userRole !== 'admin' && userRole !== 'super_admin') {
        console.log('âŒ Insufficient privileges');
        return res.status(403).json({
            success: false,
            message: 'Administrative privileges required'
        });
    }

    console.log('âœ… Admin access granted');
    next();
};

// Middleware to check if user is super_admin only
const requireSuperAdmin = async (req, res, next) => {
    if (!req.session.user) {
        console.log('âŒ No authenticated user found in super admin middleware');
        return res.status(401).json({
            success: false,
            message: 'Authentication required'
        });
    }

    const userRole = req.session.user.role;
    if (userRole !== 'super_admin') {
        return res.status(403).json({
            success: false,
            message: 'Super administrator privileges required'
        });
    }

    next();
};

// Middleware to check if user can create/edit users with specific roles
const requireRolePermission = async (req, res, next) => {
    if (!req.session.user) {
        console.log('âŒ No authenticated user found in role permission middleware');
        return res.status(401).json({
            success: false,
            message: 'Authentication required'
        });
    }

    const userRole = req.session.user.role;
    const targetRole = req.body.role;

    console.log('ðŸ” Role permission check:');
    console.log('  User role:', userRole);
    console.log('  Target role:', targetRole);

    // Super admin can create/edit any role except super_admin
    if (userRole === 'super_admin') {
        if (targetRole === 'super_admin') {
            console.log('âŒ Super admin cannot create super_admin users');
            return res.status(403).json({
                success: false,
                message: 'Cannot create or modify super_admin users'
            });
        }
        console.log('âœ… Super admin can create', targetRole, 'users');
        return next();
    }

    // Regular admin can only create/edit non-admin roles
    if (userRole === 'admin') {
        if (targetRole === 'admin' || targetRole === 'super_admin') {
            console.log('âŒ Regular admin cannot create admin/super_admin users');
            return res.status(403).json({
                success: false,
                message: 'Cannot create or modify admin or super_admin users'
            });
        }
        console.log('âœ… Regular admin can create', targetRole, 'users');
        return next();
    }

    console.log('âŒ No permission for role:', userRole);
    return res.status(403).json({
        success: false,
        message: 'Insufficient privileges'
    });
};

// Debug middleware for admin routes
router.use((req, res, next) => {
    console.log(`ðŸ”§ Admin route: ${req.method} ${req.path} - Original URL: ${req.originalUrl}`);
    next();
});

// GET /admin/users - Get all users
router.get('/users', requireAdmin, async (req, res) => {
    try {
        console.log('ðŸ” Admin users request from:', req.session.user?.email);

        // First, try a simple query to test connectivity
        const [testRows] = await promisePool.query('SELECT COUNT(*) as count FROM users');
        console.log('âœ… Database connection working, total users:', testRows[0].count);

        // Now try the full query
        const [rows] = await promisePool.query(`
      SELECT 
        u.id,
        u.email,
        u.first_name,
        u.last_name,
        u.role,
        u.church_id,
        c.name as church_name,
        u.is_active,
        u.email_verified,
        u.preferred_language,
        u.timezone,
        u.landing_page,
        u.created_at,
        u.updated_at,
        u.last_login
      FROM users u
      LEFT JOIN churches c ON u.church_id = c.id
      ORDER BY u.created_at DESC
    `);

        console.log('âœ… Query successful, returned', rows.length, 'users');

        res.json({
            success: true,
            users: rows
        });
    } catch (err) {
        console.error('âŒ Error fetching users:', err.message);
        console.error('âŒ Full error:', err);
        res.status(500).json({
            success: false,
            message: 'Server error while fetching users',
            error: err.message
        });
    }
});

// POST /admin/users - Create new user
router.post('/users', requireRolePermission, async (req, res) => {
    try {
        const {
            email,
            first_name,
            last_name,
            role,
            church_id,
            preferred_language,
            send_welcome_email
        } = req.body;

        // Validate required fields
        if (!email || !first_name || !last_name || !role) {
            return res.status(400).json({
                success: false,
                message: 'Email, first name, last name, and role are required'
            });
        }

        // Check if email already exists
        const [existingUsers] = await promisePool.query(
            'SELECT id FROM users WHERE email = ?',
            [email]
        );

        if (existingUsers.length > 0) {
            return res.status(400).json({
                success: false,
                message: 'Email address is already in use'
            });
        }

        // Generate temporary password
        const tempPassword = Math.random().toString(36).slice(-12) + Math.random().toString(36).slice(-12);

        // Hash the password
        const saltRounds = 12;
        const passwordHash = await bcrypt.hash(tempPassword, saltRounds);

        // Insert new user
        const [result] = await promisePool.query(`
      INSERT INTO users (
        email, 
        first_name, 
        last_name, 
        password_hash, 
        role, 
        church_id, 
        preferred_language, 
        is_active,
        created_at,
        updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, 1, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
    `, [
            email,
            first_name,
            last_name,
            passwordHash,
            role,
            church_id || null,
            preferred_language || 'en'
        ]);

        console.log(`âœ… User created successfully: ${email} by admin ${req.session.user.email}`);

        // TODO: Send welcome email if requested
        if (send_welcome_email) {
            console.log(`ðŸ“§ Welcome email would be sent to ${email} with password: ${tempPassword}`);
        }

        res.json({
            success: true,
            message: 'User created successfully',
            userId: result.insertId,
            tempPassword: tempPassword
        });

    } catch (err) {
        console.error('Error creating user:', err);
        res.status(500).json({
            success: false,
            message: 'Server error while creating user'
        });
    }
});

// PUT /admin/users/:id - Update user
router.put('/users/:id', requireAdmin, async (req, res) => {
    try {
        const userId = parseInt(req.params.id);
        const {
            email,
            first_name,
            last_name,
            role,
            church_id,
            preferred_language,
            is_active
        } = req.body;

        const currentUser = req.session.user;

        // Get the target user being edited
        const [targetUserRows] = await promisePool.query(
            'SELECT id, email, role, first_name, last_name FROM users WHERE id = ?',
            [userId]
        );

        if (targetUserRows.length === 0) {
            return res.status(404).json({
                success: false,
                message: 'User not found'
            });
        }

        const targetUser = targetUserRows[0];

        // Check if current user can manage the target user
        if (!canManageUser(currentUser, targetUser)) {
            logUnauthorizedAttempt(currentUser, targetUser, 'UPDATE_USER');
            return res.status(403).json({
                success: false,
                message: 'You do not have permission to modify this user',
                code: 'INSUFFICIENT_PRIVILEGES'
            });
        }

        // Check if current user can change the role
        if (role && role !== targetUser.role) {
            if (!canChangeRole(currentUser, targetUser, role)) {
                logUnauthorizedAttempt(currentUser, targetUser, 'CHANGE_ROLE');
                return res.status(403).json({
                    success: false,
                    message: `You do not have permission to assign the role '${role}'`,
                    code: 'ROLE_CHANGE_DENIED'
                });
            }
        }

        // Validate required fields
        if (!email || !first_name || !last_name || !role) {
            return res.status(400).json({
                success: false,
                message: 'Email, first name, last name, and role are required'
            });
        }

        // Check if email is already taken by another user
        const [existingUsers] = await promisePool.query(
            'SELECT id FROM users WHERE email = ? AND id != ?',
            [email, userId]
        );

        if (existingUsers.length > 0) {
            return res.status(400).json({
                success: false,
                message: 'Email address is already in use'
            });
        }

        // Update user
        await promisePool.query(`
            UPDATE users 
            SET 
                email = ?,
                first_name = ?,
                last_name = ?,
                role = ?,
                church_id = ?,
                preferred_language = ?,
                is_active = ?,
                updated_at = CURRENT_TIMESTAMP
            WHERE id = ?
        `, [
            email,
            first_name,
            last_name,
            role,
            church_id || null,
            preferred_language || 'en',
            is_active ? 1 : 0,
            userId
        ]);

        console.log(`âœ… User updated successfully: ${email} by ${currentUser.email} (role: ${currentUser.role})`);

        res.json({
            success: true,
            message: 'User updated successfully'
        });

    } catch (err) {
        console.error('Error updating user:', err);
        res.status(500).json({
            success: false,
            message: 'Server error while updating user'
        });
    }
});

// DELETE /admin/users/:id - Delete user
router.delete('/users/:id', requireAdmin, async (req, res) => {
    try {
        const userId = parseInt(req.params.id);
        const currentUser = req.session.user;

        // Don't allow deletion of the current user
        if (userId === currentUser.id) {
            return res.status(400).json({
                success: false,
                message: 'You cannot delete your own account'
            });
        }

        // Get target user information
        const [userRows] = await promisePool.query(
            'SELECT id, email, role, first_name, last_name FROM users WHERE id = ?',
            [userId]
        );

        if (userRows.length === 0) {
            return res.status(404).json({
                success: false,
                message: 'User not found'
            });
        }

        const targetUser = userRows[0];

        // Check if current user can perform destructive operations on target user
        if (!canPerformDestructiveOperation(currentUser, targetUser)) {
            logUnauthorizedAttempt(currentUser, targetUser, 'DELETE_USER');
            return res.status(403).json({
                success: false,
                message: 'You do not have permission to delete this user',
                code: 'DELETE_DENIED'
            });
        }

        // Delete user
        await promisePool.query('DELETE FROM users WHERE id = ?', [userId]);

        console.log(`âœ… User deleted successfully: ${targetUser.email} by ${currentUser.email} (role: ${currentUser.role})`);

        res.json({
            success: true,
            message: 'User deleted successfully'
        });

    } catch (err) {
        console.error('Error deleting user:', err);
        res.status(500).json({
            success: false,
            message: 'Server error while deleting user'
        });
    }
});

// PUT /admin/users/:id/toggle-status - Toggle user active status
router.put('/users/:id/toggle-status', requireAdmin, async (req, res) => {
    try {
        const userId = parseInt(req.params.id);
        const currentUser = req.session.user;

        // Don't allow deactivation of the current user
        if (userId === currentUser.id) {
            return res.status(400).json({
                success: false,
                message: 'You cannot deactivate your own account'
            });
        }

        // Get target user information
        const [userRows] = await promisePool.query(
            'SELECT id, email, role, first_name, last_name, is_active FROM users WHERE id = ?',
            [userId]
        );

        if (userRows.length === 0) {
            return res.status(404).json({
                success: false,
                message: 'User not found'
            });
        }

        const targetUser = userRows[0];

        // Check if current user can perform destructive operations (deactivating is considered destructive)
        if (!canPerformDestructiveOperation(currentUser, targetUser)) {
            logUnauthorizedAttempt(currentUser, targetUser, 'TOGGLE_STATUS');
            return res.status(403).json({
                success: false,
                message: 'You do not have permission to change this user\'s status',
                code: 'STATUS_CHANGE_DENIED'
            });
        }

        const currentStatus = targetUser.is_active;
        const newStatus = currentStatus ? 0 : 1;

        // Update status
        await promisePool.query(
            'UPDATE users SET is_active = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?',
            [newStatus, userId]
        );

        console.log(`âœ… User status toggled: ${targetUser.email} -> ${newStatus ? 'active' : 'inactive'} by ${currentUser.email} (role: ${currentUser.role})`);

        res.json({
            success: true,
            message: `User ${newStatus ? 'activated' : 'deactivated'} successfully`
        });

    } catch (err) {
        console.error('Error toggling user status:', err);
        res.status(500).json({
            success: false,
            message: 'Server error while updating user status'
        });
    }
});

// GET /admin/churches - Get all churches (for admin panel)
router.get('/churches', requireAdmin, async (req, res) => {
    try {
        console.log('ðŸ” Admin churches request from:', req.session.user?.email);

        // Support filtering by preferred_language for template selection
        const { preferred_language } = req.query;
        let additionalFilter = '';
        let queryParams = [];

        if (preferred_language) {
            additionalFilter = 'AND preferred_language = ?';
            queryParams.push(preferred_language);
        }

        const query = `
            SELECT 
                id, name, email, phone, address, city, state_province, postal_code, 
                country, website, preferred_language, timezone, currency, tax_id,
                description_multilang, settings, is_active, database_name,
                has_baptism_records, has_marriage_records, has_funeral_records, 
                setup_complete, created_at, updated_at
            FROM churches 
            WHERE is_active = 1
            ${additionalFilter}
            ORDER BY created_at DESC
        `;

        const [churches] = await promisePool.query(query, queryParams);

        console.log('ðŸ“‹ Retrieved', churches.length, 'churches from orthodoxmetrics_db');
        res.json({
            success: true,
            churches: churches.map(church => ({
                id: church.id,
                church_id: church.id, // Use database ID as church_id for compatibility
                name: church.name,
                email: church.email,
                phone: church.phone,
                address: church.address,
                city: church.city,
                state_province: church.state_province,
                postal_code: church.postal_code,
                country: church.country,
                website: church.website,
                preferred_language: church.preferred_language || 'en',
                timezone: church.timezone || 'UTC',
                currency: church.currency || 'USD',
                tax_id: church.tax_id,
                description_multilang: church.description_multilang,
                settings: church.settings,
                is_active: church.is_active,
                database_name: church.database_name,
                setup_complete: church.setup_complete,
                created_at: church.created_at,
                updated_at: church.updated_at,
                // Backward compatibility aliases
                admin_email: church.email,
                church_name: church.name,
                language_preference: church.preferred_language || 'en'
            }))
        });
    } catch (error) {
        console.error('âŒ Error fetching churches for admin:', error);
        res.status(500).json({
            success: false,
            message: 'Failed to fetch churches',
            error: error.message
        });
    }
});

// GET /admin/churches/:id - Get individual church by ID (admin only)
router.get('/churches/:id', requireAdmin, async (req, res) => {
    try {
        const churchId = parseInt(req.params.id);
        console.log('ðŸ” Admin request for church ID:', churchId, 'from:', req.session.user?.email);

        if (isNaN(churchId)) {
            return res.status(400).json({
                success: false,
                message: 'Invalid church ID format'
            });
        }

        const [churchResult] = await promisePool.query(
            `SELECT 
                id, name, email, phone, address, city, state_province, postal_code, 
                country, website, preferred_language, timezone, currency, tax_id,
                description_multilang, settings, is_active, database_name,
                has_baptism_records, has_marriage_records, has_funeral_records, 
                setup_complete, created_at, updated_at
            FROM churches 
            WHERE id = ? AND is_active = 1`,
            [churchId]
        );

        if (churchResult.length === 0) {
            console.log('âŒ Church not found with ID:', churchId);
            return res.status(404).json({
                success: false,
                message: 'Church not found'
            });
        }

        const church = churchResult[0];
        console.log('âœ… Church found for editing:', church.name);

        res.json({
            success: true,
            ...church, // Return the church data directly for compatibility with frontend
            church_id: church.id, // Add church_id for frontend compatibility
            // Add backward compatibility aliases
            admin_email: church.email,
            church_name: church.name,
            language_preference: church.preferred_language || 'en'
        });
    } catch (error) {
        console.error('âŒ Error fetching church for admin:', error);
        res.status(500).json({
            success: false,
            message: 'Failed to fetch church',
            error: error.message
        });
    }
});

// POST /admin/churches - Create new church (super_admin only)
router.post('/churches', requireSuperAdmin, async (req, res) => {
    try {
        console.log('ðŸ›ï¸ Creating new church with data:', req.body);
        
        const {
            name,
            email,
            phone,
            address,
            city,
            state_province,
            postal_code,
            country,
            website,
            preferred_language = 'en',
            timezone = 'UTC',
            currency = 'USD',
            is_active = true,
            template_church_id = null, // New template selection field
            // Template setup options
            setup_templates = false,
            auto_setup_standard = false,
            generate_components = false,
            record_types = ['baptism', 'marriage', 'funeral'],
            template_style = 'orthodox_traditional'
        } = req.body;

        // Validate required fields
        if (!name || !email) {
            return res.status(400).json({
                success: false,
                message: 'Church name and email are required'
            });
        }

        // Check if church name already exists
        const [existingChurches] = await promisePool.query(
            'SELECT id FROM churches WHERE name = ?',
            [name]
        );

        if (existingChurches.length > 0) {
            return res.status(400).json({
                success: false,
                message: 'Church name already exists'
            });
        }

        // Check if email already exists
        const [existingEmails] = await promisePool.query(
            'SELECT id FROM churches WHERE email = ?',
            [email]
        );

        if (existingEmails.length > 0) {
            return res.status(400).json({
                success: false,
                message: 'Email already in use'
            });
        }

        // If template church is specified, validate it exists and is English
        let templateChurch = null;
        if (template_church_id) {
            const [templateChurches] = await promisePool.query(
                'SELECT * FROM churches WHERE id = ? AND preferred_language = ? AND is_active = 1',
                [template_church_id, 'en']
            );

            if (templateChurches.length === 0) {
                return res.status(400).json({
                    success: false,
                    message: 'Template church not found or not an active English church'
                });
            }

            templateChurch = templateChurches[0];
            console.log('ðŸŽ¯ Using template church:', templateChurch.name);
        }

        // Generate unique church_id (critical for cross-database consistency)
        const generateChurchId = (churchName) => {
            const prefix = churchName
                .split(' ')
                .map(word => word.charAt(0).toUpperCase())
                .join('')
                .substring(0, 6);
            const timestamp = Date.now().toString().slice(-6);
            return parseInt(`${timestamp}${Math.floor(Math.random() * 100)}`);
        };

        const church_id = generateChurchId(name);
        
        // Generate database name starting with church_id
        const sanitizedName = name
            .toLowerCase()
            .replace(/[^a-z0-9\s]/g, '')
            .replace(/\s+/g, '_')
            .substring(0, 30); // Shorter to accommodate church_id prefix
        
        const database_name = `${church_id}_${sanitizedName}_db`;

        // Insert new church into orthodoxmetrics_db.churches
        const [result] = await promisePool.query(`
            INSERT INTO churches (
                name, email, phone, address, city, state_province, postal_code, 
                country, website, preferred_language, timezone, currency, is_active,
                database_name, setup_complete, created_at, updated_at,
                -- Legacy compatibility fields
                church_name, admin_email, language_preference
            ) 
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, ?, ?, ?)
        `, [
            name, email, phone, address, city, state_province, postal_code,
            country, website, preferred_language, timezone, currency, is_active ? 1 : 0,
            database_name, false, // setup_complete = false initially
            // Legacy compatibility
            name, email, preferred_language
        ]);

        const newChurchDbId = result.insertId;
        console.log('âœ… Church created in orthodoxmetrics_db with ID:', newChurchDbId);

        // Create individual church database and set up with consistent church_id
        try {
            console.log('ðŸ”„ Creating church-specific database:', database_name);
            
            // Create the database
            await promisePool.query(`CREATE DATABASE IF NOT EXISTS \`${database_name}\``);
            
            // Create basic church schema in the new database
            await promisePool.query(`USE \`${database_name}\``);
            
            // Create church info table with the same church_id
            await promisePool.query(`
                CREATE TABLE IF NOT EXISTS church_info (
                    id INT PRIMARY KEY AUTO_INCREMENT,
                    church_id INT NOT NULL DEFAULT ${church_id},
                    name VARCHAR(255) NOT NULL DEFAULT '${name}',
                    email VARCHAR(255) NOT NULL DEFAULT '${email}',
                    phone VARCHAR(50),
                    address TEXT,
                    city VARCHAR(100),
                    state_province VARCHAR(100),
                    country VARCHAR(100),
                    preferred_language VARCHAR(10) DEFAULT '${preferred_language}',
                    timezone VARCHAR(50) DEFAULT '${timezone}',
                    currency VARCHAR(10) DEFAULT '${currency}',
                    is_active BOOLEAN DEFAULT TRUE,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                    UNIQUE KEY uk_church_id (church_id)
                )
            `);

            // Insert the church info with consistent church_id
            await promisePool.query(`
                INSERT INTO church_info (
                    church_id, name, email, phone, address, city, state_province, 
                    country, preferred_language, timezone, currency, is_active
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            `, [
                church_id, name, email, phone, address, city, state_province,
                country, preferred_language, timezone, currency, is_active ? 1 : 0
            ]);

            // If template church is specified, clone its structure
            if (templateChurch && templateChurch.database_name) {
                console.log('ðŸŽ¯ Cloning structure from template church database:', templateChurch.database_name);
                
                try {
                    // Clone table structures (excluding data for now)
                    const [templateTables] = await promisePool.query(`
                        SELECT TABLE_NAME 
                        FROM information_schema.TABLES 
                        WHERE TABLE_SCHEMA = ? 
                        AND TABLE_NAME NOT IN ('church_info')
                    `, [templateChurch.database_name]);

                    for (const table of templateTables) {
                        const tableName = table.TABLE_NAME;
                        console.log(`ðŸ“‹ Cloning table structure: ${tableName}`);
                        
                        // Get CREATE TABLE statement from template
                        const [createTableResult] = await promisePool.query(`SHOW CREATE TABLE \`${templateChurch.database_name}\`.\`${tableName}\``);
                        let createStatement = createTableResult[0]['Create Table'];
                        
                        // Replace table name and execute in new database
                        createStatement = createStatement.replace(`CREATE TABLE \`${tableName}\``, `CREATE TABLE IF NOT EXISTS \`${database_name}\`.\`${tableName}\``);
                        await promisePool.query(createStatement);
                    }
                    
                    console.log('âœ… Template structure cloned successfully');
                } catch (templateError) {
                    console.warn('âš ï¸ Template cloning failed (non-critical):', templateError.message);
                }
            }

            // Always create standard record tables (whether template is used or not)
            console.log('ðŸ“‹ Creating/ensuring standard record tables exist');
            
            // Baptism records table
            await promisePool.query(`
                CREATE TABLE IF NOT EXISTS \`${database_name}\`.baptism_records (
                    id INT PRIMARY KEY AUTO_INCREMENT,
                    church_id INT NOT NULL DEFAULT ${church_id},
                    first_name VARCHAR(255) NOT NULL,
                    middle_name VARCHAR(255),
                    last_name VARCHAR(255) NOT NULL,
                    birth_date DATE,
                    baptism_date DATE NOT NULL,
                    birth_place VARCHAR(255),
                    baptism_place VARCHAR(255),
                    father_name VARCHAR(255),
                    mother_name VARCHAR(255),
                    godfather_name VARCHAR(255),
                    godmother_name VARCHAR(255),
                    godparents VARCHAR(500),
                    priest_name VARCHAR(255),
                    sponsors VARCHAR(500),
                    parents VARCHAR(500),
                    clergy VARCHAR(255),
                    certificate_number VARCHAR(100),
                    book_number VARCHAR(100),
                    page_number VARCHAR(100),
                    entry_number VARCHAR(100),
                    notes TEXT,
                    created_by INT,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                    INDEX idx_baptism_church_id (church_id),
                    INDEX idx_baptism_names (first_name, last_name),
                    INDEX idx_baptism_date (baptism_date)
                )
            `);

            // Marriage records table
            await promisePool.query(`
                CREATE TABLE IF NOT EXISTS \`${database_name}\`.marriage_records (
                    id INT PRIMARY KEY AUTO_INCREMENT,
                    church_id INT NOT NULL DEFAULT ${church_id},
                    groom_first_name VARCHAR(255) NOT NULL,
                    groom_middle_name VARCHAR(255),
                    groom_last_name VARCHAR(255) NOT NULL,
                    bride_first_name VARCHAR(255) NOT NULL,
                    bride_middle_name VARCHAR(255),
                    bride_last_name VARCHAR(255) NOT NULL,
                    marriage_date DATE NOT NULL,
                    marriage_place VARCHAR(255),
                    groom_father VARCHAR(255),
                    groom_mother VARCHAR(255),
                    bride_father VARCHAR(255),
                    bride_mother VARCHAR(255),
                    priest_name VARCHAR(255),
                    best_man VARCHAR(255),
                    maid_of_honor VARCHAR(255),
                    witness1 VARCHAR(255),
                    witness2 VARCHAR(255),
                    certificate_number VARCHAR(100),
                    book_number VARCHAR(100),
                    page_number VARCHAR(100),
                    entry_number VARCHAR(100),
                    notes TEXT,
                    created_by INT,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                    INDEX idx_marriage_church_id (church_id),
                    INDEX idx_marriage_groom (groom_first_name, groom_last_name),
                    INDEX idx_marriage_bride (bride_first_name, bride_last_name),
                    INDEX idx_marriage_date (marriage_date)
                )
            `);

            // Funeral records table
            await promisePool.query(`
                CREATE TABLE IF NOT EXISTS \`${database_name}\`.funeral_records (
                    id INT PRIMARY KEY AUTO_INCREMENT,
                    church_id INT NOT NULL DEFAULT ${church_id},
                    first_name VARCHAR(255) NOT NULL,
                    middle_name VARCHAR(255),
                    last_name VARCHAR(255) NOT NULL,
                    birth_date DATE,
                    death_date DATE,
                    funeral_date DATE NOT NULL,
                    funeral_place VARCHAR(255),
                    burial_place VARCHAR(255),
                    burial_location VARCHAR(255),
                    age_at_death INT,
                    cause_of_death VARCHAR(255),
                    priest_name VARCHAR(255),
                    family_contact VARCHAR(255),
                    certificate_number VARCHAR(100),
                    book_number VARCHAR(100),
                    page_number VARCHAR(100),
                    entry_number VARCHAR(100),
                    notes TEXT,
                    created_by INT,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                    INDEX idx_funeral_church_id (church_id),
                    INDEX idx_funeral_names (first_name, last_name),
                    INDEX idx_funeral_date (funeral_date)
                )
            `);

            // Clergy table
            await promisePool.query(`
                CREATE TABLE IF NOT EXISTS \`${database_name}\`.clergy (
                    id INT PRIMARY KEY AUTO_INCREMENT,
                    church_id INT NOT NULL DEFAULT ${church_id},
                    name VARCHAR(255) NOT NULL,
                    title VARCHAR(100),
                    email VARCHAR(255),
                    phone VARCHAR(50),
                    role ENUM('priest', 'deacon', 'reader', 'chanter', 'other') DEFAULT 'priest',
                    ordination_date DATE,
                    assignment_date DATE,
                    is_active BOOLEAN DEFAULT TRUE,
                    notes TEXT,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                    INDEX idx_clergy_church_id (church_id),
                    INDEX idx_clergy_active (is_active)
                )
            `);

            // NOTE: Users are stored in orthodoxmetrics_db, not in individual church databases
            // Church databases are for records only. User management is handled centrally.
            // Use the church_users junction table in orthodoxmetrics_db to assign users to churches.

            // Church calendar events table
            await promisePool.query(`
                CREATE TABLE IF NOT EXISTS \`${database_name}\`.calendar_events (
                    id INT PRIMARY KEY AUTO_INCREMENT,
                    church_id INT NOT NULL DEFAULT ${church_id},
                    title VARCHAR(255) NOT NULL,
                    description TEXT,
                    event_date DATE NOT NULL,
                    start_time TIME,
                    end_time TIME,
                    event_type ENUM('liturgy', 'service', 'feast', 'fast', 'meeting', 'other') DEFAULT 'other',
                    is_recurring BOOLEAN DEFAULT FALSE,
                    recurrence_pattern VARCHAR(100),
                    created_by INT,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                    INDEX idx_calendar_church_id (church_id),
                    INDEX idx_calendar_date (event_date),
                    INDEX idx_calendar_type (event_type)
                )
            `);

            // Church settings table
            await promisePool.query(`
                CREATE TABLE IF NOT EXISTS \`${database_name}\`.church_settings (
                    id INT PRIMARY KEY AUTO_INCREMENT,
                    church_id INT NOT NULL DEFAULT ${church_id},
                    setting_key VARCHAR(100) NOT NULL,
                    setting_value TEXT,
                    setting_type ENUM('string', 'number', 'boolean', 'json') DEFAULT 'string',
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                    UNIQUE KEY uk_church_setting (church_id, setting_key),
                    INDEX idx_settings_church_id (church_id)
                )
            `);

            console.log('âœ… All standard record tables created successfully');

            // Switch back to main database
            await promisePool.query('USE orthodoxmetrics_db');
            
            // Update church with the generated church_id
            await promisePool.query(
                'UPDATE churches SET setup_complete = 1 WHERE id = ?',
                [newChurchDbId]
            );

            console.log(`âœ… Church database setup completed: ${database_name}`);
            console.log(`ðŸ”— Church ID alignment: orthodoxmetrics_db.churches.id=${newChurchDbId}, church_id=${church_id}`);

        } catch (dbError) {
            console.error('âŒ Database setup error:', dbError);
            // Clean up: Delete the church record if database creation failed
            await promisePool.query('DELETE FROM churches WHERE id = ?', [newChurchDbId]);
            throw new Error(`Database setup failed: ${dbError.message}`);
        }

        // Fetch the complete created church data
        const [newChurch] = await promisePool.query(
            'SELECT * FROM churches WHERE id = ?',
            [newChurchDbId]
        );

        const responseData = {
            success: true,
            message: templateChurch 
                ? `Church created successfully using template from "${templateChurch.name}"`
                : 'Church created successfully',
            church: {
                id: newChurch[0].id,
                church_id: church_id,
                name: newChurch[0].name,
                email: newChurch[0].email,
                database_name: newChurch[0].database_name,
                setup_complete: newChurch[0].setup_complete,
                template_used: templateChurch ? templateChurch.name : null,
                created_at: newChurch[0].created_at
            }
        };

        console.log(`âœ… Church "${name}" created successfully by admin ${req.session.user.email}`);
        res.status(201).json(responseData);

    } catch (err) {
        console.error('âŒ Error creating church:', err);
        res.status(500).json({
            success: false,
            message: 'Server error while creating church',
            error: err.message
        });
    }
});

// POST /admin/churches/wizard - Create church via comprehensive wizard (super_admin only)
router.post('/churches/wizard', requireSuperAdmin, async (req, res) => {
    try {
        console.log('ðŸ§™â€â™‚ï¸ Church Setup Wizard request:', req.body);
        
        const {
            // Basic church info
            name, email, phone, address, city, state_province, postal_code, country,
            website, preferred_language = 'en', timezone = 'UTC', currency = 'USD', is_active = true,
            
            // Template selection
            template_church_id = null,
            selected_tables = [],
            
            // Custom fields
            custom_fields = [],
            
            // Initial users
            initial_users = [],
            
            // Landing page configuration
            custom_landing_page = { enabled: false }
        } = req.body;

        // Validate required fields
        if (!name || !email) {
            return res.status(400).json({
                success: false,
                message: 'Church name and email are required'
            });
        }

        // Check for existing church with same name or email
        const [existingChurches] = await promisePool.query(
            'SELECT id FROM churches WHERE name = ? OR email = ?',
            [name, email]
        );

        if (existingChurches.length > 0) {
            return res.status(400).json({
                success: false,
                message: 'Church with this name or email already exists'
            });
        }

        // Validate template church if specified
        let templateChurch = null;
        if (template_church_id) {
            const [templateChurches] = await promisePool.query(
                'SELECT * FROM churches WHERE id = ? AND preferred_language = ? AND is_active = 1',
                [template_church_id, 'en']
            );

            if (templateChurches.length === 0) {
                return res.status(400).json({
                    success: false,
                    message: 'Template church not found or not an active English church'
                });
            }

            templateChurch = templateChurches[0];
            console.log('ðŸŽ¯ Using wizard template church:', templateChurch.name);
        }

        // Generate unique church_id and database name
        const generateChurchId = (churchName) => {
            const prefix = churchName
                .split(' ')
                .map(word => word.charAt(0).toUpperCase())
                .join('')
                .substring(0, 6);
            const timestamp = Date.now().toString().slice(-6);
            return parseInt(`${timestamp}${Math.floor(Math.random() * 100)}`);
        };

        const church_id = generateChurchId(name);
        const sanitizedName = name
            .toLowerCase()
            .replace(/[^a-z0-9\s]/g, '')
            .replace(/\s+/g, '_')
            .substring(0, 30);
        
        const database_name = `${church_id}_${sanitizedName}_db`;

        // Insert new church into orthodoxmetrics_db.churches
        const [result] = await promisePool.query(`
            INSERT INTO churches (
                name, email, phone, address, city, state_province, postal_code, 
                country, website, preferred_language, timezone, currency, is_active,
                database_name, setup_complete, created_at, updated_at,
                church_name, admin_email, language_preference
            ) 
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, ?, ?, ?)
        `, [
            name, email, phone, address, city, state_province, postal_code,
            country, website, preferred_language, timezone, currency, is_active ? 1 : 0,
            database_name, false, // Will be set to true after full setup
            name, email, preferred_language
        ]);

        const newChurchDbId = result.insertId;
        console.log('âœ… Church created in orthodoxmetrics_db with ID:', newChurchDbId);

        // Create individual church database with comprehensive setup
        try {
            console.log('ðŸ”„ Creating church-specific database with wizard settings:', database_name);
            
            // Create the database
            await promisePool.query(`CREATE DATABASE IF NOT EXISTS \`${database_name}\``);
            await promisePool.query(`USE \`${database_name}\``);
            
            // Create church_info table with the same church_id
            await promisePool.query(`
                CREATE TABLE IF NOT EXISTS church_info (
                    id INT PRIMARY KEY AUTO_INCREMENT,
                    church_id INT NOT NULL DEFAULT ${church_id},
                    name VARCHAR(255) NOT NULL DEFAULT '${name}',
                    email VARCHAR(255) NOT NULL DEFAULT '${email}',
                    phone VARCHAR(50),
                    address TEXT,
                    city VARCHAR(100),
                    state_province VARCHAR(100),
                    country VARCHAR(100),
                    preferred_language VARCHAR(10) DEFAULT '${preferred_language}',
                    timezone VARCHAR(50) DEFAULT '${timezone}',
                    currency VARCHAR(10) DEFAULT '${currency}',
                    is_active BOOLEAN DEFAULT TRUE,
                    custom_landing_page JSON,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                    UNIQUE KEY uk_church_id (church_id)
                )
            `);

            // Insert church info with landing page configuration
            await promisePool.query(`
                INSERT INTO church_info (
                    church_id, name, email, phone, address, city, state_province, 
                    country, preferred_language, timezone, currency, is_active, custom_landing_page
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, ?, ?, ?)
            `, [
                church_id, name, email, phone, address, city, state_province,
                country, preferred_language, timezone, currency, is_active ? 1 : 0,
                JSON.stringify(custom_landing_page)
            ]);

            // If template church is specified, clone its structure
            if (templateChurch && templateChurch.database_name) {
                console.log('ðŸŽ¯ Cloning structure from wizard template church database:', templateChurch.database_name);
                
                try {
                    // Clone table structures (excluding data)
                    const [templateTables] = await promisePool.query(`
                        SELECT TABLE_NAME 
                        FROM information_schema.TABLES 
                        WHERE TABLE_SCHEMA = ? 
                        AND TABLE_NAME NOT IN ('church_info')
                        AND TABLE_NAME IN (${selected_tables.map(() => '?').join(',')})
                    `, [templateChurch.database_name, ...selected_tables]);

                    for (const table of templateTables) {
                        const tableName = table.TABLE_NAME;
                        console.log(`ðŸ“‹ Cloning wizard table structure: ${tableName}`);
                        
                        // Get CREATE TABLE statement from template
                        const [createTableResult] = await promisePool.query(`SHOW CREATE TABLE \`${templateChurch.database_name}\`.\`${tableName}\``);
                        let createStatement = createTableResult[0]['Create Table'];
                        
                        // Replace table name and execute in new database
                        createStatement = createStatement.replace(`CREATE TABLE \`${tableName}\``, `CREATE TABLE IF NOT EXISTS \`${database_name}\`.\`${tableName}\``);
                        await promisePool.query(createStatement);
                    }
                    
                    console.log('âœ… Wizard template structure cloned successfully');
                } catch (templateError) {
                    console.warn('âš ï¸ Wizard template cloning failed (non-critical):', templateError.message);
                }
            }

            // Create all selected record tables
            console.log('ðŸ“‹ Creating wizard selected record tables:', selected_tables);
            
            const tableDefinitions = {
                'baptism_records': `
                    CREATE TABLE IF NOT EXISTS \`${database_name}\`.baptism_records (
                        id INT PRIMARY KEY AUTO_INCREMENT,
                        church_id INT NOT NULL DEFAULT ${church_id},
                        first_name VARCHAR(255) NOT NULL,
                        middle_name VARCHAR(255),
                        last_name VARCHAR(255) NOT NULL,
                        birth_date DATE,
                        baptism_date DATE NOT NULL,
                        birth_place VARCHAR(255),
                        baptism_place VARCHAR(255),
                        father_name VARCHAR(255),
                        mother_name VARCHAR(255),
                        godfather_name VARCHAR(255),
                        godmother_name VARCHAR(255),
                        godparents VARCHAR(500),
                        priest_name VARCHAR(255),
                        sponsors VARCHAR(500),
                        parents VARCHAR(500),
                        clergy VARCHAR(255),
                        certificate_number VARCHAR(100),
                        book_number VARCHAR(100),
                        page_number VARCHAR(100),
                        entry_number VARCHAR(100),
                        notes TEXT,
                        created_by INT,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                        INDEX idx_baptism_church_id (church_id),
                        INDEX idx_baptism_names (first_name, last_name),
                        INDEX idx_baptism_date (baptism_date)
                    )
                `,
                'marriage_records': `
                    CREATE TABLE IF NOT EXISTS \`${database_name}\`.marriage_records (
                        id INT PRIMARY KEY AUTO_INCREMENT,
                        church_id INT NOT NULL DEFAULT ${church_id},
                        groom_first_name VARCHAR(255) NOT NULL,
                        groom_middle_name VARCHAR(255),
                        groom_last_name VARCHAR(255) NOT NULL,
                        bride_first_name VARCHAR(255) NOT NULL,
                        bride_middle_name VARCHAR(255),
                        bride_last_name VARCHAR(255) NOT NULL,
                        marriage_date DATE NOT NULL,
                        marriage_place VARCHAR(255),
                        groom_father VARCHAR(255),
                        groom_mother VARCHAR(255),
                        bride_father VARCHAR(255),
                        bride_mother VARCHAR(255),
                        priest_name VARCHAR(255),
                        best_man VARCHAR(255),
                        maid_of_honor VARCHAR(255),
                        witness1 VARCHAR(255),
                        witness2 VARCHAR(255),
                        certificate_number VARCHAR(100),
                        book_number VARCHAR(100),
                        page_number VARCHAR(100),
                        entry_number VARCHAR(100),
                        notes TEXT,
                        created_by INT,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                        INDEX idx_marriage_church_id (church_id),
                        INDEX idx_marriage_groom (groom_first_name, groom_last_name),
                        INDEX idx_marriage_bride (bride_first_name, bride_last_name),
                        INDEX idx_marriage_date (marriage_date)
                    )
                `,
                'funeral_records': `
                    CREATE TABLE IF NOT EXISTS \`${database_name}\`.funeral_records (
                        id INT PRIMARY KEY AUTO_INCREMENT,
                        church_id INT NOT NULL DEFAULT ${church_id},
                        first_name VARCHAR(255) NOT NULL,
                        middle_name VARCHAR(255),
                        last_name VARCHAR(255) NOT NULL,
                        birth_date DATE,
                        death_date DATE,
                        funeral_date DATE NOT NULL,
                        birth_place VARCHAR(255),
                        death_place VARCHAR(255),
                        funeral_place VARCHAR(255),
                        father_name VARCHAR(255),
                        mother_name VARCHAR(255),
                        spouse_name VARCHAR(255),
                        priest_name VARCHAR(255),
                        cause_of_death VARCHAR(255),
                        cemetery VARCHAR(255),
                        plot_number VARCHAR(100),
                        certificate_number VARCHAR(100),
                        book_number VARCHAR(100),
                        page_number VARCHAR(100),
                        entry_number VARCHAR(100),
                        notes TEXT,
                        created_by INT,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                        INDEX idx_funeral_church_id (church_id),
                        INDEX idx_funeral_names (first_name, last_name),
                        INDEX idx_funeral_date (funeral_date)
                    )
                `,
                'clergy': `
                    CREATE TABLE IF NOT EXISTS \`${database_name}\`.clergy (
                        id INT PRIMARY KEY AUTO_INCREMENT,
                        church_id INT NOT NULL DEFAULT ${church_id},
                        first_name VARCHAR(255) NOT NULL,
                        last_name VARCHAR(255) NOT NULL,
                        title VARCHAR(100),
                        position VARCHAR(100),
                        ordination_date DATE,
                        start_date DATE,
                        end_date DATE,
                        email VARCHAR(255),
                        phone VARCHAR(50),
                        is_active BOOLEAN DEFAULT TRUE,
                        notes TEXT,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                        INDEX idx_clergy_church_id (church_id),
                        INDEX idx_clergy_names (first_name, last_name)
                    )
                `,
                'members': `
                    CREATE TABLE IF NOT EXISTS \`${database_name}\`.members (
                        id INT PRIMARY KEY AUTO_INCREMENT,
                        church_id INT NOT NULL DEFAULT ${church_id},
                        first_name VARCHAR(255) NOT NULL,
                        last_name VARCHAR(255) NOT NULL,
                        email VARCHAR(255),
                        phone VARCHAR(50),
                        address TEXT,
                        city VARCHAR(100),
                        state_province VARCHAR(100),
                        postal_code VARCHAR(20),
                        country VARCHAR(100),
                        birth_date DATE,
                        baptism_date DATE,
                        membership_date DATE,
                        membership_status VARCHAR(50) DEFAULT 'active',
                        notes TEXT,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                        INDEX idx_members_church_id (church_id),
                        INDEX idx_members_names (first_name, last_name),
                        INDEX idx_members_email (email)
                    )
                `,
                'donations': `
                    CREATE TABLE IF NOT EXISTS \`${database_name}\`.donations (
                        id INT PRIMARY KEY AUTO_INCREMENT,
                        church_id INT NOT NULL DEFAULT ${church_id},
                        donor_name VARCHAR(255),
                        amount DECIMAL(10,2) NOT NULL,
                        currency VARCHAR(10) DEFAULT '${currency}',
                        donation_date DATE NOT NULL,
                        category VARCHAR(100),
                        method VARCHAR(50),
                        reference_number VARCHAR(100),
                        notes TEXT,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                        INDEX idx_donations_church_id (church_id),
                        INDEX idx_donations_date (donation_date),
                        INDEX idx_donations_amount (amount)
                    )
                `,
                'calendar_events': `
                    CREATE TABLE IF NOT EXISTS \`${database_name}\`.calendar_events (
                        id INT PRIMARY KEY AUTO_INCREMENT,
                        church_id INT NOT NULL DEFAULT ${church_id},
                        title VARCHAR(255) NOT NULL,
                        description TEXT,
                        event_date DATE NOT NULL,
                        start_time TIME,
                        end_time TIME,
                        event_type VARCHAR(100),
                        location VARCHAR(255),
                        is_recurring BOOLEAN DEFAULT FALSE,
                        recurrence_pattern VARCHAR(100),
                        created_by INT,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                        INDEX idx_events_church_id (church_id),
                        INDEX idx_events_date (event_date),
                        INDEX idx_events_type (event_type)
                    )
                `,
                'confession_records': `
                    CREATE TABLE IF NOT EXISTS \`${database_name}\`.confession_records (
                        id INT PRIMARY KEY AUTO_INCREMENT,
                        church_id INT NOT NULL DEFAULT ${church_id},
                        person_name VARCHAR(255),
                        confession_date DATE NOT NULL,
                        priest_name VARCHAR(255),
                        notes TEXT,
                        is_confidential BOOLEAN DEFAULT TRUE,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                        INDEX idx_confession_church_id (church_id),
                        INDEX idx_confession_date (confession_date)
                    )
                `,
                'communion_records': `
                    CREATE TABLE IF NOT EXISTS \`${database_name}\`.communion_records (
                        id INT PRIMARY KEY AUTO_INCREMENT,
                        church_id INT NOT NULL DEFAULT ${church_id},
                        person_name VARCHAR(255),
                        communion_date DATE NOT NULL,
                        service_type VARCHAR(100),
                        priest_name VARCHAR(255),
                        notes TEXT,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                        INDEX idx_communion_church_id (church_id),
                        INDEX idx_communion_date (communion_date)
                    )
                `,
                'chrismation_records': `
                    CREATE TABLE IF NOT EXISTS \`${database_name}\`.chrismation_records (
                        id INT PRIMARY KEY AUTO_INCREMENT,
                        church_id INT NOT NULL DEFAULT ${church_id},
                        first_name VARCHAR(255) NOT NULL,
                        last_name VARCHAR(255) NOT NULL,
                        chrismation_date DATE NOT NULL,
                        baptism_date DATE,
                        sponsor_name VARCHAR(255),
                        priest_name VARCHAR(255),
                        confirmation_name VARCHAR(255),
                        certificate_number VARCHAR(100),
                        notes TEXT,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                        INDEX idx_chrismation_church_id (church_id),
                        INDEX idx_chrismation_names (first_name, last_name),
                        INDEX idx_chrismation_date (chrismation_date)
                    )
                `
            };

            // Create selected tables
            for (const tableName of selected_tables) {
                if (tableDefinitions[tableName]) {
                    await promisePool.query(tableDefinitions[tableName]);
                    console.log(`âœ… Created table: ${tableName}`);
                }
            }

            // Add custom fields to selected tables
            if (custom_fields && custom_fields.length > 0) {
                console.log('ðŸ”§ Adding custom fields:', custom_fields);
                
                for (const field of custom_fields) {
                    try {
                        let fieldDefinition = `${field.field_name} ${field.field_type}`;
                        
                        if (field.field_type === 'VARCHAR' && field.field_length) {
                            fieldDefinition += `(${field.field_length})`;
                        }
                        
                        if (field.is_required) {
                            fieldDefinition += ' NOT NULL';
                        }
                        
                        if (field.default_value) {
                            fieldDefinition += ` DEFAULT '${field.default_value}'`;
                        }

                        await promisePool.query(`
                            ALTER TABLE \`${database_name}\`.\`${field.table_name}\` 
                            ADD COLUMN ${fieldDefinition}
                        `);
                        
                        console.log(`âœ… Added custom field: ${field.field_name} to ${field.table_name}`);
                    } catch (fieldError) {
                        console.warn(`âš ï¸ Failed to add custom field ${field.field_name}:`, fieldError.message);
                    }
                }
            }

            // NOTE: Users are stored in orthodoxmetrics_db, not in individual church databases
            // Church databases are for records only. User management is handled centrally.
            // Use the church_users junction table in orthodoxmetrics_db to assign users to churches.

            // Add initial users to orthodoxmetrics_db (not church database)
            if (initial_users && initial_users.length > 0) {
                console.log('ðŸ‘¥ Adding initial users to orthodoxmetrics_db:', initial_users.length);
                
                for (const user of initial_users) {
                    try {
                        // Check if user already exists in orthodoxmetrics_db
                        const [existingUsers] = await promisePool.query(
                            'SELECT id FROM users WHERE email = ?',
                            [user.email]
                        );

                        let userId;
                        if (existingUsers.length > 0) {
                            userId = existingUsers[0].id;
                            console.log(`ðŸ‘¤ User ${user.email} already exists, using existing user`);
                        } else {
                            // Create new user in orthodoxmetrics_db
                            const tempPassword = Math.random().toString(36).slice(-12);
                            const bcrypt = require('bcrypt');
                            const hashedPassword = await bcrypt.hash(tempPassword, 10);

                            const [result] = await promisePool.query(`
                                INSERT INTO users (
                                    email, first_name, last_name, role, church_id, 
                                    password_hash, is_active, created_at, updated_at
                                ) VALUES (?, ?, ?, ?, ?, ?, ?, NOW(), NOW())
                            `, [
                                user.email, user.first_name, user.last_name, user.role, church_id,
                                hashedPassword, true
                            ]);
                            
                            userId = result.insertId;
                            console.log(`âœ… Created user: ${user.first_name} ${user.last_name} (${user.role}) with temp password: ${tempPassword}`);
                        }

                        // Assign user to church via church_users junction table
                        await promisePool.query(
                            'INSERT INTO church_users (church_id, user_id, role) VALUES (?, ?, ?) ON DUPLICATE KEY UPDATE role = VALUES(role)',
                            [church_id, userId, user.role]
                        );
                        
                        // TODO: Send invitation email if user.send_invite is true
                        if (user.send_invite) {
                            console.log(`ðŸ“§ TODO: Send invitation email to ${user.email}`);
                        }
                    } catch (userError) {
                        console.warn(`âš ï¸ Failed to add user ${user.email}:`, userError.message);
                    }
                }
            }

            // Create church settings table for landing page and other configurations
            await promisePool.query(`
                CREATE TABLE IF NOT EXISTS \`${database_name}\`.church_settings (
                    id INT PRIMARY KEY AUTO_INCREMENT,
                    church_id INT NOT NULL DEFAULT ${church_id},
                    setting_key VARCHAR(255) NOT NULL,
                    setting_value JSON,
                    description TEXT,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                    UNIQUE KEY uk_church_setting (church_id, setting_key),
                    INDEX idx_settings_church_id (church_id)
                )
            `);

            // Store landing page configuration in settings
            if (custom_landing_page && custom_landing_page.enabled) {
                await promisePool.query(`
                    INSERT INTO \`${database_name}\`.church_settings (
                        church_id, setting_key, setting_value, description
                    ) VALUES (?, 'custom_landing_page', ?, 'Custom landing page configuration with default app')
                `, [church_id, JSON.stringify(custom_landing_page)]);
                console.log('âœ… Stored custom landing page configuration with default app');
            }

            // Switch back to main database and mark setup as complete
            await promisePool.query('USE orthodoxmetrics_db');
            await promisePool.query('UPDATE churches SET setup_complete = 1 WHERE id = ?', [newChurchDbId]);

            console.log('ðŸŽ‰ Church Setup Wizard completed successfully!');

        } catch (dbError) {
            console.error('âŒ Database setup failed:', dbError);
            
            // Rollback: delete the church record if database setup failed
            try {
                await promisePool.query('DELETE FROM churches WHERE id = ?', [newChurchDbId]);
                console.log('ðŸ”„ Rolled back church record due to database setup failure');
            } catch (rollbackError) {
                console.error('âŒ Rollback failed:', rollbackError);
            }
            
            throw new Error(`Database setup failed: ${dbError.message}`);
        }

        // Fetch the created church with all details
        const [newChurch] = await promisePool.query(`
            SELECT * FROM churches WHERE id = ?
        `, [newChurchDbId]);

        res.json({
            success: true,
            message: `Church "${name}" created successfully via wizard`,
            church: newChurch[0],
            wizard_summary: {
                template_used: templateChurch ? templateChurch.name : null,
                tables_created: selected_tables.length,
                custom_fields_added: custom_fields.length,
                initial_users_added: initial_users.length,
                landing_page_configured: custom_landing_page.enabled,
                church_id: church_id,
                database_name: database_name
            }
        });

    } catch (error) {
        console.error('âŒ Church wizard creation failed:', error);
        res.status(500).json({
            success: false,
            message: 'Failed to create church via wizard',
            error: error.message
        });
    }
});

// PUT /admin/churches/:id - Update church (super_admin only)
router.put('/churches/:id', requireSuperAdmin, async (req, res) => {
    try {
        const churchId = parseInt(req.params.id);
        console.log('ðŸ”„ Updating church ID:', churchId, 'with data:', req.body);

        const {
            name,
            email,
            phone,
            address,
            city,
            state_province,
            postal_code,
            country,
            website,
            preferred_language,
            timezone,
            currency,
            tax_id,
            description_multilang,
            settings,
            is_active
        } = req.body;

        // Validate required fields
        if (!name || !email) {
            return res.status(400).json({
                success: false,
                message: 'Church name and email are required'
            });
        }

        // Check if church exists
        const [existingChurch] = await promisePool.query(
            'SELECT id FROM churches WHERE id = ?',
            [churchId]
        );

        if (existingChurch.length === 0) {
            return res.status(404).json({
                success: false,
                message: 'Church not found'
            });
        }

        // Check if church name is already taken by another church
        const [existingName] = await promisePool.query(
            'SELECT id FROM churches WHERE name = ? AND id != ?',
            [name, churchId]
        );

        if (existingName.length > 0) {
            return res.status(400).json({
                success: false,
                message: 'Church name already exists'
            });
        }

        // Check if email is already taken by another church
        const [existingEmail] = await promisePool.query(
            'SELECT id FROM churches WHERE email = ? AND id != ?',
            [email, churchId]
        );

        if (existingEmail.length > 0) {
            return res.status(400).json({
                success: false,
                message: 'Email already exists'
            });
        }

        // Process JSON fields properly - convert empty strings to NULL
        const processedDescriptionMultilang = description_multilang && description_multilang.trim() !== '' 
            ? description_multilang 
            : null;
        
        const processedSettings = settings && settings.trim() !== '' 
            ? settings 
            : null;

        // Process other fields - convert empty strings to NULL for optional fields
        const processedTaxId = tax_id && tax_id.trim() !== '' ? tax_id : null;
        const processedWebsite = website && website.trim() !== '' ? website : null;

        // Update church with complete field mapping
        await promisePool.query(`
            UPDATE churches 
            SET 
                name = ?, 
                email = ?, 
                phone = ?, 
                address = ?, 
                city = ?, 
                state_province = ?, 
                postal_code = ?, 
                country = ?, 
                website = ?,
                preferred_language = ?,
                timezone = ?,
                currency = ?,
                tax_id = ?,
                description_multilang = ?,
                settings = ?,
                is_active = ?,
                updated_at = CURRENT_TIMESTAMP,
                -- Also update legacy fields for backward compatibility
                church_name = ?,
                admin_email = ?,
                language_preference = ?
            WHERE id = ?
        `, [
            name, email, phone, address, city, state_province, postal_code,
            country, processedWebsite, preferred_language, timezone, currency, 
            processedTaxId, processedDescriptionMultilang, processedSettings, 
            is_active ? 1 : 0,
            // Legacy fields
            name, email, preferred_language,
            churchId
        ]);

        console.log(`âœ… Church updated successfully: ${name} by admin ${req.session.user.email}`);

        // Fetch the updated church data to return
        const [updatedChurch] = await promisePool.query(`
            SELECT 
                id,
                name,
                email,
                phone,
                address,
                city,
                state_province,
                postal_code,
                country,
                website,
                preferred_language,
                timezone,
                currency,
                tax_id,
                description_multilang,
                settings,
                is_active,
                database_name,
                setup_complete,
                created_at,
                updated_at
            FROM churches 
            WHERE id = ?
        `, [churchId]);

        res.json({
            success: true,
            message: 'Church updated successfully',
            church: updatedChurch[0]
        });

    } catch (err) {
        console.error('âŒ Error updating church:', err);
        res.status(500).json({
            success: false,
            message: 'Server error while updating church',
            error: err.message
        });
    }
});

// DELETE /admin/churches/:id - Delete church (super_admin only)
router.delete('/churches/:id', requireSuperAdmin, async (req, res) => {
    try {
        const churchId = parseInt(req.params.id);

        // Check if there are users assigned to this church
        const [userRows] = await promisePool.query(
            'SELECT COUNT(*) as user_count FROM users WHERE church_id = ?',
            [churchId]
        );

        if (userRows[0].user_count > 0) {
            return res.status(400).json({
                success: false,
                message: 'Cannot delete church with assigned users. Please reassign users first.'
            });
        }

        // Get church info before deletion
        const [churchRows] = await promisePool.query(
            'SELECT name FROM churches WHERE id = ?',
            [churchId]
        );

        if (churchRows.length === 0) {
            return res.status(404).json({
                success: false,
                message: 'Church not found'
            });
        }

        // Delete church
        await promisePool.query('DELETE FROM churches WHERE id = ?', [churchId]);

        console.log(`âœ… Church deleted successfully: ${churchRows[0].name} by admin ${req.session.user.email}`);

        res.json({
            success: true,
            message: 'Church deleted successfully'
        });

    } catch (err) {
        console.error('Error deleting church:', err);
        res.status(500).json({
            success: false,
            message: 'Server error while deleting church'
        });
    }
});

// GET /admin/church/:id - Get individual church data for admin panel
router.get('/church/:id', requireAdmin, async (req, res) => {
    try {
        const churchId = parseInt(req.params.id);
        console.log('ðŸ” Admin church detail request for church ID:', churchId, 'from:', req.session.user?.email);

        // Get church basic info
        const [churchRows] = await promisePool.query(`
            SELECT 
                id,
                name,
                email,
                phone,
                address,
                city,
                state_province,
                postal_code,
                country,
                website,
                preferred_language,
                timezone,
                currency,
                is_active,
                created_at,
                updated_at
            FROM churches 
            WHERE id = ?
        `, [churchId]);

        if (churchRows.length === 0) {
            return res.status(404).json({
                success: false,
                message: 'Church not found'
            });
        }

        const church = churchRows[0];

        // Get users for this church
        const [users] = await promisePool.query(`
            SELECT 
                id,
                email,
                first_name,
                last_name,
                role,
                is_active,
                email_verified,
                last_login,
                created_at
            FROM users 
            WHERE church_id = ?
            ORDER BY created_at DESC
        `, [churchId]);

        // Get record counts (from the client database - we'll need to handle this differently)
        // For now, we'll return sample data since we need the client-specific database connection
        const recordCounts = {
            baptism: 0,
            marriage: 0,
            funeral: 0
        };

        // Get recent activity logs for this church
        const [activityLogs] = await promisePool.query(`
            SELECT 
                al.id,
                al.action,
                al.entity_type,
                al.entity_id,
                al.created_at,
                u.first_name,
                u.last_name,
                u.email
            FROM activity_log al
            LEFT JOIN users u ON al.user_id = u.id
            WHERE al.church_id = ?
            ORDER BY al.created_at DESC
            LIMIT 50
        `, [churchId]);

        console.log('âœ… Church admin data retrieved for:', church.name);

        res.json({
            success: true,
            church: church,
            users: users,
            recordCounts: recordCounts,
            activityLogs: activityLogs
        });

    } catch (err) {
        console.error('âŒ Error fetching church admin data:', err);
        res.status(500).json({
            success: false,
            message: 'Server error while fetching church data',
            error: err.message
        });
    }
});

// POST /admin/users/:id/reset-password - Reset user password
router.post('/users/:id/reset-password', requireAdmin, async (req, res) => {
    try {
        const userId = parseInt(req.params.id);

        // Don't allow reset of current user's password
        if (userId === req.session.user.id) {
            return res.status(400).json({
                success: false,
                message: 'You cannot reset your own password'
            });
        }

        // Get user info and check permissions
        const [userRows] = await promisePool.query(
            'SELECT email, role FROM users WHERE id = ?',
            [userId]
        );

        if (userRows.length === 0) {
            return res.status(404).json({
                success: false,
                message: 'User not found'
            });
        }

        const targetUserRole = userRows[0].role;
        const currentUserRole = req.session.user.role;

        // Super admin can reset any role except super_admin
        if (currentUserRole === 'super_admin') {
            if (targetUserRole === 'super_admin') {
                return res.status(403).json({
                    success: false,
                    message: 'Cannot reset super_admin passwords'
                });
            }
        }

        // Regular admin cannot reset admin or super_admin passwords
        if (currentUserRole === 'admin') {
            if (targetUserRole === 'admin' || targetUserRole === 'super_admin') {
                return res.status(403).json({
                    success: false,
                    message: 'Cannot reset admin or super_admin passwords'
                });
            }
        }

        // Generate new temporary password
        const tempPassword = Math.random().toString(36).slice(-12) + Math.random().toString(36).slice(-12);

        // Hash the password
        const saltRounds = 12;
        const passwordHash = await bcrypt.hash(tempPassword, saltRounds);

        // Update user password
        await promisePool.query(
            'UPDATE users SET password_hash = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?',
            [passwordHash, userId]
        );

        console.log(`âœ… Password reset for user: ${userRows[0].email} by admin ${req.session.user.email}`);
        console.log(`ðŸ” New temporary password for ${userRows[0].email}: ${tempPassword}`);

        // TODO: Send password via secure email instead of returning in response
        res.json({
            success: true,
            message: 'Password reset successfully. New password has been logged securely for admin retrieval.'
        });

    } catch (err) {
        console.error('Error resetting password:', err);
        res.status(500).json({
            success: false,
            message: 'Server error while resetting password'
        });
    }
});

// PATCH /admin/users/:id/reset-password - Reset user password with custom password
router.patch('/users/:id/reset-password', requireAdmin, async (req, res) => {
    try {
        const userId = parseInt(req.params.id);
        const { new_password, auto_generate } = req.body;
        const currentUser = req.session.user;

        // Don't allow reset of current user's password
        if (userId === currentUser.id) {
            return res.status(400).json({
                success: false,
                message: 'You cannot reset your own password'
            });
        }

        // Get target user information
        const [userRows] = await promisePool.query(
            'SELECT id, email, role, first_name, last_name FROM users WHERE id = ?',
            [userId]
        );

        if (userRows.length === 0) {
            return res.status(404).json({
                success: false,
                message: 'User not found'
            });
        }

        const targetUser = userRows[0];

        // Check if current user can manage the target user
        if (!canManageUser(currentUser, targetUser)) {
            logUnauthorizedAttempt(currentUser, targetUser, 'RESET_PASSWORD');
            return res.status(403).json({
                success: false,
                message: 'You do not have permission to reset this user\'s password',
                code: 'PASSWORD_RESET_DENIED'
            });
        }

        // Generate or use provided password
        let passwordToUse;
        if (auto_generate || !new_password) {
            // Auto-generate secure password
            const charset = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*';
            const length = 16;
            let password = '';
            
            // Ensure at least one character from each category
            const lowercase = 'abcdefghijklmnopqrstuvwxyz';
            const uppercase = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            const numbers = '0123456789';
            const symbols = '!@#$%^&*';
            
            password += lowercase[Math.floor(Math.random() * lowercase.length)];
            password += uppercase[Math.floor(Math.random() * uppercase.length)];
            password += numbers[Math.floor(Math.random() * numbers.length)];
            password += symbols[Math.floor(Math.random() * symbols.length)];
            
            // Fill the rest randomly
            for (let i = 4; i < length; i++) {
                password += charset[Math.floor(Math.random() * charset.length)];
            }
            
            // Shuffle the password
            passwordToUse = password.split('').sort(() => Math.random() - 0.5).join('');
        } else {
            // Validate provided password
            if (new_password.length < 8) {
                return res.status(400).json({
                    success: false,
                    message: 'Password must be at least 8 characters long'
                });
            }
            passwordToUse = new_password;
        }

        // Hash the password
        const saltRounds = 12;
        const passwordHash = await bcrypt.hash(passwordToUse, saltRounds);

        // Update user password
        await promisePool.query(
            'UPDATE users SET password_hash = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?',
            [passwordHash, userId]
        );

        console.log(`âœ… Password reset for user: ${targetUser.email} by ${currentUser.email} (role: ${currentUser.role})`);

        res.json({
            success: true,
            message: 'Password reset successfully',
            newPassword: auto_generate ? passwordToUse : undefined
        });

    } catch (err) {
        console.error('Error resetting password:', err);
        res.status(500).json({
            success: false,
            message: 'Server error while resetting password'
        });
    }
});

// PATCH /admin/users/:id/status - Update user status
router.patch('/users/:id/status', requireAdmin, async (req, res) => {
    try {
        const userId = parseInt(req.params.id);
        const { is_active } = req.body;
        const currentUser = req.session.user;

        // Don't allow deactivation of the current user
        if (userId === currentUser.id && !is_active) {
            return res.status(400).json({
                success: false,
                message: 'You cannot deactivate your own account'
            });
        }

        // Get target user information
        const [userRows] = await promisePool.query(
            'SELECT id, email, role, first_name, last_name FROM users WHERE id = ?',
            [userId]
        );

        if (userRows.length === 0) {
            return res.status(404).json({
                success: false,
                message: 'User not found'
            });
        }

        const targetUser = userRows[0];

        // Check if current user can perform destructive operations (deactivating is considered destructive)
        if (!is_active && !canPerformDestructiveOperation(currentUser, targetUser)) {
            logUnauthorizedAttempt(currentUser, targetUser, 'DEACTIVATE_USER');
            return res.status(403).json({
                success: false,
                message: 'You do not have permission to deactivate this user',
                code: 'DEACTIVATION_DENIED'
            });
        }

        // Check if current user can manage the target user (for activation)
        if (is_active && !canManageUser(currentUser, targetUser)) {
            logUnauthorizedAttempt(currentUser, targetUser, 'ACTIVATE_USER');
            return res.status(403).json({
                success: false,
                message: 'You do not have permission to activate this user',
                code: 'ACTIVATION_DENIED'
            });
        }

        // Update user status
        await promisePool.query(
            'UPDATE users SET is_active = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?',
            [is_active ? 1 : 0, userId]
        );

        console.log(`âœ… User status updated: ${targetUser.email} -> ${is_active ? 'active' : 'inactive'} by ${currentUser.email} (role: ${currentUser.role})`);

        res.json({
            success: true,
            message: `User ${is_active ? 'activated' : 'deactivated'} successfully`
        });

    } catch (err) {
        console.error('Error updating user status:', err);
        res.status(500).json({
            success: false,
            message: 'Server error while updating user status'
        });
    }
});

/*
// Test endpoint to verify query works (disabled for production)
router.get('/test-users', requireAdmin, async (req, res) => {
    try {
        console.log('ðŸ” Testing admin users query...');
        
        // Test the exact query that was working
        const [rows] = await promisePool.query(`
            SELECT 
                u.id,
                u.email,
                u.first_name,
                u.last_name,
                u.role,
                u.church_id,
                c.name as church_name,
                u.is_active,
                u.email_verified,
                u.preferred_language,
                u.timezone,
                u.landing_page,
                u.created_at,
                u.updated_at,
                u.last_login
            FROM users u
            LEFT JOIN churches c ON u.church_id = c.id
            ORDER BY u.created_at DESC
        `);

        console.log('âœ… Test query successful, returned', rows.length, 'users');
        
        res.json({
            success: true,
            count: rows.length,
            users: rows
        });
    } catch (err) {
        console.error('âŒ Test query error:', err.message);
        console.error('âŒ Full error:', err);
        res.status(500).json({
            success: false,
            message: 'Test query failed',
            error: err.message
        });
    }
});
*/

// GET /admin/churches/:id/tables - Get available tables for a church (for template selection)
router.get('/churches/:id/tables', requireAdmin, async (req, res) => {
    try {
        const churchId = parseInt(req.params.id);
        console.log('ðŸ“‹ Getting tables for church ID:', churchId);

        // Get the church to find its database name
        const [churches] = await promisePool.query(
            'SELECT database_name FROM churches WHERE id = ? AND is_active = 1',
            [churchId]
        );

        if (churches.length === 0) {
            return res.status(404).json({
                success: false,
                message: 'Church not found or inactive'
            });
        }

        const { database_name } = churches[0];

        // Get all tables from the church's database
        const [tables] = await promisePool.query(`
            SELECT TABLE_NAME 
            FROM information_schema.TABLES 
            WHERE TABLE_SCHEMA = ? 
            AND TABLE_NAME NOT IN ('church_info', 'users', 'church_settings')
            ORDER BY TABLE_NAME
        `, [database_name]);

        const tableNames = tables.map(table => table.TABLE_NAME);

        res.json({
            success: true,
            tables: tableNames,
            church_id: churchId,
            database_name: database_name
        });

    } catch (error) {
        console.error('âŒ Error getting church tables:', error);
        res.status(500).json({
            success: false,
            message: 'Failed to get church tables',
            error: error.message
        });
    }
});

// GET /admin/churches/:id/users - Get church users
router.get('/churches/:id/users', requireAdmin, async (req, res) => {
    try {
        const churchId = parseInt(req.params.id);
        console.log('ðŸ‘¥ Getting users for church ID:', churchId);

        // Verify church exists
        const [churches] = await promisePool.query(
            'SELECT id, name FROM churches WHERE id = ? AND is_active = 1',
            [churchId]
        );

        if (churches.length === 0) {
            return res.status(404).json({
                success: false,
                message: 'Church not found or inactive'
            });
        }

        // Get users assigned to this church via junction table
        const [users] = await promisePool.query(`
            SELECT 
                u.id, u.email, u.first_name, u.last_name, u.role as system_role, 
                u.is_active, u.last_login, u.created_at, u.updated_at,
                cu.role as church_role
            FROM church_users cu
            JOIN users u ON cu.user_id = u.id
            WHERE cu.church_id = ?
            ORDER BY u.created_at DESC
        `, [churchId]);

        res.json({
            success: true,
            users: users
        });

    } catch (error) {
        console.error('âŒ Error getting church users:', error);
        res.status(500).json({
            success: false,
            message: 'Failed to get church users',
            error: error.message
        });
    }
});

// GET /admin/churches/:id/record-counts - Get record counts for church
router.get('/churches/:id/record-counts', requireAdmin, async (req, res) => {
    try {
        const churchId = parseInt(req.params.id);
        console.log('ðŸ“Š Getting record counts for church ID:', churchId);

        // Get the church database name
        const [churches] = await promisePool.query(
            'SELECT database_name FROM churches WHERE id = ? AND is_active = 1',
            [churchId]
        );

        if (churches.length === 0) {
            return res.status(404).json({
                success: false,
                message: 'Church not found or inactive'
            });
        }

        const { database_name } = churches[0];

        // Get table names and counts
        const [tables] = await promisePool.query(`
            SELECT TABLE_NAME 
            FROM information_schema.TABLES 
            WHERE TABLE_SCHEMA = ? 
            AND TABLE_NAME LIKE '%_records'
            OR TABLE_NAME IN ('clergy', 'members', 'donations', 'calendar_events')
        `, [database_name]);

        const counts = {};
        
        for (const table of tables) {
            try {
                const [countResult] = await promisePool.query(`
                    SELECT COUNT(*) as count FROM \`${database_name}\`.\`${table.TABLE_NAME}\`
                `);
                counts[table.TABLE_NAME] = countResult[0].count;
            } catch (tableError) {
                console.warn(`âš ï¸ Error counting ${table.TABLE_NAME}:`, tableError.message);
                counts[table.TABLE_NAME] = 0;
            }
        }

        res.json({
            success: true,
            counts: counts
        });

    } catch (error) {
        console.error('âŒ Error getting record counts:', error);
        res.status(500).json({
            success: false,
            message: 'Failed to get record counts',
            error: error.message
        });
    }
});

// GET /admin/churches/:id/database-info - Get database information
router.get('/churches/:id/database-info', requireAdmin, async (req, res) => {
    try {
        const churchId = parseInt(req.params.id);
        console.log('ðŸ—„ï¸ Getting database info for church ID:', churchId);

        // Get the church database name
        const [churches] = await promisePool.query(
            'SELECT database_name FROM churches WHERE id = ? AND is_active = 1',
            [churchId]
        );

        if (churches.length === 0) {
            return res.status(404).json({
                success: false,
                message: 'Church not found or inactive'
            });
        }

        const { database_name } = churches[0];

        // Get database size and table count
        const [dbInfo] = await promisePool.query(`
            SELECT 
                TABLE_SCHEMA as name,
                ROUND(SUM(data_length + index_length) / 1024 / 1024, 2) AS size_mb,
                COUNT(TABLE_NAME) as table_count
            FROM information_schema.TABLES 
            WHERE TABLE_SCHEMA = ?
            GROUP BY TABLE_SCHEMA
        `, [database_name]);

        // Get table list for this database
        const [tables] = await promisePool.query(`
            SELECT TABLE_NAME, TABLE_ROWS, ROUND((data_length + index_length) / 1024 / 1024, 2) AS size_mb
            FROM information_schema.TABLES 
            WHERE TABLE_SCHEMA = ?
            ORDER BY TABLE_NAME
        `, [database_name]);

        // Calculate totals from individual tables if main query fails
        let totalSize = 0;
        let tableCount = tables.length;
        
        if (tables.length > 0) {
            totalSize = tables.reduce((sum, table) => sum + (parseFloat(table.size_mb) || 0), 0);
        }

        // Get backup info (mock for now - in production this would come from backup system)
        const mockBackupInfo = {
            last_backup: '2025-01-17 02:00:00',
            backup_size: '15.3 MB',
            status: 'success'
        };

        // Get recent database changes (mock data - in production this would come from audit logs)
        const mockLogs = [
            {
                timestamp: new Date().toISOString(),
                change_type: 'CREATE',
                table_name: 'baptism_records',
                description: 'Created new baptism record table',
                user_email: 'admin@church.org'
            },
            {
                timestamp: new Date(Date.now() - 86400000).toISOString(),
                change_type: 'ALTER',
                table_name: 'members',
                description: 'Added phone column to members table',
                user_email: 'admin@church.org'
            }
        ];

        // Always return database name, use calculated values as fallback
        const databaseInfo = {
            name: database_name, // Always return the actual database name
            size: dbInfo[0] ? `${dbInfo[0].size_mb} MB` : `${totalSize.toFixed(2)} MB`,
            table_count: dbInfo[0] ? dbInfo[0].table_count : tableCount,
            last_backup: mockBackupInfo.last_backup,
            tables: tables.map(table => ({
                name: table.TABLE_NAME,
                rows: table.TABLE_ROWS || 0,
                size: `${table.size_mb || 0} MB`
            }))
        };

        res.json({
            success: true,
            database: databaseInfo,
            logs: mockLogs
        });

    } catch (error) {
        console.error('âŒ Error getting database info:', error);
        res.status(500).json({
            success: false,
            message: 'Failed to get database info',
            error: error.message
        });
    }
});

// POST /admin/churches/:id/users/:userId/reset-password - Reset user password
router.post('/churches/:id/users/:userId/reset-password', requireAdmin, async (req, res) => {
    try {
        const churchId = parseInt(req.params.id);
        const userId = parseInt(req.params.userId);
        
        // Generate new password
        const newPassword = Math.random().toString(36).slice(-8);
        const bcrypt = require('bcrypt');
        const hashedPassword = await bcrypt.hash(newPassword, 10);

        // Verify church exists
        const [churches] = await promisePool.query(
            'SELECT id, name FROM churches WHERE id = ? AND is_active = 1',
            [churchId]
        );

        if (churches.length === 0) {
            return res.status(404).json({
                success: false,
                message: 'Church not found'
            });
        }

        // Verify user exists and is assigned to this church
        const [userAssignments] = await promisePool.query(
            'SELECT u.id, u.email FROM users u JOIN church_users cu ON u.id = cu.user_id WHERE u.id = ? AND cu.church_id = ?',
            [userId, churchId]
        );

        if (userAssignments.length === 0) {
            return res.status(404).json({
                success: false,
                message: 'User not found or not assigned to this church'
            });
        }

        // Update user password in orthodoxmetrics_db.users
        await promisePool.query(`
            UPDATE users 
            SET password_hash = ?, updated_at = CURRENT_TIMESTAMP 
            WHERE id = ?
        `, [hashedPassword, userId]);

        res.json({
            success: true,
            message: 'Password reset successfully',
            newPassword: newPassword
        });

    } catch (error) {
        console.error('âŒ Error resetting password:', error);
        res.status(500).json({
            success: false,
            message: 'Failed to reset password',
            error: error.message
        });
    }
});

// POST /admin/churches/:id/users/:userId/lock - Lock user account
router.post('/churches/:id/users/:userId/lock', requireAdmin, async (req, res) => {
    try {
        const churchId = parseInt(req.params.id);
        const userId = parseInt(req.params.userId);

        // Verify church exists
        const [churches] = await promisePool.query(
            'SELECT id, name FROM churches WHERE id = ? AND is_active = 1',
            [churchId]
        );

        if (churches.length === 0) {
            return res.status(404).json({
                success: false,
                message: 'Church not found'
            });
        }

        // Verify user exists and is assigned to this church
        const [userAssignments] = await promisePool.query(
            'SELECT u.id FROM users u JOIN church_users cu ON u.id = cu.user_id WHERE u.id = ? AND cu.church_id = ?',
            [userId, churchId]
        );

        if (userAssignments.length === 0) {
            return res.status(404).json({
                success: false,
                message: 'User not found or not assigned to this church'
            });
        }

        // Lock user account in orthodoxmetrics_db.users
        await promisePool.query(`
            UPDATE users 
            SET is_active = 0, updated_at = CURRENT_TIMESTAMP 
            WHERE id = ?
        `, [userId]);

        res.json({
            success: true,
            message: 'User account locked'
        });

    } catch (error) {
        console.error('âŒ Error locking user:', error);
        res.status(500).json({
            success: false,
            message: 'Failed to lock user',
            error: error.message
        });
    }
});

// POST /admin/churches/:id/users/:userId/unlock - Unlock user account
router.post('/churches/:id/users/:userId/unlock', requireAdmin, async (req, res) => {
    try {
        const churchId = parseInt(req.params.id);
        const userId = parseInt(req.params.userId);

        // Verify church exists
        const [churches] = await promisePool.query(
            'SELECT id, name FROM churches WHERE id = ? AND is_active = 1',
            [churchId]
        );

        if (churches.length === 0) {
            return res.status(404).json({
                success: false,
                message: 'Church not found'
            });
        }

        // Verify user exists and is assigned to this church
        const [userAssignments] = await promisePool.query(
            'SELECT u.id FROM users u JOIN church_users cu ON u.id = cu.user_id WHERE u.id = ? AND cu.church_id = ?',
            [userId, churchId]
        );

        if (userAssignments.length === 0) {
            return res.status(404).json({
                success: false,
                message: 'User not found or not assigned to this church'
            });
        }

        // Unlock user account in orthodoxmetrics_db.users
        await promisePool.query(`
            UPDATE users 
            SET is_active = 1, updated_at = CURRENT_TIMESTAMP 
            WHERE id = ?
        `, [userId]);

        res.json({
            success: true,
            message: 'User account unlocked'
        });

    } catch (error) {
        console.error('âŒ Error unlocking user:', error);
        res.status(500).json({
            success: false,
            message: 'Failed to unlock user',
            error: error.message
        });
    }
});

// POST /admin/churches/:id/users - Add new user to church
router.post('/churches/:id/users', requireAdmin, async (req, res) => {
    try {
        const churchId = parseInt(req.params.id);
        const { email, first_name, last_name, role, is_active, phone, landing_page, password } = req.body;
        
        console.log('ðŸ‘¤ Adding new user to church ID:', churchId);

        // Verify church exists
        const [churches] = await promisePool.query(
            'SELECT id, name FROM churches WHERE id = ? AND is_active = 1',
            [churchId]
        );

        if (churches.length === 0) {
            return res.status(404).json({
                success: false,
                message: 'Church not found'
            });
        }

        // Check if user already exists in orthodoxmetrics_db
        const [existingUsers] = await promisePool.query(
            'SELECT id FROM users WHERE email = ?',
            [email]
        );

        if (existingUsers.length > 0) {
            return res.status(400).json({
                success: false,
                message: 'User with this email already exists in the system'
            });
        }

        // Hash password
        const bcrypt = require('bcrypt');
        const hashedPassword = await bcrypt.hash(password, 10);

        // Insert user into orthodoxmetrics_db.users (NOT church database)
        const [result] = await promisePool.query(`
            INSERT INTO users 
            (email, first_name, last_name, phone, role, is_active, landing_page, password_hash, church_id, created_at, updated_at)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())
        `, [email, first_name, last_name, phone, role, is_active, landing_page, hashedPassword, churchId]);

        const newUserId = result.insertId;

        // Assign user to church via church_users junction table
        await promisePool.query(
            'INSERT INTO church_users (church_id, user_id, role) VALUES (?, ?, ?) ON DUPLICATE KEY UPDATE role = VALUES(role)',
            [churchId, newUserId, role]
        );

        console.log(`âœ… User created in orthodoxmetrics_db and assigned to church ${churchId}`);

        res.json({
            success: true,
            message: 'User created and assigned to church successfully',
            user_id: newUserId
        });

    } catch (error) {
        console.error('âŒ Error adding user to church:', error);
        res.status(500).json({
            success: false,
            message: 'Failed to add user',
            error: error.message
        });
    }
});

// PUT /admin/churches/:id/users/:userId - Update church user
router.put('/churches/:id/users/:userId', requireAdmin, async (req, res) => {
    try {
        const churchId = parseInt(req.params.id);
        const userId = parseInt(req.params.userId);
        const { email, first_name, last_name, role, is_active, phone, landing_page, password } = req.body;
        
        console.log('ðŸ‘¤ Updating user ID:', userId, 'in church ID:', churchId);

        // Verify church exists
        const [churches] = await promisePool.query(
            'SELECT id, name FROM churches WHERE id = ? AND is_active = 1',
            [churchId]
        );

        if (churches.length === 0) {
            return res.status(404).json({
                success: false,
                message: 'Church not found'
            });
        }

        // Verify user exists in orthodoxmetrics_db
        const [existingUsers] = await promisePool.query(
            'SELECT id FROM users WHERE id = ?',
            [userId]
        );

        if (existingUsers.length === 0) {
            return res.status(404).json({
                success: false,
                message: 'User not found'
            });
        }

        // Prepare update query for orthodoxmetrics_db.users
        let updateFields = [];
        let updateValues = [];

        // Always update basic info
        updateFields.push('email = ?', 'first_name = ?', 'last_name = ?', 'phone = ?', 'role = ?', 'is_active = ?', 'landing_page = ?', 'updated_at = NOW()');
        updateValues.push(email, first_name, last_name, phone, role, is_active, landing_page);

        // Only update password if provided
        if (password && password.trim()) {
            const bcrypt = require('bcrypt');
            const hashedPassword = await bcrypt.hash(password, 10);
            updateFields.push('password_hash = ?');
            updateValues.push(hashedPassword);
        }

        updateValues.push(userId);

        // Update user in orthodoxmetrics_db.users (NOT church database)
        await promisePool.query(`
            UPDATE users 
            SET ${updateFields.join(', ')}
            WHERE id = ?
        `, updateValues);

        // Update user's role in church_users junction table
        await promisePool.query(
            'UPDATE church_users SET role = ? WHERE church_id = ? AND user_id = ?',
            [role, churchId, userId]
        );

        console.log(`âœ… User ${userId} updated in orthodoxmetrics_db and church assignment updated`);

        res.json({
            success: true,
            message: 'User updated successfully'
        });

    } catch (error) {
        console.error('âŒ Error updating church user:', error);
        res.status(500).json({
            success: false,
            message: 'Failed to update user',
            error: error.message
        });
    }
});

// POST /admin/churches/:id/test-connection - Test database connection
router.post('/churches/:id/test-connection', requireAdmin, async (req, res) => {
    try {
        const churchId = parseInt(req.params.id);
        console.log('ðŸ”Œ Testing database connection for church ID:', churchId);

        // Get the church database name
        const [churches] = await promisePool.query(
            'SELECT database_name, name FROM churches WHERE id = ? AND is_active = 1',
            [churchId]
        );

        if (churches.length === 0) {
            return res.status(404).json({
                success: false,
                message: 'Church not found or inactive'
            });
        }

        const { database_name, name } = churches[0];

        // Test basic connection
        const startTime = Date.now();
        const [connectionTest] = await promisePool.query('SELECT 1 as test');
        const connectionTime = Date.now() - startTime;

        // Test database existence
        const [dbExists] = await promisePool.query(`
            SELECT SCHEMA_NAME 
            FROM information_schema.SCHEMATA 
            WHERE SCHEMA_NAME = ?
        `, [database_name]);

        // Get database stats
        const [dbStats] = await promisePool.query(`
            SELECT 
                COUNT(TABLE_NAME) as table_count,
                ROUND(SUM(data_length + index_length) / 1024 / 1024, 2) AS size_mb
            FROM information_schema.TABLES 
            WHERE TABLE_SCHEMA = ?
        `, [database_name]);

        // Test a sample query on a common table
        let sampleTableTest = null;
        try {
            const [sampleQuery] = await promisePool.query(`
                SELECT COUNT(*) as record_count 
                FROM \`${database_name}\`.baptism_records 
                LIMIT 1
            `);
            sampleTableTest = {
                success: true,
                baptism_records: sampleQuery[0].record_count
            };
        } catch (tableError) {
            sampleTableTest = {
                success: false,
                error: 'Baptism records table not accessible'
            };
        }

        res.json({
            success: true,
            connection: {
                database_name,
                church_name: name,
                database_exists: dbExists.length > 0,
                connection_time_ms: connectionTime,
                table_count: dbStats[0]?.table_count || 0,
                size_mb: dbStats[0]?.size_mb || 0,
                sample_query: sampleTableTest,
                timestamp: new Date().toISOString()
            }
        });

    } catch (error) {
        console.error('âŒ Error testing database connection:', error);
        res.status(500).json({
            success: false,
            message: 'Database connection test failed',
            error: error.message
        });
    }
});

module.exports = router;
