import { BoundComponent } from '../../front-end/src/pages/omb/types';
import { AgentTaskResult, AgentExecutionOptions, AgentLogEntry } from './agents/types';
import agents from './agents';
import * as fs from 'fs/promises';
import * as path from 'path';

export async function runAgentsOnComponent(
  component: BoundComponent,
  options: AgentExecutionOptions = {}
): Promise<AgentTaskResult[]> {
  const { agents: selectedAgents, includeAutofix = false, user = 'system' } = options;
  
  const agentsToRun = selectedAgents 
    ? agents.filter(agent => selectedAgents.includes(agent.name))
    : agents;
  
  const results: AgentTaskResult[] = [];
  
  for (const agent of agentsToRun) {
    try {
      const result = await agent.run(component);
      results.push(result);
      
      // Log the agent execution
      await logAgentExecution(result, user);
      
      // Handle autofix if requested and available
      if (includeAutofix && result.canAutofix && result.autofixAction) {
        await executeAutofix(result, component, user);
      }
    } catch (error) {
      results.push({
        agent: agent.name,
        componentId: component.id,
        action: 'agentExecution',
        status: 'error',
        result: `❌ Agent execution failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
        canAutofix: false,
        timestamp: new Date().toISOString()
      });
    }
  }
  
  return results;
}

async function logAgentExecution(result: AgentTaskResult, user: string): Promise<void> {
  const logEntry: AgentLogEntry = {
    timestamp: result.timestamp,
    agent: result.agent,
    componentId: result.componentId,
    action: result.action,
    status: result.status,
    result: result.result,
    recommendation: result.recommendation,
    canAutofix: result.canAutofix,
    autofixAction: result.autofixAction,
    user,
    metadata: result.metadata
  };
  
  const logFile = 'logs/omai-agent-tasks.log';
  
  try {
    // Ensure logs directory exists
    await fs.mkdir(path.dirname(logFile), { recursive: true });
    
    // Append to log file
    await fs.appendFile(logFile, JSON.stringify(logEntry) + '\n');
  } catch (error) {
    console.error('Failed to log agent execution:', error);
  }
}

async function executeAutofix(
  result: AgentTaskResult,
  component: BoundComponent,
  user: string
): Promise<void> {
  try {
    switch (result.autofixAction) {
      case 'generateDocumentation':
        await generateDocumentation(component);
        break;
      case 'regenerateDocumentation':
        await generateDocumentation(component);
        break;
      case 'generateApiRoute':
        await generateApiRoute(component);
        break;
      case 'registerApiRoute':
        await registerApiRoute(component);
        break;
      case 'generateSchema':
        await generateSchema(component);
        break;
      case 'updateSchema':
        await updateSchema(component);
        break;
      case 'applyRefactoring':
        await applyRefactoring(component, result.metadata);
        break;
      default:
        console.warn(`Unknown autofix action: ${result.autofixAction}`);
    }
    
    // Log successful autofix
    await logAutofixExecution(result, component, user);
  } catch (error) {
    console.error(`Autofix execution failed for ${result.agent}:`, error);
  }
}

async function generateDocumentation(component: BoundComponent): Promise<void> {
  // This would integrate with the existing markdown generation system
  const { generateMarkdownDoc } = require('./generateMarkdownDoc');
  await generateMarkdownDoc(component);
}

async function generateApiRoute(component: BoundComponent): Promise<void> {
  // This would integrate with the existing code generation system
  const { generateFromComponent } = require('../omb/generateFromComponent');
  await generateFromComponent(component, { previewOnly: false });
}

async function registerApiRoute(component: BoundComponent): Promise<void> {
  // Add route registration to server routes index
  const routesIndexPath = 'server/routes/index.js';
  const routeRegistration = `app.use('${component.route}', require('./${component.route.replace('/api/', '').replace('/', '-')}'));\n`;
  
  try {
    const currentContent = await fs.readFile(routesIndexPath, 'utf8');
    if (!currentContent.includes(component.route)) {
      await fs.writeFile(routesIndexPath, currentContent + routeRegistration);
    }
  } catch (error) {
    console.error('Failed to register API route:', error);
  }
}

async function generateSchema(component: BoundComponent): Promise<void> {
  const migrationPath = `migrations/${component.dbTable}_table.sql`;
  const schemaContent = `-- Migration for ${component.dbTable} table
-- Generated by OMAI Agent

CREATE TABLE IF NOT EXISTS ${component.dbTable} (
  id INT PRIMARY KEY AUTO_INCREMENT,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  created_by VARCHAR(255),
  status ENUM('active', 'inactive') DEFAULT 'active',
  -- Add your specific fields here
  PRIMARY KEY (id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- Add indexes as needed
-- CREATE INDEX idx_${component.dbTable}_status ON ${component.dbTable}(status);
-- CREATE INDEX idx_${component.dbTable}_created_at ON ${component.dbTable}(created_at);
`;

  try {
    await fs.mkdir(path.dirname(migrationPath), { recursive: true });
    await fs.writeFile(migrationPath, schemaContent);
  } catch (error) {
    console.error('Failed to generate schema:', error);
  }
}

async function updateSchema(component: BoundComponent): Promise<void> {
  // This would update existing schema files
  console.log(`Schema update for ${component.dbTable} would be implemented here`);
}

async function applyRefactoring(component: BoundComponent, metadata?: Record<string, any>): Promise<void> {
  // This would apply refactoring suggestions
  console.log(`Refactoring for ${component.id} would be implemented here`);
}

async function logAutofixExecution(
  result: AgentTaskResult,
  component: BoundComponent,
  user: string
): Promise<void> {
  const autofixLogEntry: AgentLogEntry = {
    timestamp: new Date().toISOString(),
    agent: result.agent,
    componentId: component.id,
    action: `autofix_${result.autofixAction}`,
    status: 'success',
    result: `✅ Autofix applied: ${result.autofixAction}`,
    canAutofix: false,
    user,
    metadata: result.metadata
  };
  
  const logFile = 'logs/omai-agent-tasks.log';
  
  try {
    await fs.appendFile(logFile, JSON.stringify(autofixLogEntry) + '\n');
  } catch (error) {
    console.error('Failed to log autofix execution:', error);
  }
}

export async function getAgentMetrics(): Promise<any> {
  const logFile = 'logs/omai-agent-tasks.log';
  
  try {
    const logContent = await fs.readFile(logFile, 'utf8');
    const lines = logContent.split('\n').filter(line => line.trim());
    const entries = lines.map(line => JSON.parse(line));
    
    const agentStats: Record<string, number> = {};
    const statusStats: Record<string, number> = {};
    let totalExecutions = 0;
    let successfulFixes = 0;
    
    for (const entry of entries) {
      totalExecutions++;
      agentStats[entry.agent] = (agentStats[entry.agent] || 0) + 1;
      statusStats[entry.status] = (statusStats[entry.status] || 0) + 1;
      
      if (entry.action.startsWith('autofix_')) {
        successfulFixes++;
      }
    }
    
    const mostActiveAgents = Object.entries(agentStats)
      .sort(([,a], [,b]) => b - a)
      .slice(0, 5)
      .map(([agent, count]) => ({ agent, executions: count }));
    
    return {
      totalExecutions,
      successfulFixes,
      warnings: statusStats.warning || 0,
      errors: statusStats.error || 0,
      averageExecutionTime: 0, // Would need timing data
      mostActiveAgents
    };
  } catch (error) {
    return {
      totalExecutions: 0,
      successfulFixes: 0,
      warnings: 0,
      errors: 0,
      averageExecutionTime: 0,
      mostActiveAgents: []
    };
  }
} 