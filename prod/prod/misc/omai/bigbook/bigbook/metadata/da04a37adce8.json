{
  "id": "da04a37adce8",
  "originalPath": "/var/www/orthodox-church-mgmt/orthodoxmetrics/prod/server/scrapers/database/church-database.js",
  "relativePath": "server/scrapers/database/church-database.js",
  "name": "church-database.js",
  "extension": ".js",
  "size": 15943,
  "modified": "2025-07-24T14:51:40.448Z",
  "created": "2025-07-24T14:51:40.444Z",
  "classification": {
    "type": "Database Scripts",
    "category": "Backend > Database",
    "confidence": 4
  },
  "metadata": {
    "fileStats": {
      "lines": 434,
      "characters": 15941,
      "words": 1208
    },
    "classification": {
      "type": "Database Scripts",
      "category": "Backend > Database",
      "confidence": 4
    },
    "dependencies": [
      {
        "type": "npm_package",
        "name": "mysql2/promise",
        "line": 4
      },
      {
        "type": "npm_package",
        "name": "fs",
        "line": 5
      },
      {
        "type": "npm_package",
        "name": "path",
        "line": 6
      }
    ],
    "security": {
      "findings": [
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 11,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 12,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 13,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 14,
          "redacted": true
        }
      ],
      "hasSecurityIssues": true,
      "redactedContent": "// 📁 server/scrapers/database/church-database.js\r\n// Database integration for Orthodox Church Directory\r\n\r\nconst mysql = require('mysql2/promise');\r\nconst fs = require('fs').promises;\r\nconst path = require('path');\r\n\r\nclass ChurchDatabase {\r\n    constructor(options = {}) {\r\n        this.dbConfig = {\r\n            host: options.host || process.env.[REDACTED] || 'localhost',\r\n            user: options.user || process.env.[REDACTED] || 'orthodoxapps',\r\n            password: options.password || process.env.[REDACTED] || 'Summerof1982@!',\r\n            database: options.database || process.env.[REDACTED] || 'orthodoxmetrics',\r\n            charset: 'utf8mb4',\r\n            ...options.dbConfig\r\n        };\r\n        \r\n        this.logger = options.logger || console;\r\n        this.pool = null;\r\n    }\r\n\r\n    async initialize() {\r\n        try {\r\n            // Create connection pool\r\n            this.pool = mysql.createPool({\r\n                ...this.dbConfig,\r\n                waitForConnections: true,\r\n                connectionLimit: 10,\r\n                queueLimit: 0,\r\n                acquireTimeout: 60000,\r\n                timeout: 60000\r\n            });\r\n\r\n            // Test connection\r\n            const connection = await this.pool.getConnection();\r\n            await connection.ping();\r\n            connection.release();\r\n\r\n            this.logger.info('Database connection established');\r\n            \r\n            // Initialize schema if needed\r\n            await this.initializeSchema();\r\n            \r\n        } catch (error) {\r\n            this.logger.error('Failed to initialize database', { error: error.message });\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    async initializeSchema() {\r\n        try {\r\n            // Check if churches table exists\r\n            const [rows] = await this.pool.execute(`\r\n                SELECT COUNT(*) as count \r\n                FROM information_schema.tables \r\n                WHERE table_schema = ? AND table_name = 'orthodox_churches'\r\n            `, [this.dbConfig.database]);\r\n\r\n            if (rows[0].count === 0) {\r\n                this.logger.info('Churches table not found, creating schema...');\r\n                await this.createSchema();\r\n            } else {\r\n                this.logger.info('Churches table already exists');\r\n            }\r\n        } catch (error) {\r\n            this.logger.error('Error checking schema', { error: error.message });\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    async createSchema() {\r\n        try {\r\n            const schemaPath = path.join(__dirname, '../schema/churches-schema.sql');\r\n            const schemaSql = await fs.readFile(schemaPath, 'utf8');\r\n            \r\n            // Split by delimiter and execute each statement\r\n            const statements = schemaSql\r\n                .split(/;\\s*(?=(?:[^']*'[^']*')*[^']*$)/) // Split on semicolons not in quotes\r\n                .filter(stmt => stmt.trim().length > 0);\r\n\r\n            for (const statement of statements) {\r\n                if (statement.trim()) {\r\n                    await this.pool.execute(statement);\r\n                }\r\n            }\r\n\r\n            this.logger.info('Database schema created successfully');\r\n        } catch (error) {\r\n            this.logger.error('Error creating schema', { error: error.message });\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    async startScrapingSession(config = {}) {\r\n        try {\r\n            const [result] = await this.pool.execute(`\r\n                INSERT INTO scraping_sessions (\r\n                    session_start, \r\n                    scraper_version, \r\n                    config_options, \r\n                    status\r\n                ) VALUES (NOW(), ?, ?, 'running')\r\n            `, ['1.0.0', JSON.stringify(config)]);\r\n\r\n            const sessionId = result.insertId;\r\n            this.logger.info('Scraping session started', { sessionId });\r\n            return sessionId;\r\n        } catch (error) {\r\n            this.logger.error('Error starting scraping session', { error: error.message });\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    async endScrapingSession(sessionId, statistics, errors = []) {\r\n        try {\r\n            await this.pool.execute(`\r\n                UPDATE scraping_sessions SET\r\n                    session_end = NOW(),\r\n                    total_churches_scraped = ?,\r\n                    total_churches_saved = ?,\r\n                    duplicates_found = ?,\r\n                    urls_validated = ?,\r\n                    errors_count = ?,\r\n                    jurisdiction_breakdown = ?,\r\n                    status = 'completed'\r\n                WHERE id = ?\r\n            `, [\r\n                statistics.totalChurches,\r\n                statistics.totalChurches - statistics.duplicatesFound,\r\n                statistics.duplicatesFound,\r\n                statistics.validatedUrls,\r\n                errors.length,\r\n                JSON.stringify(statistics.jurisdictionCounts),\r\n                sessionId\r\n            ]);\r\n\r\n            // Insert errors\r\n            if (errors.length > 0) {\r\n                await this.insertScrapingErrors(sessionId, errors);\r\n            }\r\n\r\n            this.logger.info('Scraping session completed', { sessionId });\r\n        } catch (error) {\r\n            this.logger.error('Error ending scraping session', { error: error.message });\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    async insertScrapingErrors(sessionId, errors) {\r\n        if (errors.length === 0) return;\r\n\r\n        try {\r\n            const values = errors.map(error => [\r\n                sessionId,\r\n                error.jurisdiction,\r\n                error.type || 'scraping_error',\r\n                error.error || error.message,\r\n                error.url || null\r\n            ]);\r\n\r\n            await this.pool.execute(`\r\n                INSERT INTO scraping_errors (session_id, jurisdiction, error_type, error_message, url)\r\n                VALUES ${values.map(() => '(?, ?, ?, ?, ?)').join(', ')}\r\n            `, values.flat());\r\n\r\n        } catch (error) {\r\n            this.logger.error('Error inserting scraping errors', { error: error.message });\r\n        }\r\n    }\r\n\r\n    async saveChurches(churches) {\r\n        if (churches.length === 0) return;\r\n\r\n        this.logger.info('Saving churches to database', { count: churches.length });\r\n\r\n        const connection = await this.pool.getConnection();\r\n        await connection.beginTransaction();\r\n\r\n        try {\r\n            let savedCount = 0;\r\n            let duplicateCount = 0;\r\n\r\n            for (const church of churches) {\r\n                const existing = await this.findExistingChurch(connection, church);\r\n                \r\n                if (existing) {\r\n                    // Update existing record\r\n                    await this.updateChurch(connection, existing.id, church);\r\n                    duplicateCount++;\r\n                } else {\r\n                    // Insert new record\r\n                    await this.insertChurch(connection, church);\r\n                    savedCount++;\r\n                }\r\n            }\r\n\r\n            await connection.commit();\r\n            this.logger.info('Churches saved successfully', { \r\n                saved: savedCount, \r\n                updated: duplicateCount \r\n            });\r\n\r\n            return { saved: savedCount, updated: duplicateCount };\r\n\r\n        } catch (error) {\r\n            await connection.rollback();\r\n            this.logger.error('Error saving churches', { error: error.message });\r\n            throw error;\r\n        } finally {\r\n            connection.release();\r\n        }\r\n    }\r\n\r\n    async findExistingChurch(connection, church) {\r\n        // Look for existing church by name and location\r\n        const [rows] = await connection.execute(`\r\n            SELECT id, name, city, state, website, contact_phone\r\n            FROM orthodox_churches\r\n            WHERE (\r\n                (name = ? OR name_normalized = ?) OR\r\n                (website IS NOT NULL AND website = ?) OR\r\n                (contact_phone IS NOT NULL AND contact_phone = ?)\r\n            ) AND (\r\n                city = ? OR state = ?\r\n            )\r\n            LIMIT 1\r\n        `, [\r\n            church.name,\r\n            church.name_normalized,\r\n            church.website,\r\n            church.contact_phone,\r\n            church.city,\r\n            church.state\r\n        ]);\r\n\r\n        return rows.length > 0 ? rows[0] : null;\r\n    }\r\n\r\n    async insertChurch(connection, church) {\r\n        const [result] = await connection.execute(`\r\n            INSERT INTO orthodox_churches (\r\n                name, name_normalized, jurisdiction, address, city, state, zip_code,\r\n                full_address, website, website_validated, contact_email, contact_phone,\r\n                establishment_year, clergy_contact, search_keywords, source_url,\r\n                source_urls, scraper_version, merged_from, merge_date\r\n            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\r\n        `, [\r\n            church.name,\r\n            church.name_normalized,\r\n            church.jurisdiction,\r\n            church.address,\r\n            church.city,\r\n            church.state,\r\n            church.zip_code,\r\n            church.full_address,\r\n            church.website,\r\n            church.website_validated,\r\n            church.contact_email,\r\n            church.contact_phone,\r\n            church.establishment_year,\r\n            church.clergy_contact,\r\n            church.search_keywords,\r\n            church.source_url,\r\n            church.source_urls ? JSON.stringify(church.source_urls) : null,\r\n            church.scraper_version || '1.0.0',\r\n            church.merged_from,\r\n            church.merge_date\r\n        ]);\r\n\r\n        return result.insertId;\r\n    }\r\n\r\n    async updateChurch(connection, churchId, church) {\r\n        await connection.execute(`\r\n            UPDATE orthodox_churches SET\r\n                name = COALESCE(?, name),\r\n                name_normalized = COALESCE(?, name_normalized),\r\n                jurisdiction = COALESCE(?, jurisdiction),\r\n                address = COALESCE(?, address),\r\n                city = COALESCE(?, city),\r\n                state = COALESCE(?, state),\r\n                zip_code = COALESCE(?, zip_code),\r\n                full_address = COALESCE(?, full_address),\r\n                website = COALESCE(?, website),\r\n                website_validated = COALESCE(?, website_validated),\r\n                contact_email = COALESCE(?, contact_email),\r\n                contact_phone = COALESCE(?, contact_phone),\r\n                establishment_year = COALESCE(?, establishment_year),\r\n                clergy_contact = COALESCE(?, clergy_contact),\r\n                search_keywords = COALESCE(?, search_keywords),\r\n                source_url = COALESCE(?, source_url),\r\n                last_updated = NOW()\r\n            WHERE id = ?\r\n        `, [\r\n            church.name,\r\n            church.name_normalized,\r\n            church.jurisdiction,\r\n            church.address,\r\n            church.city,\r\n            church.state,\r\n            church.zip_code,\r\n            church.full_address,\r\n            church.website,\r\n            church.website_validated,\r\n            church.contact_email,\r\n            church.contact_phone,\r\n            church.establishment_year,\r\n            church.clergy_contact,\r\n            church.search_keywords,\r\n            church.source_url,\r\n            churchId\r\n        ]);\r\n    }\r\n\r\n    async saveUrlValidations(validations) {\r\n        if (validations.length === 0) return;\r\n\r\n        try {\r\n            const values = validations.map(validation => [\r\n                validation.church_id,\r\n                validation.url,\r\n                validation.isValid,\r\n                validation.status,\r\n                validation.responseTime,\r\n                validation.redirectUrl,\r\n                validation.error\r\n            ]);\r\n\r\n            await this.pool.execute(`\r\n                INSERT INTO url_validations (\r\n                    church_id, url, is_valid, status_code, response_time, redirect_url, error_message\r\n                ) VALUES ${values.map(() => '(?, ?, ?, ?, ?, ?, ?)').join(', ')}\r\n                ON DUPLICATE KEY UPDATE\r\n                    is_valid = VALUES(is_valid),\r\n                    status_code = VALUES(status_code),\r\n                    response_time = VALUES(response_time),\r\n                    redirect_url = VALUES(redirect_url),\r\n                    error_message = VALUES(error_message),\r\n                    validated_at = NOW()\r\n            `, values.flat());\r\n\r\n            this.logger.info('URL validations saved', { count: validations.length });\r\n        } catch (error) {\r\n            this.logger.error('Error saving URL validations', { error: error.message });\r\n        }\r\n    }\r\n\r\n    async getChurchesByJurisdiction(jurisdiction) {\r\n        try {\r\n            const [rows] = await this.pool.execute(`\r\n                SELECT * FROM orthodox_churches \r\n                WHERE jurisdiction = ? \r\n                ORDER BY state, city, name\r\n            `, [jurisdiction]);\r\n\r\n            return rows;\r\n        } catch (error) {\r\n            this.logger.error('Error getting churches by jurisdiction', { error: error.message });\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    async searchChurches(searchTerm, limit = 50) {\r\n        try {\r\n            const [rows] = await this.pool.execute(`\r\n                SELECT *, \r\n                       MATCH(name, city, address, clergy_contact, search_keywords) \r\n                       AGAINST(? IN NATURAL LANGUAGE MODE) as relevance_score\r\n                FROM orthodox_churches \r\n                WHERE MATCH(name, city, address, clergy_contact, search_keywords) \r\n                      AGAINST(? IN NATURAL LANGUAGE MODE)\r\n                ORDER BY relevance_score DESC\r\n                LIMIT ?\r\n            `, [searchTerm, searchTerm, limit]);\r\n\r\n            return rows;\r\n        } catch (error) {\r\n            this.logger.error('Error searching churches', { error: error.message });\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    async getStatistics() {\r\n        try {\r\n            const [stats] = await this.pool.execute(`\r\n                SELECT \r\n                    COUNT(*) as total_churches,\r\n                    COUNT(DISTINCT jurisdiction) as total_jurisdictions,\r\n                    COUNT(website) as churches_with_websites,\r\n                    COUNT(CASE WHEN website_validated = 1 THEN 1 END) as validated_websites,\r\n                    COUNT(contact_email) as churches_with_email,\r\n                    COUNT(contact_phone) as churches_with_phone,\r\n                    AVG(CASE WHEN establishment_year IS NOT NULL THEN establishment_year END) as avg_establishment_year,\r\n                    MAX(last_updated) as last_scrape_update\r\n                FROM orthodox_churches\r\n            `);\r\n\r\n            const [jurisdictionStats] = await this.pool.execute(`\r\n                SELECT jurisdiction, COUNT(*) as count\r\n                FROM orthodox_churches\r\n                GROUP BY jurisdiction\r\n                ORDER BY count DESC\r\n            `);\r\n\r\n            const [stateStats] = await this.pool.execute(`\r\n                SELECT state, COUNT(*) as count\r\n                FROM orthodox_churches\r\n                WHERE state IS NOT NULL\r\n                GROUP BY state\r\n                ORDER BY count DESC\r\n            `);\r\n\r\n            return {\r\n                overall: stats[0],\r\n                byJurisdiction: jurisdictionStats,\r\n                byState: stateStats\r\n            };\r\n        } catch (error) {\r\n            this.logger.error('Error getting statistics', { error: error.message });\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    async close() {\r\n        if (this.pool) {\r\n            await this.pool.end();\r\n            this.logger.info('Database connection closed');\r\n        }\r\n    }\r\n}\r\n\r\nmodule.exports = ChurchDatabase;\r\n"
    },
    "complexity": {
      "totalLines": 434,
      "codeLines": 371,
      "commentLines": 11,
      "commentRatio": 0.028795811518324606,
      "averageLineLength": 40.30628272251309
    },
    "lastAnalyzed": "2025-07-28T07:20:00.584Z"
  },
  "contentHash": "7969a2a22d340cc869acba9c0d171849d6e1329fa9f2f91b1d6dc81c704cce97",
  "discoveredAt": "2025-07-28T07:20:00.584Z"
}