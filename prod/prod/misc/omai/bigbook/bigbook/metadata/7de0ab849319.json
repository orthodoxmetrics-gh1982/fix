{
  "id": "7de0ab849319",
  "originalPath": "/var/www/orthodox-church-mgmt/orthodoxmetrics/prod/server/routes/templates.js",
  "relativePath": "server/routes/templates.js",
  "name": "templates.js",
  "extension": ".js",
  "size": 20448,
  "modified": "2025-07-12T02:27:46.707Z",
  "created": "2025-07-12T01:49:49.143Z",
  "classification": {
    "type": "Server Scripts",
    "category": "Backend > Server",
    "confidence": 7
  },
  "metadata": {
    "fileStats": {
      "lines": 732,
      "characters": 20448,
      "words": 2038
    },
    "classification": {
      "type": "Server Scripts",
      "category": "Backend > Server",
      "confidence": 7
    },
    "dependencies": [
      {
        "type": "npm_package",
        "name": "express",
        "line": 2
      },
      {
        "type": "npm_package",
        "name": "multer",
        "line": 5
      },
      {
        "type": "npm_package",
        "name": "csv-parser",
        "line": 6
      },
      {
        "type": "npm_package",
        "name": "fs",
        "line": 7
      },
      {
        "type": "npm_package",
        "name": "path",
        "line": 569
      }
    ],
    "security": {
      "findings": [
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 92,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 121,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 157,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 235,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 286,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 362,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 465,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 488,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 511,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 534,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 557,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 591,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 642,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 666,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 726,
          "redacted": true
        }
      ],
      "hasSecurityIssues": true,
      "redactedContent": "// server/routes/templates.js\r\nconst express = require('express');\r\nconst router = express.Router();\r\nconst TemplateService = require('../services/templateService');\r\nconst multer = require('multer');\r\nconst csv = require('csv-parser');\r\nconst fs = require('fs');\r\n\r\n// Configure multer for file uploads\r\nconst upload = multer({ \r\n  dest: 'uploads/temp/',\r\n  fileFilter: (req, file, cb) => {\r\n    // Accept CSV and JSON files\r\n    if (file.mimetype === 'text/csv' || \r\n        file.mimetype === 'application/json' || \r\n        file.originalname.endsWith('.csv') || \r\n        file.originalname.endsWith('.json')) {\r\n      cb(null, true);\r\n    } else {\r\n      cb(new Error('Only CSV and JSON files are allowed'));\r\n    }\r\n  },\r\n  limits: {\r\n    fileSize: 5 * 1024 * 1024 // 5MB limit\r\n  }\r\n});\r\n\r\n/**\r\n * POST /api/templates/generate\r\n * Generate a new template file from field definitions\r\n */\r\nrouter.post('/generate', async (req, res) => {\r\n  try {\r\n    const { templateName, fields, options = {}, churchId } = req.body;\r\n\r\n    // Validate request\r\n    if (!templateName || !fields) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        error: 'Template name and fields are required'\r\n      });\r\n    }\r\n\r\n    // Validate template name (should be PascalCase, no spaces)\r\n    const templateNameRegex = /^[A-Z][a-zA-Z0-9]*$/;\r\n    if (!templateNameRegex.test(templateName)) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        error: 'Template name must be in PascalCase format (e.g., \"BaptismRecords\")'\r\n      });\r\n    }\r\n\r\n    // Validate fields structure\r\n    if (!TemplateService.validateFields(fields)) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        error: 'Invalid fields structure. Each field must have \"field\" and \"label\" properties'\r\n      });\r\n    }\r\n\r\n    // Add church ID to options if provided\r\n    if (churchId) {\r\n      options.churchId = churchId;\r\n    }\r\n\r\n    // Generate the template\r\n    const filePath = await TemplateService.generateTemplate(templateName, fields, options);\r\n\r\n    res.json({\r\n      success: true,\r\n      message: 'Template generated successfully',\r\n      data: {\r\n        templateName,\r\n        filePath,\r\n        fieldsCount: fields.length\r\n      }\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error generating template:', error);\r\n    \r\n    if (error.message.includes('EEXIST') || error.message.includes('Duplicate entry')) {\r\n      return res.status(409).json({\r\n        success: false,\r\n        error: 'Template with this name already exists'\r\n      });\r\n    }\r\n\r\n    res.status(500).json({\r\n      success: false,\r\n      error: 'Failed to generate template',\r\n      details: process.env.[REDACTED] === 'development' ? error.message : undefined\r\n    });\r\n  }\r\n});\r\n\r\n/**\r\n * GET /api/templates\r\n * Get all templates with metadata (with optional church filtering)\r\n */\r\nrouter.get('/', async (req, res) => {\r\n  try {\r\n    const { churchId, includeGlobal = 'true' } = req.query;\r\n    \r\n    const templates = await TemplateService.getAllTemplates(\r\n      churchId ? parseInt(churchId) : null,\r\n      includeGlobal === 'true'\r\n    );\r\n\r\n    res.json({\r\n      success: true,\r\n      data: templates,\r\n      count: templates.length\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error fetching templates:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      error: 'Failed to fetch templates',\r\n      details: process.env.[REDACTED] === 'development' ? error.message : undefined\r\n    });\r\n  }\r\n});\r\n\r\n/**\r\n * GET /api/templates/:name\r\n * Get a specific template by name (with optional church filtering)\r\n */\r\nrouter.get('/:name', async (req, res) => {\r\n  try {\r\n    const { name } = req.params;\r\n    const { churchId } = req.query;\r\n    \r\n    const template = await TemplateService.getTemplateByName(\r\n      name, \r\n      churchId ? parseInt(churchId) : null\r\n    );\r\n\r\n    if (!template) {\r\n      return res.status(404).json({\r\n        success: false,\r\n        error: 'Template not found'\r\n      });\r\n    }\r\n\r\n    res.json({\r\n      success: true,\r\n      data: template\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error fetching template:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      error: 'Failed to fetch template',\r\n      details: process.env.[REDACTED] === 'development' ? error.message : undefined\r\n    });\r\n  }\r\n});\r\n\r\n/**\r\n * PUT /api/templates/:name\r\n * Update an existing template (with church permission check)\r\n */\r\nrouter.put('/:name', async (req, res) => {\r\n  try {\r\n    const { name } = req.params;\r\n    const { fields, churchId, ...updates } = req.body;\r\n\r\n    // Check if template exists\r\n    const existingTemplate = await TemplateService.getTemplateByName(\r\n      name, \r\n      churchId ? parseInt(churchId) : null\r\n    );\r\n    \r\n    if (!existingTemplate) {\r\n      return res.status(404).json({\r\n        success: false,\r\n        error: 'Template not found'\r\n      });\r\n    }\r\n\r\n    if (fields) {\r\n      // Validate fields structure\r\n      if (!TemplateService.validateFields(fields)) {\r\n        return res.status(400).json({\r\n          success: false,\r\n          error: 'Invalid fields structure. Each field must have \"field\" and \"label\" properties'\r\n        });\r\n      }\r\n\r\n      // Regenerate the template with new fields\r\n      const filePath = await TemplateService.generateTemplate(name, fields, {\r\n        ...updates,\r\n        churchId: churchId ? parseInt(churchId) : null\r\n      });\r\n\r\n      res.json({\r\n        success: true,\r\n        message: 'Template updated successfully',\r\n        data: {\r\n          templateName: name,\r\n          filePath,\r\n          fieldsCount: fields.length\r\n        }\r\n      });\r\n    } else {\r\n      // Update only metadata\r\n      await TemplateService.updateTemplate(\r\n        name, \r\n        updates, \r\n        churchId ? parseInt(churchId) : null\r\n      );\r\n\r\n      res.json({\r\n        success: true,\r\n        message: 'Template metadata updated successfully'\r\n      });\r\n    }\r\n\r\n  } catch (error) {\r\n    console.error('Error updating template:', error);\r\n    \r\n    if (error.message.includes('Permission denied') || error.message.includes('Cannot modify')) {\r\n      return res.status(403).json({\r\n        success: false,\r\n        error: error.message\r\n      });\r\n    }\r\n    \r\n    res.status(500).json({\r\n      success: false,\r\n      error: 'Failed to update template',\r\n      details: process.env.[REDACTED] === 'development' ? error.message : undefined\r\n    });\r\n  }\r\n});\r\n\r\n/**\r\n * DELETE /api/templates/:name\r\n * Delete a template and its file (with church permission check)\r\n */\r\nrouter.delete('/:name', async (req, res) => {\r\n  try {\r\n    const { name } = req.params;\r\n    const { churchId } = req.body;\r\n\r\n    const success = await TemplateService.deleteTemplate(\r\n      name, \r\n      churchId ? parseInt(churchId) : null\r\n    );\r\n\r\n    if (success) {\r\n      res.json({\r\n        success: true,\r\n        message: 'Template deleted successfully'\r\n      });\r\n    } else {\r\n      res.status(404).json({\r\n        success: false,\r\n        error: 'Template not found'\r\n      });\r\n    }\r\n\r\n  } catch (error) {\r\n    console.error('Error deleting template:', error);\r\n    \r\n    if (error.message === 'Template not found') {\r\n      return res.status(404).json({\r\n        success: false,\r\n        error: 'Template not found'\r\n      });\r\n    }\r\n\r\n    if (error.message.includes('Permission denied') || error.message.includes('Cannot delete')) {\r\n      return res.status(403).json({\r\n        success: false,\r\n        error: error.message\r\n      });\r\n    }\r\n\r\n    res.status(500).json({\r\n      success: false,\r\n      error: 'Failed to delete template',\r\n      details: process.env.[REDACTED] === 'development' ? error.message : undefined\r\n    });\r\n  }\r\n});\r\n\r\n/**\r\n * POST /api/templates/validate\r\n * Validate template fields structure without creating a template\r\n */\r\nrouter.post('/validate', async (req, res) => {\r\n  try {\r\n    const { templateName, fields } = req.body;\r\n\r\n    const validation = {\r\n      templateName: {\r\n        valid: templateName && /^[A-Z][a-zA-Z0-9]*$/.test(templateName),\r\n        message: 'Template name must be in PascalCase format'\r\n      },\r\n      fields: {\r\n        valid: TemplateService.validateFields(fields),\r\n        message: 'Each field must have \"field\" and \"label\" properties'\r\n      }\r\n    };\r\n\r\n    const isValid = validation.templateName.valid && validation.fields.valid;\r\n\r\n    res.json({\r\n      success: true,\r\n      valid: isValid,\r\n      validation\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error validating template:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      error: 'Failed to validate template'\r\n    });\r\n  }\r\n});\r\n\r\n/**\r\n * GET /api/templates/type/:recordType\r\n * Get templates by record type (with optional church filtering)\r\n */\r\nrouter.get('/type/:recordType', async (req, res) => {\r\n  try {\r\n    const { recordType } = req.params;\r\n    const { churchId, includeGlobal = 'true' } = req.query;\r\n    \r\n    // Validate record type\r\n    const validTypes = ['baptism', 'marriage', 'funeral', 'custom'];\r\n    if (!validTypes.includes(recordType)) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        error: 'Invalid record type. Must be one of: ' + validTypes.join(', ')\r\n      });\r\n    }\r\n\r\n    const templates = await TemplateService.getTemplatesByType(\r\n      recordType,\r\n      churchId ? parseInt(churchId) : null,\r\n      includeGlobal === 'true'\r\n    );\r\n    \r\n    res.json({\r\n      success: true,\r\n      data: templates,\r\n      count: templates.length\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error getting templates by type:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      error: 'Error retrieving templates by type',\r\n      details: process.env.[REDACTED] === 'development' ? error.message : undefined\r\n    });\r\n  }\r\n});\r\n\r\n/**\r\n * POST /api/templates/upload\r\n * Upload and parse CSV/JSON file to generate field definitions\r\n */\r\nrouter.post('/upload', upload.single('file'), async (req, res) => {\r\n  try {\r\n    if (!req.file) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        error: 'No file uploaded'\r\n      });\r\n    }\r\n\r\n    const filePath = req.file.path;\r\n    const originalName = req.file.originalname;\r\n    let fields = [];\r\n\r\n    try {\r\n      if (originalName.endsWith('.json')) {\r\n        // Parse JSON file\r\n        const jsonData = JSON.parse(fs.readFileSync(filePath, 'utf-8'));\r\n        \r\n        if (Array.isArray(jsonData) && jsonData.length > 0) {\r\n          // If it's an array of objects, use the keys from the first object\r\n          const sampleObject = jsonData[0];\r\n          fields = Object.keys(sampleObject).map(key => ({\r\n            field: key,\r\n            label: key.replace(/_/g, ' ').replace(/\\b\\w/g, l => l.toUpperCase()),\r\n            type: typeof sampleObject[key] === 'number' ? 'number' : \r\n                  (key.toLowerCase().includes('date') ? 'date' : 'string')\r\n          }));\r\n        } else if (typeof jsonData === 'object') {\r\n          // If it's a single object, use its keys\r\n          fields = Object.keys(jsonData).map(key => ({\r\n            field: key,\r\n            label: key.replace(/_/g, ' ').replace(/\\b\\w/g, l => l.toUpperCase()),\r\n            type: typeof jsonData[key] === 'number' ? 'number' : \r\n                  (key.toLowerCase().includes('date') ? 'date' : 'string')\r\n          }));\r\n        }\r\n      } else if (originalName.endsWith('.csv')) {\r\n        // Parse CSV file\r\n        const results = [];\r\n        \r\n        await new Promise((resolve, reject) => {\r\n          fs.createReadStream(filePath)\r\n            .pipe(csv())\r\n            .on('data', (data) => results.push(data))\r\n            .on('end', () => resolve())\r\n            .on('error', (error) => reject(error));\r\n        });\r\n\r\n        if (results.length > 0) {\r\n          const headers = Object.keys(results[0]);\r\n          const sampleRow = results[0];\r\n          \r\n          fields = headers.map(header => ({\r\n            field: header.toLowerCase().replace(/\\s+/g, '_'),\r\n            label: header,\r\n            type: isNaN(sampleRow[header]) ? \r\n                  (header.toLowerCase().includes('date') ? 'date' : 'string') : \r\n                  'number'\r\n          }));\r\n        }\r\n      }\r\n\r\n      // Clean up uploaded file\r\n      fs.unlinkSync(filePath);\r\n\r\n      if (fields.length === 0) {\r\n        return res.status(400).json({\r\n          success: false,\r\n          error: 'Unable to parse fields from the uploaded file'\r\n        });\r\n      }\r\n\r\n      res.json({\r\n        success: true,\r\n        message: 'File parsed successfully',\r\n        data: {\r\n          fields,\r\n          suggestedTemplateName: originalName.replace(/\\.(csv|json)$/i, 'Records')\r\n        }\r\n      });\r\n\r\n    } catch (parseError) {\r\n      // Clean up uploaded file\r\n      if (fs.existsSync(filePath)) {\r\n        fs.unlinkSync(filePath);\r\n      }\r\n      throw parseError;\r\n    }\r\n\r\n  } catch (error) {\r\n    console.error('Error processing uploaded file:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      error: 'Error processing uploaded file',\r\n      details: process.env.[REDACTED] === 'development' ? error.message : undefined\r\n    });\r\n  }\r\n});\r\n\r\n/**\r\n * POST /api/templates/init\r\n * Initialize the templates database table\r\n */\r\nrouter.post('/init', async (req, res) => {\r\n  try {\r\n    await TemplateService.initializeDatabase();\r\n    \r\n    res.json({\r\n      success: true,\r\n      message: 'Templates database initialized successfully'\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error initializing templates database:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      error: 'Failed to initialize templates database',\r\n      details: process.env.[REDACTED] === 'development' ? error.message : undefined\r\n    });\r\n  }\r\n});\r\n\r\n/**\r\n * POST /api/templates/sync\r\n * Sync existing template files with database\r\n */\r\nrouter.post('/sync', async (req, res) => {\r\n  try {\r\n    await TemplateService.syncExistingTemplates();\r\n\r\n    res.json({\r\n      success: true,\r\n      message: 'Templates synced successfully'\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error syncing templates:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      error: 'Failed to sync templates',\r\n      details: process.env.[REDACTED] === 'development' ? error.message : undefined\r\n    });\r\n  }\r\n});\r\n\r\n/**\r\n * GET /api/templates/predefined/definitions\r\n * Get predefined template definitions\r\n */\r\nrouter.get('/predefined/definitions', async (req, res) => {\r\n  try {\r\n    const predefinedTemplates = TemplateService.getPredefinedTemplates();\r\n\r\n    res.json({\r\n      success: true,\r\n      data: predefinedTemplates\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error getting predefined templates:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      error: 'Failed to retrieve predefined templates',\r\n      details: process.env.[REDACTED] === 'development' ? error.message : undefined\r\n    });\r\n  }\r\n});\r\n\r\n/**\r\n * POST /api/templates/predefined/initialize\r\n * Initialize predefined templates\r\n */\r\nrouter.post('/predefined/initialize', async (req, res) => {\r\n  try {\r\n    await TemplateService.initializePredefinedTemplates();\r\n\r\n    res.json({\r\n      success: true,\r\n      message: 'Predefined templates initialized successfully'\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error initializing predefined templates:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      error: 'Failed to initialize predefined templates',\r\n      details: process.env.[REDACTED] === 'development' ? error.message : undefined\r\n    });\r\n  }\r\n});\r\n\r\n/**\r\n * POST /api/templates/analyze/:filename\r\n * Analyze an existing template file and extract field definitions\r\n */\r\nrouter.post('/analyze/:filename', async (req, res) => {\r\n  try {\r\n    const { filename } = req.params;\r\n    const path = require('path');\r\n    \r\n    // Construct file path\r\n    const filePath = path.resolve(__dirname, `../../front-end/src/views/records/${filename}`);\r\n    \r\n    // Extract fields from the template\r\n    const fields = TemplateService.extractFieldsFromTemplate(filePath);\r\n\r\n    res.json({\r\n      success: true,\r\n      data: {\r\n        filename,\r\n        fields,\r\n        fieldCount: fields.length\r\n      }\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error analyzing template:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      error: error.message || 'Failed to analyze template',\r\n      details: process.env.[REDACTED] === 'development' ? error.message : undefined\r\n    });\r\n  }\r\n});\r\n\r\n/**\r\n * GET /api/templates/types/record-types\r\n * Get available record types\r\n */\r\nrouter.get('/types/record-types', async (req, res) => {\r\n  try {\r\n    const recordTypes = [\r\n      { value: 'baptism', label: 'Baptism Records', description: 'Orthodox baptism ceremonies' },\r\n      { value: 'marriage', label: 'Marriage Records', description: 'Orthodox wedding ceremonies' },\r\n      { value: 'funeral', label: 'Funeral Records', description: 'Orthodox funeral services' },\r\n      { value: 'custom', label: 'Custom Records', description: 'Custom record types' }\r\n    ];\r\n\r\n    res.json({\r\n      success: true,\r\n      data: recordTypes\r\n    });\r\n\r\n  } catch (error) {\r\n    res.status(500).json({\r\n      success: false,\r\n      error: 'Failed to retrieve record types'\r\n    });\r\n  }\r\n});\r\n\r\n/**\r\n * GET /api/templates/church/:churchId\r\n * Get all templates for a specific church (including global templates)\r\n */\r\nrouter.get('/church/:churchId', async (req, res) => {\r\n  try {\r\n    const { churchId } = req.params;\r\n    const templates = await TemplateService.getTemplatesForChurch(parseInt(churchId));\r\n\r\n    res.json({\r\n      success: true,\r\n      data: templates,\r\n      count: templates.length\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error getting templates for church:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      error: 'Failed to fetch church templates',\r\n      details: process.env.[REDACTED] === 'development' ? error.message : undefined\r\n    });\r\n  }\r\n});\r\n\r\n/**\r\n * GET /api/templates/global/available\r\n * Get available global templates that can be duplicated\r\n */\r\nrouter.get('/global/available', async (req, res) => {\r\n  try {\r\n    const globalTemplates = await TemplateService.getGlobalTemplates();\r\n\r\n    res.json({\r\n      success: true,\r\n      data: globalTemplates,\r\n      count: globalTemplates.length\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error getting global templates:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      error: 'Failed to fetch global templates',\r\n      details: process.env.[REDACTED] === 'development' ? error.message : undefined\r\n    });\r\n  }\r\n});\r\n\r\n/**\r\n * POST /api/templates/duplicate\r\n * Duplicate a global template for a specific church\r\n */\r\nrouter.post('/duplicate', async (req, res) => {\r\n  try {\r\n    const { globalTemplateName, churchId, newName, options = {} } = req.body;\r\n\r\n    if (!globalTemplateName || !churchId || !newName) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        error: 'Global template name, church ID, and new name are required'\r\n      });\r\n    }\r\n\r\n    // Validate new template name\r\n    const templateNameRegex = /^[A-Z][a-zA-Z0-9]*$/;\r\n    if (!templateNameRegex.test(newName)) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        error: 'New template name must be in PascalCase format'\r\n      });\r\n    }\r\n\r\n    const filePath = await TemplateService.duplicateGlobalTemplate(\r\n      globalTemplateName,\r\n      parseInt(churchId),\r\n      newName,\r\n      options\r\n    );\r\n\r\n    res.json({\r\n      success: true,\r\n      message: 'Global template duplicated successfully',\r\n      data: {\r\n        originalTemplate: globalTemplateName,\r\n        newTemplateName: newName,\r\n        churchId,\r\n        filePath\r\n      }\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error duplicating global template:', error);\r\n    \r\n    if (error.message.includes('not found') || error.message.includes('already exists')) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        error: error.message\r\n      });\r\n    }\r\n\r\n    res.status(500).json({\r\n      success: false,\r\n      error: 'Failed to duplicate global template',\r\n      details: process.env.[REDACTED] === 'development' ? error.message : undefined\r\n    });\r\n  }\r\n});\r\n\r\nmodule.exports = router;\r\n"
    },
    "complexity": {
      "totalLines": 732,
      "codeLines": 547,
      "commentLines": 90,
      "commentRatio": 0.141287284144427,
      "averageLineLength": 30.682888540031396
    },
    "lastAnalyzed": "2025-07-28T07:20:00.570Z"
  },
  "contentHash": "aab1e3f47be03faba7aa8881d3141eafa5ce67cb70e30931ff27cbcde32cbfe1",
  "discoveredAt": "2025-07-28T07:20:00.570Z"
}