{
  "id": "37ee64edd22a",
  "originalPath": "/var/www/orthodox-church-mgmt/orthodoxmetrics/prod/server/routes/ocr.js",
  "relativePath": "server/routes/ocr.js",
  "name": "ocr.js",
  "extension": ".js",
  "size": 21358,
  "modified": "2025-07-23T20:00:38.854Z",
  "created": "2025-07-09T00:48:38.482Z",
  "classification": {
    "type": "Server Scripts",
    "category": "Backend > Server",
    "confidence": 7
  },
  "metadata": {
    "fileStats": {
      "lines": 710,
      "characters": 21334,
      "words": 2003
    },
    "classification": {
      "type": "Server Scripts",
      "category": "Backend > Server",
      "confidence": 7
    },
    "dependencies": [
      {
        "type": "npm_package",
        "name": "express",
        "line": 2
      },
      {
        "type": "npm_package",
        "name": "multer",
        "line": 3
      },
      {
        "type": "npm_package",
        "name": "path",
        "line": 4
      },
      {
        "type": "npm_package",
        "name": "fs",
        "line": 5
      },
      {
        "type": "npm_package",
        "name": "express-rate-limit",
        "line": 6
      },
      {
        "type": "npm_package",
        "name": "mysql2/promise",
        "line": 612
      }
    ],
    "security": {
      "findings": [
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 31,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 42,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 43,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 614,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 615,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 616,
          "redacted": true
        }
      ],
      "hasSecurityIssues": true,
      "redactedContent": "// OCR Routes with Barcode Validation\r\nconst express = require('express');\r\nconst multer = require('multer');\r\nconst path = require('path');\r\nconst fs = require('fs');\r\nconst rateLimit = require('express-rate-limit');\r\nconst { validateOCRSession, markSessionAsUsed } = require('../middleware/sessionValidation');\r\nconst { requireAuth } = require('../middleware/auth');\r\nconst { sendOCRReceipt, sendErrorNotification } = require('../utils/emailService');\r\nconst logger = require('../utils/logger');\r\n\r\n// Import church security middleware with fallback\r\nlet requireChurchOCR;\r\ntry {\r\n    const churchSecurity = require('../middleware/churchSecurity');\r\n    requireChurchOCR = churchSecurity.requireChurchOCR;\r\n} catch (error) {\r\n    console.error('Failed to load church security middleware:', error);\r\n    // Fallback middleware that just passes through\r\n    requireChurchOCR = () => (req, res, next) => {\r\n        console.warn('âš ï¸ Church OCR middleware not available, using fallback');\r\n        next();\r\n    };\r\n}\r\n\r\nconst router = express.Router();\r\n\r\n// Configure multer for file uploads\r\nconst storage = multer.diskStorage({\r\n  destination: (req, file, cb) => {\r\n    cb(null, process.env.[REDACTED] || './uploads');\r\n  },\r\n  filename: (req, file, cb) => {\r\n    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);\r\n    cb(null, file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname));\r\n  }\r\n});\r\n\r\nconst upload = multer({\r\n  storage,\r\n  limits: {\r\n    fileSize: parseInt(process.env.[REDACTED]) || 20 * 1024 * 1024, // 20MB\r\n    files: parseInt(process.env.[REDACTED]) || 10\r\n  },\r\n  fileFilter: (req, file, cb) => {\r\n    const allowedTypes = [\r\n      'image/jpeg',\r\n      'image/png',\r\n      'image/tiff',\r\n      'image/gif',\r\n      'image/webp',\r\n      'application/pdf'\r\n    ];\r\n\r\n    if (allowedTypes.includes(file.mimetype)) {\r\n      cb(null, true);\r\n    } else {\r\n      cb(new Error(`Unsupported file type: ${file.mimetype}`), false);\r\n    }\r\n  }\r\n});\r\n\r\n// Rate limiting for session creation\r\nconst sessionCreateLimit = rateLimit({\r\n  windowMs: 15 * 60 * 1000, // 15 minutes\r\n  max: 5, // 5 sessions per IP per 15 minutes\r\n  message: {\r\n    success: false,\r\n    error: 'Too many session creation attempts. Please try again later.'\r\n  }\r\n});\r\n\r\n// Rate limiting for uploads\r\nconst uploadLimit = rateLimit({\r\n  windowMs: 60 * 60 * 1000, // 1 hour\r\n  max: 20, // 20 uploads per IP per hour\r\n  message: {\r\n    success: false,\r\n    error: 'Upload limit exceeded. Please try again later.'\r\n  }\r\n});\r\n\r\n// Middleware to log requests\r\nrouter.use((req, res, next) => {\r\n  if (logger && logger.info) {\r\n    logger.info(`OCR API Request: ${req.method} ${req.path} from ${req.ip}`);\r\n  }\r\n  next();\r\n});\r\n\r\n// Enhanced OCR upload endpoint with session validation\r\nrouter.post('/upload', uploadLimit, upload.array('files', 10), validateOCRSession, requireChurchOCR(), async (req, res) => {\r\n  let uploadedFiles = [];\r\n\r\n  try {\r\n    if (!req.files || req.files.length === 0) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        error: 'No files uploaded',\r\n        code: 'NO_FILES'\r\n      });\r\n    }\r\n\r\n    uploadedFiles = req.files;\r\n    const session = req.ocrSession; // Attached by middleware\r\n    const {\r\n      language = 'auto',\r\n      includeTranslation = false,\r\n      targetLanguage = 'en',\r\n      enhanceImage = true\r\n    } = req.body;\r\n\r\n    const startTime = Date.now();\r\n    const results = [];\r\n\r\n    // Process each file\r\n    for (const file of req.files) {\r\n      try {\r\n        // Here you would integrate with Google Vision API\r\n        // For now, we'll simulate OCR processing\r\n        const result = await processOCRFile(file, {\r\n          language,\r\n          enhanceImage,\r\n          includeTranslation,\r\n          targetLanguage\r\n        });\r\n\r\n        results.push({\r\n          filename: file.originalname,\r\n          success: true,\r\n          text: result.text,\r\n          confidence: result.confidence,\r\n          translatedText: result.translatedText,\r\n          metadata: result.metadata\r\n        });\r\n\r\n      } catch (fileError) {\r\n        results.push({\r\n          filename: file.originalname,\r\n          success: false,\r\n          error: fileError.message\r\n        });\r\n      }\r\n    }\r\n\r\n    const processingTime = Date.now() - startTime;\r\n\r\n    // Aggregate results\r\n    const successfulResults = results.filter(r => r.success);\r\n    const failedResults = results.filter(r => !r.success);\r\n\r\n    const responseData = {\r\n      success: successfulResults.length > 0,\r\n      sessionId: session.session_id,\r\n      results,\r\n      summary: {\r\n        totalFiles: req.files.length,\r\n        successful: successfulResults.length,\r\n        failed: failedResults.length,\r\n        processingTime: processingTime,\r\n        totalExtractedText: successfulResults.map(r => r.text).join('\\n\\n')\r\n      }\r\n    };\r\n\r\n    // Send email receipt if user email is available\r\n    if (session.user_email && successfulResults.length > 0) {\r\n      try {\r\n        await sendOCRReceipt(session, {\r\n          processedImages: successfulResults.length,\r\n          extractedText: responseData.summary.totalExtractedText,\r\n          translatedText: successfulResults.map(r => r.translatedText).filter(Boolean).join('\\n\\n'),\r\n          confidence: successfulResults.reduce((avg, r) => avg + r.confidence, 0) / successfulResults.length\r\n        });\r\n      } catch (emailError) {\r\n        console.error('Failed to send receipt email:', emailError);\r\n        // Don't fail the request if email fails\r\n      }\r\n    }\r\n\r\n    // Mark session as used\r\n    await markSessionAsUsed(req, res, () => { });\r\n\r\n    // Clean up uploaded files\r\n    uploadedFiles.forEach(file => {\r\n      if (fs.existsSync(file.path)) {\r\n        fs.unlinkSync(file.path);\r\n      }\r\n    });\r\n\r\n    res.json(responseData);\r\n\r\n  } catch (error) {\r\n    console.error('OCR processing error:', error);\r\n\r\n    // Send error notification email\r\n    if (req.ocrSession?.user_email) {\r\n      try {\r\n        await sendErrorNotification(req.ocrSession, error);\r\n      } catch (emailError) {\r\n        console.error('Failed to send error notification:', emailError);\r\n      }\r\n    }\r\n\r\n    // Clean up uploaded files\r\n    uploadedFiles.forEach(file => {\r\n      if (fs.existsSync(file.path)) {\r\n        fs.unlinkSync(file.path);\r\n      }\r\n    });\r\n\r\n    res.status(500).json({\r\n      success: false,\r\n      error: 'OCR processing failed',\r\n      details: error.message,\r\n      code: 'PROCESSING_ERROR'\r\n    });\r\n  }\r\n});\r\n\r\n// Simulate OCR processing (replace with actual Google Vision integration)\r\nasync function processOCRFile(file, options) {\r\n  // This is a placeholder - integrate with Google Vision API\r\n  const mockResult = {\r\n    text: `Extracted text from ${file.originalname}\\n\\nSample Orthodox Church Record:\\nName: John Doe\\nDate: 2024-01-15\\nPlace: St. Nicholas Orthodox Church`,\r\n    confidence: 0.85 + Math.random() * 0.1,\r\n    metadata: {\r\n      language: options.language,\r\n      fileSize: file.size,\r\n      mimeType: file.mimetype,\r\n      processedAt: new Date().toISOString()\r\n    }\r\n  };\r\n\r\n  // Simulate translation if requested\r\n  if (options.includeTranslation && options.targetLanguage !== 'auto') {\r\n    mockResult.translatedText = `[Translated to ${options.targetLanguage}] ${mockResult.text}`;\r\n  }\r\n\r\n  // Simulate processing time\r\n  await new Promise(resolve => setTimeout(resolve, 1000 + Math.random() * 2000));\r\n\r\n  return mockResult;\r\n}\r\n\r\n// Russian OCR endpoint\r\nrouter.post('/ocr-ru', upload.single('file'), async (req, res) => {\r\n  try {\r\n    if (!req.file) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        error: 'No file uploaded'\r\n      });\r\n    }\r\n\r\n    const startTime = Date.now();\r\n    const result = await processOCR(req.file.path, 'Russian');\r\n    const processingTime = Date.now() - startTime;\r\n\r\n    // Clean up uploaded file\r\n    fs.unlinkSync(req.file.path);\r\n\r\n    res.json({\r\n      success: true,\r\n      text: result.text,\r\n      confidence: result.confidence,\r\n      metadata: {\r\n        language: 'Russian',\r\n        processingTime: processingTime,\r\n        fileSize: req.file.size,\r\n        imageResolution: req.file.mimetype.startsWith('image/') ? {\r\n          width: null,\r\n          height: null\r\n        } : undefined\r\n      }\r\n    });\r\n  } catch (error) {\r\n    console.error('Russian OCR error:', error);\r\n\r\n    if (req.file && fs.existsSync(req.file.path)) {\r\n      fs.unlinkSync(req.file.path);\r\n    }\r\n\r\n    res.status(500).json({\r\n      success: false,\r\n      error: error.message || 'OCR processing failed'\r\n    });\r\n  }\r\n});\r\n\r\n// Romanian OCR endpoint\r\nrouter.post('/ocr-ro', upload.single('file'), async (req, res) => {\r\n  try {\r\n    if (!req.file) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        error: 'No file uploaded'\r\n      });\r\n    }\r\n\r\n    const startTime = Date.now();\r\n    const result = await processOCR(req.file.path, 'Romanian');\r\n    const processingTime = Date.now() - startTime;\r\n\r\n    // Clean up uploaded file\r\n    fs.unlinkSync(req.file.path);\r\n\r\n    res.json({\r\n      success: true,\r\n      text: result.text,\r\n      confidence: result.confidence,\r\n      metadata: {\r\n        language: 'Romanian',\r\n        processingTime: processingTime,\r\n        fileSize: req.file.size,\r\n        imageResolution: req.file.mimetype.startsWith('image/') ? {\r\n          width: null,\r\n          height: null\r\n        } : undefined\r\n      }\r\n    });\r\n  } catch (error) {\r\n    console.error('Romanian OCR error:', error);\r\n\r\n    if (req.file && fs.existsSync(req.file.path)) {\r\n      fs.unlinkSync(req.file.path);\r\n    }\r\n\r\n    res.status(500).json({\r\n      success: false,\r\n      error: error.message || 'OCR processing failed'\r\n    });\r\n  }\r\n});\r\n\r\n// Greek OCR endpoint\r\nrouter.post('/ocr-gr', upload.single('file'), async (req, res) => {\r\n  try {\r\n    if (!req.file) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        error: 'No file uploaded'\r\n      });\r\n    }\r\n\r\n    const startTime = Date.now();\r\n    const result = await processOCR(req.file.path, 'Greek');\r\n    const processingTime = Date.now() - startTime;\r\n\r\n    // Clean up uploaded file\r\n    fs.unlinkSync(req.file.path);\r\n\r\n    res.json({\r\n      success: true,\r\n      text: result.text,\r\n      confidence: result.confidence,\r\n      metadata: {\r\n        language: 'Greek',\r\n        processingTime: processingTime,\r\n        fileSize: req.file.size,\r\n        imageResolution: req.file.mimetype.startsWith('image/') ? {\r\n          width: null,\r\n          height: null\r\n        } : undefined\r\n      }\r\n    });\r\n  } catch (error) {\r\n    console.error('Greek OCR error:', error);\r\n\r\n    if (req.file && fs.existsSync(req.file.path)) {\r\n      fs.unlinkSync(req.file.path);\r\n    }\r\n\r\n    res.status(500).json({\r\n      success: false,\r\n      error: error.message || 'OCR processing failed'\r\n    });\r\n  }\r\n});\r\n\r\n// General OCR processing endpoint\r\nrouter.post('/ocr', requireAuth, requireChurchOCR(), upload.array('images', 10), async (req, res) => {\r\n  try {\r\n    if (!req.files || req.files.length === 0) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        error: 'No files uploaded'\r\n      });\r\n    }\r\n\r\n    const { language = 'English' } = req.body;\r\n    const results = [];\r\n    const startTime = Date.now();\r\n\r\n    console.log(`ðŸ” Processing ${req.files.length} files for OCR with language: ${language}`);\r\n\r\n    // Process each file\r\n    for (const file of req.files) {\r\n      try {\r\n        console.log(`ðŸ“„ Processing file: ${file.originalname}`);\r\n        const result = await processOCR(file.path, language);\r\n\r\n        results.push({\r\n          filename: file.originalname,\r\n          success: true,\r\n          text: result.text,\r\n          confidence: result.confidence,\r\n          language: language\r\n        });\r\n\r\n        // Clean up file\r\n        fs.unlinkSync(file.path);\r\n      } catch (fileError) {\r\n        console.error(`âŒ Error processing ${file.originalname}:`, fileError);\r\n        results.push({\r\n          filename: file.originalname,\r\n          success: false,\r\n          error: fileError.message\r\n        });\r\n\r\n        // Clean up file even if processing failed\r\n        try {\r\n          fs.unlinkSync(file.path);\r\n        } catch (unlinkError) {\r\n          console.error('Error cleaning up file:', unlinkError);\r\n        }\r\n      }\r\n    }\r\n\r\n    const processingTime = Date.now() - startTime;\r\n    const successfulResults = results.filter(r => r.success);\r\n\r\n    console.log(`âœ… OCR processing complete: ${successfulResults.length}/${results.length} files successful`);\r\n\r\n    res.json({\r\n      success: successfulResults.length > 0,\r\n      results,\r\n      summary: {\r\n        totalFiles: req.files.length,\r\n        successful: successfulResults.length,\r\n        failed: results.length - successfulResults.length,\r\n        processingTime: processingTime,\r\n        language: language,\r\n        extractedText: successfulResults.map(r => r.text).join('\\n\\n')\r\n      }\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('âŒ OCR processing error:', error);\r\n\r\n    // Clean up any uploaded files\r\n    if (req.files) {\r\n      req.files.forEach(file => {\r\n        try {\r\n          fs.unlinkSync(file.path);\r\n        } catch (unlinkError) {\r\n          console.error('Error cleaning up file:', unlinkError);\r\n        }\r\n      });\r\n    }\r\n\r\n    res.status(500).json({\r\n      success: false,\r\n      error: error.message || 'OCR processing failed'\r\n    });\r\n  }\r\n});\r\n\r\n// OCR processing endpoint with session validation (alternative endpoint)\r\nrouter.post('/process', upload.array('images', 10), async (req, res) => {\r\n  try {\r\n    if (!req.files || req.files.length === 0) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        error: 'No files uploaded'\r\n      });\r\n    }\r\n\r\n    const { language = 'English', sessionId } = req.body;\r\n    const results = [];\r\n    const startTime = Date.now();\r\n\r\n    console.log(`ðŸ” Processing ${req.files.length} files for OCR with language: ${language}, sessionId: ${sessionId}`);\r\n\r\n    // Process each file\r\n    for (const file of req.files) {\r\n      try {\r\n        console.log(`ðŸ“„ Processing file: ${file.originalname}`);\r\n        const result = await processOCR(file.path, language);\r\n\r\n        results.push({\r\n          filename: file.originalname,\r\n          success: true,\r\n          text: result.text,\r\n          confidence: result.confidence,\r\n          language: language\r\n        });\r\n\r\n        // Clean up file\r\n        fs.unlinkSync(file.path);\r\n      } catch (fileError) {\r\n        console.error(`âŒ Error processing ${file.originalname}:`, fileError);\r\n        results.push({\r\n          filename: file.originalname,\r\n          success: false,\r\n          error: fileError.message\r\n        });\r\n\r\n        // Clean up file even if processing failed\r\n        try {\r\n          fs.unlinkSync(file.path);\r\n        } catch (unlinkError) {\r\n          console.error('Error cleaning up file:', unlinkError);\r\n        }\r\n      }\r\n    }\r\n\r\n    const processingTime = Date.now() - startTime;\r\n    const successfulResults = results.filter(r => r.success);\r\n\r\n    console.log(`âœ… OCR processing complete: ${successfulResults.length}/${results.length} files successful`);\r\n\r\n    res.json({\r\n      success: successfulResults.length > 0,\r\n      sessionId: sessionId,\r\n      results,\r\n      summary: {\r\n        totalFiles: req.files.length,\r\n        successful: successfulResults.length,\r\n        failed: results.length - successfulResults.length,\r\n        processingTime: processingTime,\r\n        language: language,\r\n        extractedText: successfulResults.map(r => r.text).join('\\n\\n')\r\n      }\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('âŒ OCR processing error:', error);\r\n\r\n    // Clean up any uploaded files\r\n    if (req.files) {\r\n      req.files.forEach(file => {\r\n        try {\r\n          fs.unlinkSync(file.path);\r\n        } catch (unlinkError) {\r\n          console.error('Error cleaning up file:', unlinkError);\r\n        }\r\n      });\r\n    }\r\n\r\n    res.status(500).json({\r\n      success: false,\r\n      error: error.message || 'OCR processing failed'\r\n    });\r\n  }\r\n});\r\n\r\n// Health check endpoint\r\nrouter.get('/ocr-health', (req, res) => {\r\n  res.json({\r\n    success: true,\r\n    message: 'OCR service is running',\r\n    supportedLanguages: ['English', 'Russian', 'Romanian', 'Greek'],\r\n    maxFileSize: '20MB',\r\n    supportedFormats: ['PNG', 'JPG', 'JPEG', 'PDF']\r\n  });\r\n});\r\n\r\n// Enhanced OCR parsing endpoint with preprocessing\r\nrouter.post('/parse-enhanced', upload.single('image'), async (req, res) => {\r\n  const { churchOcrController } = require('../controllers/churchOcrController');\r\n  return churchOcrController.parseEnhanced(req, res);\r\n});\r\n\r\n// Field extraction endpoint\r\nrouter.post('/extract-fields', async (req, res) => {\r\n  const { churchOcrController } = require('../controllers/churchOcrController');\r\n  return churchOcrController.extractFields(req, res);\r\n});\r\n\r\n// Save wizard results endpoint  \r\nrouter.post('/wizard-results', upload.array('images'), async (req, res) => {\r\n  const { churchOcrController } = require('../controllers/churchOcrController');\r\n  return churchOcrController.saveWizardResults(req, res);\r\n});\r\n\r\n// Submit corrected multi-record results endpoint\r\nrouter.post('/submit-corrected-records', async (req, res) => {\r\n  try {\r\n    const { churchId, records, ocrLines, mappingMetadata } = req.body;\r\n\r\n    if (!churchId || !records || !Array.isArray(records)) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        error: 'Missing required fields: churchId, records'\r\n      });\r\n    }\r\n\r\n    // Validate at least one record has required fields\r\n    const validRecords = records.filter(record => \r\n      record.name && record.name.trim() && \r\n      record.death_date && record.death_date.trim()\r\n    );\r\n\r\n    if (validRecords.length === 0) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        error: 'At least one record must have name and death_date'\r\n      });\r\n    }\r\n\r\n    // Connect to the church's database\r\n    const mysql = require('mysql2/promise');\r\n    const connection = await mysql.createConnection({\r\n      host: process.env.[REDACTED],\r\n      user: process.env.[REDACTED],\r\n      password: process.env.[REDACTED],\r\n      database: `church_${churchId}_records`\r\n    });\r\n\r\n    const insertedRecords = [];\r\n\r\n    try {\r\n      await connection.beginTransaction();\r\n\r\n      // Insert each valid record into the database\r\n      for (const record of validRecords) {\r\n        const insertQuery = `\r\n          INSERT INTO funeralrecords (\r\n            death_date, burial_date, name, age, cause_of_death,\r\n            priest_administered, priest_officiated, burial_location,\r\n            created_at, updated_at, data_source, ocr_confidence_avg\r\n          ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW(), 'multi_record_ocr', ?)\r\n        `;\r\n\r\n        // Calculate average confidence for the record\r\n        const confidenceScores = [];\r\n        Object.keys(record).forEach(key => {\r\n          if (key.endsWith('_metadata') && record[key]?.confidence) {\r\n            confidenceScores.push(record[key].confidence);\r\n          }\r\n        });\r\n        const avgConfidence = confidenceScores.length > 0 \r\n          ? confidenceScores.reduce((sum, conf) => sum + conf, 0) / confidenceScores.length \r\n          : 0.5;\r\n\r\n        const values = [\r\n          record.death_date || null,\r\n          record.burial_date || null,\r\n          record.name || null,\r\n          record.age ? parseInt(record.age) : null,\r\n          record.cause_of_death || null,\r\n          record.priest_administered || null,\r\n          record.priest_officiated || null,\r\n          record.burial_location || null,\r\n          Math.round(avgConfidence * 100) / 100\r\n        ];\r\n\r\n        const [result] = await connection.execute(insertQuery, values);\r\n        \r\n        insertedRecords.push({\r\n          id: result.insertId,\r\n          originalId: record.id,\r\n          name: record.name,\r\n          death_date: record.death_date,\r\n          confidence: avgConfidence\r\n        });\r\n      }\r\n\r\n      await connection.commit();\r\n\r\n      // Log the successful processing\r\n      if (logger && logger.info) {\r\n        logger.info(`Multi-record OCR: Inserted ${insertedRecords.length} death records for church ${churchId}`);\r\n      }\r\n\r\n      res.json({\r\n        success: true,\r\n        message: `Successfully processed ${insertedRecords.length} death records`,\r\n        insertedRecords,\r\n        metadata: {\r\n          totalSubmitted: records.length,\r\n          validRecords: validRecords.length,\r\n          insertedCount: insertedRecords.length,\r\n          averageConfidence: insertedRecords.reduce((sum, r) => sum + r.confidence, 0) / insertedRecords.length,\r\n          processingMetadata: mappingMetadata\r\n        }\r\n      });\r\n\r\n    } catch (dbError) {\r\n      await connection.rollback();\r\n      throw dbError;\r\n    } finally {\r\n      await connection.end();\r\n    }\r\n\r\n  } catch (error) {\r\n    if (logger && logger.error) {\r\n      logger.error('Multi-record OCR submission failed:', error);\r\n    }\r\n\r\n    res.status(500).json({\r\n      success: false,\r\n      error: 'Failed to process corrected records',\r\n      details: error.message\r\n    });\r\n  }\r\n});\r\n\r\nmodule.exports = router;\r\n"
    },
    "complexity": {
      "totalLines": 710,
      "codeLines": 564,
      "commentLines": 48,
      "commentRatio": 0.0784313725490196,
      "averageLineLength": 33.529411764705884
    },
    "lastAnalyzed": "2025-07-28T07:20:00.524Z"
  },
  "contentHash": "120fb63c3f88b744253f3b7d5388717586c2d21d560602dedeaeb634dff00750",
  "discoveredAt": "2025-07-28T07:20:00.524Z"
}