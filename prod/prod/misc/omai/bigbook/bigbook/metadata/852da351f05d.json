{
  "id": "852da351f05d",
  "originalPath": "/var/www/orthodox-church-mgmt/orthodoxmetrics/prod/server/routes/admin/services.js",
  "relativePath": "server/routes/admin/services.js",
  "name": "services.js",
  "extension": ".js",
  "size": 28838,
  "modified": "2025-07-22T14:23:13.802Z",
  "created": "2025-07-21T21:37:27.321Z",
  "classification": {
    "type": "Server Scripts",
    "category": "Backend > Server",
    "confidence": 7
  },
  "metadata": {
    "fileStats": {
      "lines": 708,
      "characters": 28772,
      "words": 2482
    },
    "classification": {
      "type": "Server Scripts",
      "category": "Backend > Server",
      "confidence": 7
    },
    "dependencies": [
      {
        "type": "npm_package",
        "name": "express",
        "line": 1
      },
      {
        "type": "npm_package",
        "name": "child_process",
        "line": 2
      },
      {
        "type": "npm_package",
        "name": "util",
        "line": 3
      },
      {
        "type": "npm_package",
        "name": "fs",
        "line": 4
      },
      {
        "type": "npm_package",
        "name": "path",
        "line": 5
      }
    ],
    "security": {
      "findings": [
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 40,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 338,
          "redacted": true
        }
      ],
      "hasSecurityIssues": true,
      "redactedContent": "const express = require('express');\r\nconst { exec, spawn } = require('child_process');\r\nconst { promisify } = require('util');\r\nconst fs = require('fs').promises;\r\nconst path = require('path');\r\nconst { promisePool } = require('../../config/db');\r\nconst { notificationService } = require('../notifications');\r\nconst router = express.Router();\r\n\r\nconst execAsync = promisify(exec);\r\n\r\n// Middleware to check if user is super admin\r\nconst requireSuperAdmin = (req, res, next) => {\r\n    if (!req.session || !req.session.user) {\r\n        return res.status(401).json({\r\n            success: false,\r\n            message: 'Authentication required'\r\n        });\r\n    }\r\n\r\n    if (req.session.user.role !== 'super_admin') {\r\n        return res.status(403).json({\r\n            success: false,\r\n            message: 'Super admin privileges required'\r\n        });\r\n    }\r\n\r\n    next();\r\n};\r\n\r\n// Service definitions and their monitoring commands\r\nconst SERVICES = {\r\n    'backend': {\r\n        name: 'backend',\r\n        displayName: 'Backend Server',\r\n        description: 'Main Node.js application server',\r\n        category: 'core',\r\n        restartable: true,\r\n        checkCommand: 'pm2 jlist',\r\n        startCommand: `cd ${process.env.[REDACTED] || '/var/www/orthodox-church-mgmt/orthodoxmetrics/prod'} && if [ -f \"ecosystem.config.js\" ]; then pm2 start ecosystem.config.js --env production; else pm2 start server/index.js --name orthodox-backend --env-file .env.production --env production; fi`,\r\n        stopCommand: 'pm2 stop orthodox-backend',\r\n        restartCommand: 'pm2 restart orthodox-backend',\r\n        reloadCommand: 'pm2 reload orthodox-backend',\r\n        port: 3001\r\n    },\r\n    'frontend': {\r\n        name: 'frontend',\r\n        displayName: 'Frontend Server',\r\n        description: 'React development server',\r\n        category: 'frontend',\r\n        restartable: true,\r\n        checkCommand: 'pm2 jlist',\r\n        startCommand: 'cd front-end && pm2 start \"npm run dev\" --name orthodox-frontend',\r\n        stopCommand: 'pm2 stop orthodox-frontend',\r\n        restartCommand: 'pm2 restart orthodox-frontend',\r\n        port: 5173\r\n    },\r\n    'database': {\r\n        name: 'database',\r\n        displayName: 'MySQL Database',\r\n        description: 'Main database server',\r\n        category: 'database',\r\n        restartable: false,\r\n        checkCommand: 'systemctl is-active mysql || systemctl is-active mariadb',\r\n        port: 3306\r\n    },\r\n    'nginx': {\r\n        name: 'nginx',\r\n        displayName: 'Nginx Web Server',\r\n        description: 'Reverse proxy and web server',\r\n        category: 'core',\r\n        restartable: true,\r\n        checkCommand: 'systemctl is-active nginx',\r\n        startCommand: 'sudo systemctl start nginx',\r\n        stopCommand: 'sudo systemctl stop nginx',\r\n        restartCommand: 'sudo systemctl restart nginx',\r\n        reloadCommand: 'sudo systemctl reload nginx'\r\n    },\r\n    'pm2': {\r\n        name: 'pm2',\r\n        displayName: 'PM2 Process Manager',\r\n        description: 'Node.js process manager',\r\n        category: 'core',\r\n        restartable: true,\r\n        checkCommand: 'pm2 ping',\r\n        reloadCommand: 'pm2 reload all',\r\n        restartCommand: 'pm2 restart all'\r\n    },\r\n    'ocr-worker': {\r\n        name: 'ocr-worker',\r\n        displayName: 'OCR Worker',\r\n        description: 'Background OCR processing service',\r\n        category: 'worker',\r\n        restartable: true,\r\n        checkCommand: 'pm2 jlist',\r\n        startCommand: 'pm2 start jobs/ocr-worker.js --name ocr-worker',\r\n        stopCommand: 'pm2 stop ocr-worker',\r\n        restartCommand: 'pm2 restart ocr-worker'\r\n    },\r\n    'redis': {\r\n        name: 'redis',\r\n        displayName: 'Redis Cache',\r\n        description: 'In-memory data structure store',\r\n        category: 'database',\r\n        restartable: true,\r\n        checkCommand: 'systemctl is-active redis || systemctl is-active redis-server',\r\n        startCommand: 'sudo systemctl start redis',\r\n        stopCommand: 'sudo systemctl stop redis',\r\n        restartCommand: 'sudo systemctl restart redis',\r\n        port: 6379\r\n    }\r\n};\r\n\r\n// Helper function to parse PM2 process list\r\nconst parsePM2List = (stdout) => {\r\n    try {\r\n        const processes = JSON.parse(stdout);\r\n        const pm2Services = {};\r\n        \r\n        processes.forEach(proc => {\r\n            if (proc.name === 'orthodox-backend' || proc.name === 'backend' || proc.name === 'index') {\r\n                pm2Services.backend = {\r\n                    status: proc.pm2_env.status === 'online' ? 'running' : 'stopped',\r\n                    pid: proc.pid,\r\n                    uptime: proc.pm2_env.pm_uptime ? formatUptime(Date.now() - proc.pm2_env.pm_uptime) : null,\r\n                    cpu: proc.monit?.cpu || 0,\r\n                    memory: proc.monit?.memory ? (proc.monit.memory / 1024 / 1024) : 0,\r\n                    lastRestart: proc.pm2_env.pm_uptime ? new Date(proc.pm2_env.pm_uptime).toISOString() : null\r\n                };\r\n            }\r\n            \r\n            if (proc.name === 'orthodox-frontend' || proc.name === 'frontend') {\r\n                pm2Services.frontend = {\r\n                    status: proc.pm2_env.status === 'online' ? 'running' : 'stopped',\r\n                    pid: proc.pid,\r\n                    uptime: proc.pm2_env.pm_uptime ? formatUptime(Date.now() - proc.pm2_env.pm_uptime) : null,\r\n                    cpu: proc.monit?.cpu || 0,\r\n                    memory: proc.monit?.memory ? (proc.monit.memory / 1024 / 1024) : 0,\r\n                    lastRestart: proc.pm2_env.pm_uptime ? new Date(proc.pm2_env.pm_uptime).toISOString() : null\r\n                };\r\n            }\r\n            \r\n            if (proc.name === 'ocr-worker') {\r\n                pm2Services['ocr-worker'] = {\r\n                    status: proc.pm2_env.status === 'online' ? 'running' : 'stopped',\r\n                    pid: proc.pid,\r\n                    uptime: proc.pm2_env.pm_uptime ? formatUptime(Date.now() - proc.pm2_env.pm_uptime) : null,\r\n                    cpu: proc.monit?.cpu || 0,\r\n                    memory: proc.monit?.memory ? (proc.monit.memory / 1024 / 1024) : 0,\r\n                    lastRestart: proc.pm2_env.pm_uptime ? new Date(proc.pm2_env.pm_uptime).toISOString() : null\r\n                };\r\n            }\r\n        });\r\n        \r\n        return pm2Services;\r\n    } catch (error) {\r\n        console.error('Error parsing PM2 list:', error);\r\n        return {};\r\n    }\r\n};\r\n\r\n// Helper function to format uptime\r\nconst formatUptime = (milliseconds) => {\r\n    const seconds = Math.floor(milliseconds / 1000);\r\n    const minutes = Math.floor(seconds / 60);\r\n    const hours = Math.floor(minutes / 60);\r\n    const days = Math.floor(hours / 24);\r\n    \r\n    if (days > 0) return `${days}d ${hours % 24}h`;\r\n    if (hours > 0) return `${hours}h ${minutes % 60}m`;\r\n    if (minutes > 0) return `${minutes}m ${seconds % 60}s`;\r\n    return `${seconds}s`;\r\n};\r\n\r\n// Helper function to check if port is in use\r\nconst checkPort = async (port) => {\r\n    try {\r\n        const { stdout } = await execAsync(`netstat -tlnp 2>/dev/null | grep :${port} || ss -tlnp 2>/dev/null | grep :${port} || true`);\r\n        return stdout.trim().length > 0;\r\n    } catch (error) {\r\n        return false;\r\n    }\r\n};\r\n\r\n// Helper function to check systemd service status\r\nconst checkSystemdService = async (serviceName) => {\r\n    try {\r\n        const { stdout } = await execAsync(`systemctl is-active ${serviceName} 2>/dev/null || echo inactive`);\r\n        const status = stdout.trim();\r\n        return {\r\n            status: status === 'active' ? 'running' : 'stopped',\r\n            systemdStatus: status\r\n        };\r\n    } catch (error) {\r\n        return { status: 'unknown', systemdStatus: 'unknown' };\r\n    }\r\n};\r\n\r\n// GET /admin/services/status - Get status of all services\r\nrouter.get('/status', requireSuperAdmin, async (req, res) => {\r\n    try {\r\n        console.log('üîç Fetching service status...');\r\n        \r\n        const services = [];\r\n        \r\n        // Get PM2 services\r\n        let pm2Services = {};\r\n        try {\r\n            const { stdout } = await execAsync('pm2 jlist 2>/dev/null || echo \"[]\"');\r\n            pm2Services = parsePM2List(stdout);\r\n        } catch (error) {\r\n            console.warn('PM2 not available or error getting PM2 status:', error.message);\r\n        }\r\n        \r\n        // Check each service\r\n        for (const [serviceKey, serviceConfig] of Object.entries(SERVICES)) {\r\n            let serviceStatus = {\r\n                name: serviceConfig.name,\r\n                displayName: serviceConfig.displayName,\r\n                description: serviceConfig.description,\r\n                category: serviceConfig.category,\r\n                restartable: serviceConfig.restartable,\r\n                status: 'unknown',\r\n                port: serviceConfig.port\r\n            };\r\n            \r\n            try {\r\n                if (serviceConfig.category === 'core' && serviceKey === 'pm2') {\r\n                    // Check PM2 itself\r\n                    try {\r\n                        await execAsync('pm2 ping 2>/dev/null');\r\n                        serviceStatus.status = 'running';\r\n                    } catch {\r\n                        serviceStatus.status = 'stopped';\r\n                    }\r\n                } else if (pm2Services[serviceKey]) {\r\n                    // Use PM2 data if available\r\n                    serviceStatus = { ...serviceStatus, ...pm2Services[serviceKey] };\r\n                } else if (serviceConfig.checkCommand.includes('systemctl')) {\r\n                    // Check systemd services\r\n                    const serviceName = serviceKey === 'database' ? 'mysql' : serviceKey;\r\n                    const systemdResult = await checkSystemdService(serviceName);\r\n                    serviceStatus.status = systemdResult.status;\r\n                } else if (serviceConfig.port) {\r\n                    // Check if port is in use\r\n                    const portInUse = await checkPort(serviceConfig.port);\r\n                    serviceStatus.status = portInUse ? 'running' : 'stopped';\r\n                }\r\n                \r\n                // Additional database check\r\n                if (serviceKey === 'database') {\r\n                    try {\r\n                        await promisePool.query('SELECT 1');\r\n                        serviceStatus.status = 'running';\r\n                    } catch (error) {\r\n                        serviceStatus.status = 'error';\r\n                    }\r\n                }\r\n                \r\n            } catch (error) {\r\n                console.warn(`Error checking service ${serviceKey}:`, error.message);\r\n                serviceStatus.status = 'error';\r\n            }\r\n            \r\n            services.push(serviceStatus);\r\n        }\r\n        \r\n        console.log(`‚úÖ Service status check complete: ${services.length} services checked`);\r\n        res.json({ services });\r\n        \r\n    } catch (error) {\r\n        console.error('‚ùå Error fetching service status:', error);\r\n        res.status(500).json({\r\n            success: false,\r\n            message: 'Failed to fetch service status',\r\n            error: error.message\r\n        });\r\n    }\r\n});\r\n\r\n// GET /admin/services/health - Get overall system health\r\nrouter.get('/health', requireSuperAdmin, async (req, res) => {\r\n    try {\r\n        console.log('üè• Checking system health...');\r\n        \r\n        // Get service statuses (reuse the status endpoint logic)\r\n        const statusResponse = await new Promise((resolve) => {\r\n            const mockReq = { session: req.session };\r\n            const mockRes = {\r\n                json: (data) => resolve(data)\r\n            };\r\n            \r\n            // Call the status endpoint internally\r\n            router.stack[0].route.stack[0].handle(mockReq, mockRes, () => {});\r\n        });\r\n        \r\n        const services = statusResponse.services || [];\r\n        const runningServices = services.filter(s => s.status === 'running').length;\r\n        const totalServices = services.length;\r\n        const criticalServices = services\r\n            .filter(s => s.category === 'core' && s.status !== 'running')\r\n            .map(s => s.name);\r\n        \r\n        let overall = 'healthy';\r\n        if (criticalServices.length > 0) {\r\n            overall = 'critical';\r\n        } else if (runningServices < totalServices * 0.8) {\r\n            overall = 'warning';\r\n        }\r\n        \r\n        const health = {\r\n            overall,\r\n            servicesUp: runningServices,\r\n            servicesTotal: totalServices,\r\n            lastUpdate: new Date().toISOString(),\r\n            criticalServices\r\n        };\r\n        \r\n        console.log(`‚úÖ System health: ${overall} (${runningServices}/${totalServices} services up)`);\r\n        res.json(health);\r\n        \r\n    } catch (error) {\r\n        console.error('‚ùå Error checking system health:', error);\r\n        res.status(500).json({\r\n            success: false,\r\n            message: 'Failed to check system health',\r\n            error: error.message\r\n        });\r\n    }\r\n});\r\n\r\n// POST /admin/services/frontend/rebuild - Trigger frontend rebuild (MUST be before generic route)\r\nrouter.post('/frontend/rebuild', requireSuperAdmin, async (req, res) => {\r\n    try {\r\n        console.log('üî® Starting frontend rebuild with proper build flags...');\r\n        \r\n        // Use configurable paths for frontend build\r\n        const frontendPath = process.env.[REDACTED] || '/var/www/orthodox-church-mgmt/orthodoxmetrics/prod/front-end';\r\n        const rebuildCommand = `cd ${frontendPath} && NODE_OPTIONS=\"--max-old-space-size=4096\" npm run build`;\r\n        \r\n        console.log('Executing build command:', rebuildCommand);\r\n        \r\n        // Execute build and capture output\r\n        const buildProcess = exec(rebuildCommand, { timeout: 300000 }, async (error, stdout, stderr) => {\r\n            const userId = req.session.user?.id;\r\n            \r\n            if (error) {\r\n                console.error('üö® FRONTEND BUILD FAILED üö®');\r\n                console.error('‚ùå Build process failed:', error);\r\n                console.error('Error details:', error.message);\r\n                await logServiceAction('frontend', 'rebuild', false, req.session.user?.email, error.message);\r\n                \r\n                // Send system notification for build failure\r\n                if (userId) {\r\n                    try {\r\n                        await notificationService.createNotification(\r\n                            userId,\r\n                            'system_alert',\r\n                            'Frontend Build Failed',\r\n                            `The frontend build process failed: ${error.message.slice(0, 200)}${error.message.length > 200 ? '...' : ''}`,\r\n                            {\r\n                                priority: 'high',\r\n                                icon: 'üö®',\r\n                                actionUrl: '/admin/settings',\r\n                                actionText: 'View Settings',\r\n                                data: {\r\n                                    buildCommand: rebuildCommand,\r\n                                    errorDetails: error.message,\r\n                                    timestamp: new Date().toISOString()\r\n                                }\r\n                            }\r\n                        );\r\n                        console.log('üì¢ Build failure notification sent to user');\r\n                    } catch (notifError) {\r\n                        console.error('Failed to send build failure notification:', notifError);\r\n                    }\r\n                }\r\n            } else {\r\n                console.log('üéâ FRONTEND BUILD COMPLETED SUCCESSFULLY üéâ');\r\n                console.log('‚úÖ Build process completed successfully');\r\n                console.log('üìä Build output summary:', stdout.slice(-500)); // Last 500 chars\r\n                console.log('üìÅ Frontend assets ready at: /front-end/dist/');\r\n                await logServiceAction('frontend', 'rebuild', true, req.session.user?.email, 'Build completed successfully');\r\n                \r\n                // Send system notification for build success\r\n                if (userId) {\r\n                    try {\r\n                        await notificationService.createNotification(\r\n                            userId,\r\n                            'system_alert',\r\n                            'Frontend Build Completed',\r\n                            'The frontend has been successfully rebuilt and is now live with your latest changes.',\r\n                            {\r\n                                priority: 'normal',\r\n                                icon: 'üéâ',\r\n                                actionUrl: '/',\r\n                                actionText: 'View Site',\r\n                                data: {\r\n                                    buildCommand: rebuildCommand,\r\n                                    buildSummary: stdout.slice(-200),\r\n                                    timestamp: new Date().toISOString()\r\n                                }\r\n                            }\r\n                        );\r\n                        console.log('üì¢ Build success notification sent to user');\r\n                    } catch (notifError) {\r\n                        console.error('Failed to send build success notification:', notifError);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        \r\n        // Log the action immediately\r\n        await logServiceAction('frontend', 'rebuild', true, req.session.user.email, 'Build started with NODE_OPTIONS=\"--max-old-space-size=4096\"');\r\n        \r\n        // Send system notification for build start\r\n        const userId = req.session.user?.id;\r\n        if (userId) {\r\n            try {\r\n                await notificationService.createNotification(\r\n                    userId,\r\n                    'system_alert',\r\n                    'Frontend Build Started',\r\n                    'The frontend rebuild process has been initiated. You will receive another notification when it completes.',\r\n                    {\r\n                        priority: 'normal',\r\n                        icon: 'üîß',\r\n                        actionUrl: '/admin/settings',\r\n                        actionText: 'View Progress',\r\n                        data: {\r\n                            buildCommand: rebuildCommand,\r\n                            timestamp: new Date().toISOString()\r\n                        }\r\n                    }\r\n                );\r\n                console.log('üì¢ Build start notification sent to user');\r\n            } catch (notifError) {\r\n                console.error('Failed to send build start notification:', notifError);\r\n            }\r\n        }\r\n        \r\n        console.log('‚úÖ Frontend rebuild started with memory optimization');\r\n        res.json({\r\n            success: true,\r\n            message: 'Frontend rebuild started with NODE_OPTIONS=\"--max-old-space-size=4096\"',\r\n            buildId: Date.now(),\r\n            command: 'NODE_OPTIONS=\"--max-old-space-size=4096\" npm run build'\r\n        });\r\n        \r\n    } catch (error) {\r\n        console.error('‚ùå Error starting frontend rebuild:', error);\r\n        \r\n        await logServiceAction('frontend', 'rebuild', false, req.session.user.email, error.message);\r\n        \r\n        res.status(500).json({\r\n            success: false,\r\n            message: 'Failed to start frontend rebuild',\r\n            error: error.message\r\n        });\r\n    }\r\n});\r\n\r\n// POST /admin/services/:service/:action - Control a service\r\nrouter.post('/:service/:action', requireSuperAdmin, async (req, res) => {\r\n    const { service: serviceName, action } = req.params;\r\n    \r\n    try {\r\n        console.log(`üéÆ Service control: ${action} ${serviceName}`);\r\n        \r\n        const serviceConfig = SERVICES[serviceName];\r\n        if (!serviceConfig) {\r\n            return res.status(404).json({\r\n                success: false,\r\n                message: `Service ${serviceName} not found`\r\n            });\r\n        }\r\n        \r\n        if (!serviceConfig.restartable) {\r\n            return res.status(400).json({\r\n                success: false,\r\n                message: `Service ${serviceName} is not controllable via this interface`\r\n            });\r\n        }\r\n        \r\n        let command;\r\n        switch (action) {\r\n            case 'start':\r\n                command = serviceConfig.startCommand;\r\n                break;\r\n            case 'stop':\r\n                command = serviceConfig.stopCommand;\r\n                break;\r\n            case 'restart':\r\n                command = serviceConfig.restartCommand;\r\n                break;\r\n            case 'reload':\r\n                command = serviceConfig.reloadCommand;\r\n                break;\r\n            default:\r\n                return res.status(400).json({\r\n                    success: false,\r\n                    message: `Invalid action: ${action}`\r\n                });\r\n        }\r\n        \r\n        if (!command) {\r\n            return res.status(400).json({\r\n                success: false,\r\n                message: `Action ${action} not supported for service ${serviceName}`\r\n            });\r\n        }\r\n        \r\n        // Execute the command\r\n        console.log(`Executing: ${command}`);\r\n        const { stdout, stderr } = await execAsync(command, { timeout: 30000 });\r\n        \r\n        // Log the action\r\n        await logServiceAction(serviceName, action, true, req.session.user.email);\r\n        \r\n        console.log(`‚úÖ Successfully executed ${action} on ${serviceName}`);\r\n        res.json({\r\n            success: true,\r\n            message: `Successfully ${action}ed ${serviceName}`,\r\n            output: stdout,\r\n            error: stderr\r\n        });\r\n        \r\n    } catch (error) {\r\n        console.error(`‚ùå Error ${action}ing ${serviceName}:`, error);\r\n        \r\n        // Log the failed action\r\n        await logServiceAction(serviceName, action, false, req.session.user.email, error.message);\r\n        \r\n        res.status(500).json({\r\n            success: false,\r\n            message: `Failed to ${action} ${serviceName}`,\r\n            error: error.message\r\n        });\r\n    }\r\n});\r\n\r\n// GET /admin/services/actions/recent - Get recent service actions\r\nrouter.get('/actions/recent', requireSuperAdmin, async (req, res) => {\r\n    try {\r\n        const [actions] = await promisePool.query(`\r\n            SELECT service, action, timestamp, success, message, user_email\r\n            FROM service_actions \r\n            ORDER BY timestamp DESC \r\n            LIMIT 50\r\n        `);\r\n        \r\n        res.json({ actions });\r\n        \r\n    } catch (error) {\r\n        console.error('Error fetching recent actions:', error);\r\n        res.json({ actions: [] }); // Return empty array if table doesn't exist\r\n    }\r\n});\r\n\r\n// Helper function to log service actions\r\nconst logServiceAction = async (service, action, success, userEmail, message = null) => {\r\n    try {\r\n        await promisePool.query(`\r\n            INSERT INTO service_actions (service, action, timestamp, success, message, user_email)\r\n            VALUES (?, ?, NOW(), ?, ?, ?)\r\n        `, [service, action, success, message, userEmail]);\r\n    } catch (error) {\r\n        console.warn('Failed to log service action:', error.message);\r\n        // Continue execution even if logging fails\r\n    }\r\n};\r\n\r\n// Create service_actions table if it doesn't exist\r\nconst initializeServiceActionsTable = async () => {\r\n    try {\r\n        await promisePool.query(`\r\n            CREATE TABLE IF NOT EXISTS service_actions (\r\n                id INT AUTO_INCREMENT PRIMARY KEY,\r\n                service VARCHAR(50) NOT NULL,\r\n                action VARCHAR(20) NOT NULL,\r\n                timestamp DATETIME NOT NULL,\r\n                success BOOLEAN NOT NULL,\r\n                message TEXT NULL,\r\n                user_email VARCHAR(255) NULL,\r\n                INDEX idx_timestamp (timestamp),\r\n                INDEX idx_service (service)\r\n            )\r\n        `);\r\n        console.log('‚úÖ Service actions table initialized');\r\n    } catch (error) {\r\n        console.warn('‚ö†Ô∏è Failed to initialize service actions table:', error.message);\r\n    }\r\n};\r\n\r\n// Initialize the table when the module loads\r\ninitializeServiceActionsTable();\r\n\r\n// GET /admin/services/:service/logs - Get service logs\r\nrouter.get('/:service/logs', requireSuperAdmin, async (req, res) => {\r\n    const { service: serviceName } = req.params;\r\n    const { lines = 100 } = req.query;\r\n    \r\n    try {\r\n        console.log(`üìã Fetching logs for service: ${serviceName}`);\r\n        \r\n        let command;\r\n        if (serviceName === 'pm2') {\r\n            // Get logs for all PM2 processes\r\n            command = `pm2 logs --lines ${lines} --nostream`;\r\n        } else if (serviceName === 'nginx') {\r\n            // Get nginx error logs\r\n            command = `tail -n ${lines} /var/log/nginx/error.log 2>/dev/null || echo \"No nginx logs found\"`;\r\n        } else if (serviceName === 'database' || serviceName === 'mysql') {\r\n            // Get MySQL/MariaDB logs\r\n            command = `tail -n ${lines} /var/log/mysql/error.log 2>/dev/null || tail -n ${lines} /var/log/mariadb/mariadb.log 2>/dev/null || echo \"No database logs found\"`;\r\n        } else {\r\n            // For PM2 managed services, get specific process logs\r\n            const serviceConfig = SERVICES[serviceName];\r\n            if (serviceConfig && serviceConfig.category !== 'database') {\r\n                command = `pm2 logs ${serviceName === 'backend' ? 'orthodox-backend' : serviceName} --lines ${lines} --nostream`;\r\n            } else {\r\n                return res.status(400).json({\r\n                    success: false,\r\n                    message: `Log viewing not supported for service: ${serviceName}`\r\n                });\r\n            }\r\n        }\r\n        \r\n        const { stdout, stderr } = await execAsync(command, { timeout: 30000 });\r\n        \r\n        // Process the logs to make them more readable\r\n        let logs = stdout || stderr || 'No logs available';\r\n        \r\n        // Split into lines and add timestamps if missing\r\n        const logLines = logs.split('\\n')\r\n            .filter(line => line.trim().length > 0)\r\n            .slice(-lines) // Ensure we don't exceed requested lines\r\n            .map(line => {\r\n                // If line doesn't start with a timestamp, add one\r\n                if (!/^\\d{4}-\\d{2}-\\d{2}/.test(line) && !/^\\w{3}\\s+\\d{2}/.test(line)) {\r\n                    return `${new Date().toISOString()} | ${line}`;\r\n                }\r\n                return line;\r\n            });\r\n        \r\n        res.json({\r\n            success: true,\r\n            service: serviceName,\r\n            logs: logLines,\r\n            totalLines: logLines.length,\r\n            command: command\r\n        });\r\n        \r\n    } catch (error) {\r\n        console.error(`‚ùå Error fetching logs for ${serviceName}:`, error);\r\n        res.status(500).json({\r\n            success: false,\r\n            message: `Failed to fetch logs for ${serviceName}`,\r\n            error: error.message\r\n        });\r\n    }\r\n});\r\n\r\n// GET /admin/services/pm2/processes - Get detailed PM2 process info\r\nrouter.get('/pm2/processes', requireSuperAdmin, async (req, res) => {\r\n    try {\r\n        console.log('üìä Fetching detailed PM2 process information...');\r\n        \r\n        const { stdout } = await execAsync('pm2 jlist');\r\n        const processes = JSON.parse(stdout);\r\n        \r\n        const detailedProcesses = processes.map(proc => ({\r\n            name: proc.name,\r\n            pid: proc.pid,\r\n            status: proc.pm2_env.status,\r\n            cpu: proc.monit?.cpu || 0,\r\n            memory: proc.monit?.memory ? Math.round(proc.monit.memory / 1024 / 1024) : 0,\r\n            uptime: proc.pm2_env.pm_uptime ? formatUptime(Date.now() - proc.pm2_env.pm_uptime) : 'N/A',\r\n            restarts: proc.pm2_env.restart_time || 0,\r\n            script: proc.pm2_env.pm_exec_path,\r\n            args: proc.pm2_env.args || [],\r\n            env: {\r\n                NODE_ENV: proc.pm2_env.NODE_ENV,\r\n                PORT: proc.pm2_env.PORT\r\n            },\r\n            logs: {\r\n                out: proc.pm2_env.pm_out_log_path,\r\n                error: proc.pm2_env.pm_err_log_path\r\n            }\r\n        }));\r\n        \r\n        res.json({\r\n            success: true,\r\n            processes: detailedProcesses,\r\n            totalProcesses: processes.length\r\n        });\r\n        \r\n    } catch (error) {\r\n        console.error('‚ùå Error fetching PM2 processes:', error);\r\n        res.status(500).json({\r\n            success: false,\r\n            message: 'Failed to fetch PM2 process information',\r\n            error: error.message\r\n        });\r\n    }\r\n});\r\n\r\nmodule.exports = router; "
    },
    "complexity": {
      "totalLines": 708,
      "codeLines": 589,
      "commentLines": 42,
      "commentRatio": 0.06656101426307448,
      "averageLineLength": 43.562599049128366
    },
    "lastAnalyzed": "2025-07-28T07:20:00.371Z"
  },
  "contentHash": "ec0e97c1ce825230e1be3f9d993c729ec745228a2a80413771e24ddfd1bf481a",
  "discoveredAt": "2025-07-28T07:20:00.371Z"
}