{
  "id": "e23b44668db1",
  "originalPath": "/var/www/orthodox-church-mgmt/orthodoxmetrics/prod/server/utils/testDeployedSite.js",
  "relativePath": "server/utils/testDeployedSite.js",
  "name": "testDeployedSite.js",
  "extension": ".js",
  "size": 14876,
  "modified": "2025-07-04T23:08:09.000Z",
  "created": "2025-07-09T00:48:38.534Z",
  "classification": {
    "type": "Testing Scripts",
    "category": "DevOps > Test",
    "confidence": 3
  },
  "metadata": {
    "fileStats": {
      "lines": 509,
      "characters": 14759,
      "words": 1368
    },
    "classification": {
      "type": "Testing Scripts",
      "category": "DevOps > Test",
      "confidence": 3
    },
    "dependencies": [
      {
        "type": "npm_package",
        "name": "puppeteer",
        "line": 4
      }
    ],
    "security": {
      "findings": [
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 12,
          "redacted": true
        }
      ],
      "hasSecurityIssues": true,
      "redactedContent": "// Site Testing Utility using Puppeteer\r\n// Performs automated testing on deployed church sites\r\n\r\nconst puppeteer = require('puppeteer');\r\nconst logger = require('./logger');\r\n\r\n// Test configuration\r\nconst TEST_CONFIG = {\r\n  timeout: 30000,\r\n  viewport: { width: 1366, height: 768 },\r\n  userAgent: 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',\r\n  headless: process.env.[REDACTED] === 'production'\r\n};\r\n\r\n// Language-specific test expectations\r\nconst LANGUAGE_TESTS = {\r\n  en: {\r\n    expectedTexts: ['Orthodox Church', 'Login', 'Calendar', 'Records'],\r\n    titlePattern: /orthodox.*church/i,\r\n    loginButtonText: 'Login'\r\n  },\r\n  gr: {\r\n    expectedTexts: ['Ορθόδοξη Εκκλησία', 'Σύνδεση', 'Ημερολόγιο', 'Αρχεία'],\r\n    titlePattern: /ορθόδοξ.*εκκλησ/i,\r\n    loginButtonText: 'Σύνδεση'\r\n  },\r\n  ru: {\r\n    expectedTexts: ['Православная Церковь', 'Вход', 'Календарь', 'Записи'],\r\n    titlePattern: /православ.*церк/i,\r\n    loginButtonText: 'Вход'\r\n  },\r\n  ro: {\r\n    expectedTexts: ['Biserica Ortodoxă', 'Autentificare', 'Calendar', 'Înregistrări'],\r\n    titlePattern: /biseric.*ortodox/i,\r\n    loginButtonText: 'Autentificare'\r\n  }\r\n};\r\n\r\n// Test deployed site\r\nasync function testDeployedSite({ siteUrl, language }) {\r\n  let browser = null;\r\n  \r\n  try {\r\n    logger.info(`Starting automated testing for ${siteUrl} in ${language}`);\r\n    \r\n    // Launch browser\r\n    browser = await puppeteer.launch({\r\n      headless: TEST_CONFIG.headless,\r\n      args: [\r\n        '--no-sandbox',\r\n        '--disable-setuid-sandbox',\r\n        '--disable-dev-shm-usage',\r\n        '--disable-accelerated-2d-canvas',\r\n        '--no-first-run',\r\n        '--no-zygote',\r\n        '--disable-gpu'\r\n      ]\r\n    });\r\n\r\n    const page = await browser.newPage();\r\n    \r\n    // Set viewport and user agent\r\n    await page.setViewport(TEST_CONFIG.viewport);\r\n    await page.setUserAgent(TEST_CONFIG.userAgent);\r\n\r\n    // Enable request interception for monitoring\r\n    await page.setRequestInterception(true);\r\n    const requests = [];\r\n    const responses = [];\r\n    \r\n    page.on('request', request => {\r\n      requests.push({\r\n        url: request.url(),\r\n        method: request.method(),\r\n        resourceType: request.resourceType()\r\n      });\r\n      request.continue();\r\n    });\r\n\r\n    page.on('response', response => {\r\n      responses.push({\r\n        url: response.url(),\r\n        status: response.status(),\r\n        ok: response.ok()\r\n      });\r\n    });\r\n\r\n    // Capture console logs and errors\r\n    const consoleLogs = [];\r\n    const errors = [];\r\n    \r\n    page.on('console', msg => {\r\n      consoleLogs.push({\r\n        type: msg.type(),\r\n        text: msg.text()\r\n      });\r\n    });\r\n\r\n    page.on('pageerror', error => {\r\n      errors.push(error.message);\r\n    });\r\n\r\n    // Start tests\r\n    const testResults = {\r\n      siteUrl,\r\n      language,\r\n      startTime: new Date().toISOString(),\r\n      tests: {}\r\n    };\r\n\r\n    // Test 1: Basic page load\r\n    testResults.tests.pageLoad = await testPageLoad(page, siteUrl);\r\n\r\n    // Test 2: Language-specific content\r\n    testResults.tests.languageContent = await testLanguageContent(page, language);\r\n\r\n    // Test 3: Navigation elements\r\n    testResults.tests.navigation = await testNavigation(page, language);\r\n\r\n    // Test 4: Login functionality\r\n    testResults.tests.loginForm = await testLoginForm(page, language);\r\n\r\n    // Test 5: Mobile responsiveness\r\n    testResults.tests.mobile = await testMobileResponsiveness(page);\r\n\r\n    // Test 6: Performance metrics\r\n    testResults.tests.performance = await testPerformance(page);\r\n\r\n    // Test 7: Accessibility\r\n    testResults.tests.accessibility = await testAccessibility(page);\r\n\r\n    // Collect final metrics\r\n    testResults.endTime = new Date().toISOString();\r\n    testResults.duration = Date.now() - new Date(testResults.startTime).getTime();\r\n    testResults.requests = requests.length;\r\n    testResults.errors = errors;\r\n    testResults.consoleLogs = consoleLogs.filter(log => log.type === 'error');\r\n    testResults.httpErrors = responses.filter(r => !r.ok).length;\r\n\r\n    // Calculate overall success\r\n    const passedTests = Object.values(testResults.tests).filter(test => test.passed).length;\r\n    const totalTests = Object.keys(testResults.tests).length;\r\n    testResults.success = passedTests === totalTests && errors.length === 0;\r\n    testResults.score = Math.round((passedTests / totalTests) * 100);\r\n\r\n    logger.info(`Site testing completed: ${testResults.score}% passed (${passedTests}/${totalTests})`);\r\n\r\n    return testResults;\r\n\r\n  } catch (error) {\r\n    logger.error(`Site testing failed for ${siteUrl}:`, error);\r\n    return {\r\n      success: false,\r\n      error: error.message,\r\n      siteUrl,\r\n      language\r\n    };\r\n  } finally {\r\n    if (browser) {\r\n      await browser.close();\r\n    }\r\n  }\r\n}\r\n\r\n// Test basic page load\r\nasync function testPageLoad(page, siteUrl) {\r\n  try {\r\n    const startTime = Date.now();\r\n    \r\n    const response = await page.goto(siteUrl, {\r\n      waitUntil: 'networkidle2',\r\n      timeout: TEST_CONFIG.timeout\r\n    });\r\n\r\n    const loadTime = Date.now() - startTime;\r\n    \r\n    return {\r\n      passed: response.ok(),\r\n      loadTime,\r\n      status: response.status(),\r\n      details: {\r\n        statusOk: response.ok(),\r\n        fastLoad: loadTime < 5000,\r\n        message: response.ok() ? 'Page loaded successfully' : `Failed with status ${response.status()}`\r\n      }\r\n    };\r\n  } catch (error) {\r\n    return {\r\n      passed: false,\r\n      error: error.message,\r\n      details: { message: 'Page failed to load' }\r\n    };\r\n  }\r\n}\r\n\r\n// Test language-specific content\r\nasync function testLanguageContent(page, language) {\r\n  try {\r\n    const langConfig = LANGUAGE_TESTS[language] || LANGUAGE_TESTS.en;\r\n    const results = { passed: true, details: {} };\r\n\r\n    // Check page title\r\n    const title = await page.title();\r\n    results.details.titleTest = {\r\n      title,\r\n      matches: langConfig.titlePattern.test(title)\r\n    };\r\n\r\n    // Check for expected language texts\r\n    const pageText = await page.evaluate(() => document.body.innerText);\r\n    results.details.textTests = [];\r\n\r\n    for (const expectedText of langConfig.expectedTexts) {\r\n      const found = pageText.includes(expectedText);\r\n      results.details.textTests.push({\r\n        text: expectedText,\r\n        found\r\n      });\r\n      if (!found) results.passed = false;\r\n    }\r\n\r\n    // Check HTML lang attribute\r\n    const htmlLang = await page.evaluate(() => document.documentElement.lang);\r\n    results.details.htmlLang = {\r\n      expected: language,\r\n      actual: htmlLang,\r\n      matches: htmlLang === language\r\n    };\r\n\r\n    if (!results.details.htmlLang.matches) {\r\n      results.passed = false;\r\n    }\r\n\r\n    return results;\r\n  } catch (error) {\r\n    return {\r\n      passed: false,\r\n      error: error.message\r\n    };\r\n  }\r\n}\r\n\r\n// Test navigation elements\r\nasync function testNavigation(page, language) {\r\n  try {\r\n    const results = { passed: true, details: {} };\r\n\r\n    // Check for navigation menu\r\n    const navExists = await page.$('nav') !== null;\r\n    results.details.navigationMenu = navExists;\r\n\r\n    // Check for main navigation links\r\n    const expectedLinks = ['login', 'calendar', 'records'];\r\n    const links = await page.$$eval('a', anchors => \r\n      anchors.map(a => ({ href: a.href, text: a.textContent.trim() }))\r\n    );\r\n\r\n    results.details.navigationLinks = {\r\n      total: links.length,\r\n      hasLoginLink: links.some(link => link.href.includes('/login')),\r\n      hasCalendarLink: links.some(link => link.href.includes('/calendar')),\r\n      hasRecordsLink: links.some(link => \r\n        link.href.includes('/records') || \r\n        link.href.includes('/baptism') || \r\n        link.href.includes('/marriage')\r\n      )\r\n    };\r\n\r\n    // Check if critical links exist\r\n    if (!results.details.navigationLinks.hasLoginLink || \r\n        !results.details.navigationLinks.hasCalendarLink) {\r\n      results.passed = false;\r\n    }\r\n\r\n    return results;\r\n  } catch (error) {\r\n    return {\r\n      passed: false,\r\n      error: error.message\r\n    };\r\n  }\r\n}\r\n\r\n// Test login form\r\nasync function testLoginForm(page, language) {\r\n  try {\r\n    const results = { passed: true, details: {} };\r\n\r\n    // Navigate to login page\r\n    const loginLink = await page.$('a[href*=\"/login\"]');\r\n    if (!loginLink) {\r\n      results.details.loginLinkFound = false;\r\n      results.passed = false;\r\n      return results;\r\n    }\r\n\r\n    await loginLink.click();\r\n    await page.waitForSelector('form', { timeout: 5000 });\r\n\r\n    // Check for login form elements\r\n    const emailInput = await page.$('input[type=\"email\"], input[name=\"email\"], input[name=\"username\"]');\r\n    const passwordInput = await page.$('input[type=\"password\"]');\r\n    const submitButton = await page.$('button[type=\"submit\"], input[type=\"submit\"]');\r\n\r\n    results.details.formElements = {\r\n      emailInput: !!emailInput,\r\n      passwordInput: !!passwordInput,\r\n      submitButton: !!submitButton\r\n    };\r\n\r\n    // Test form validation\r\n    if (emailInput && passwordInput && submitButton) {\r\n      await emailInput.click();\r\n      await passwordInput.click();\r\n      await submitButton.click();\r\n      \r\n      // Wait a moment for validation messages\r\n      await page.waitForTimeout(1000);\r\n      \r\n      const validationMessages = await page.$$eval('.invalid-feedback, .error, .form-error', \r\n        elements => elements.map(el => el.textContent)\r\n      );\r\n      \r\n      results.details.validationWorks = validationMessages.length > 0;\r\n    } else {\r\n      results.passed = false;\r\n    }\r\n\r\n    return results;\r\n  } catch (error) {\r\n    return {\r\n      passed: false,\r\n      error: error.message\r\n    };\r\n  }\r\n}\r\n\r\n// Test mobile responsiveness\r\nasync function testMobileResponsiveness(page) {\r\n  try {\r\n    const results = { passed: true, details: {} };\r\n\r\n    // Test mobile viewport\r\n    await page.setViewport({ width: 375, height: 667 }); // iPhone SE\r\n    await page.waitForTimeout(1000);\r\n\r\n    // Check if navigation collapses on mobile\r\n    const mobileNavExists = await page.$('.navbar-toggler, .mobile-menu, .hamburger') !== null;\r\n    results.details.mobileNavigation = mobileNavExists;\r\n\r\n    // Check for responsive meta tag\r\n    const viewportMeta = await page.evaluate(() => {\r\n      const meta = document.querySelector('meta[name=\"viewport\"]');\r\n      return meta ? meta.content : null;\r\n    });\r\n\r\n    results.details.viewportMeta = {\r\n      exists: !!viewportMeta,\r\n      content: viewportMeta,\r\n      responsive: viewportMeta && viewportMeta.includes('width=device-width')\r\n    };\r\n\r\n    // Reset to desktop viewport\r\n    await page.setViewport(TEST_CONFIG.viewport);\r\n\r\n    return results;\r\n  } catch (error) {\r\n    return {\r\n      passed: false,\r\n      error: error.message\r\n    };\r\n  }\r\n}\r\n\r\n// Test performance metrics\r\nasync function testPerformance(page) {\r\n  try {\r\n    const metrics = await page.metrics();\r\n    const performanceEntries = await page.evaluate(() => {\r\n      return JSON.stringify(performance.getEntriesByType('navigation'));\r\n    });\r\n\r\n    const navigation = JSON.parse(performanceEntries)[0];\r\n\r\n    return {\r\n      passed: navigation.loadEventEnd < 5000, // Under 5 seconds\r\n      details: {\r\n        loadTime: Math.round(navigation.loadEventEnd),\r\n        domContentLoaded: Math.round(navigation.domContentLoadedEventEnd),\r\n        firstPaint: Math.round(navigation.loadEventEnd - navigation.fetchStart),\r\n        jsHeapUsedSize: metrics.JSHeapUsedSize,\r\n        jsHeapTotalSize: metrics.JSHeapTotalSize\r\n      }\r\n    };\r\n  } catch (error) {\r\n    return {\r\n      passed: false,\r\n      error: error.message\r\n    };\r\n  }\r\n}\r\n\r\n// Test basic accessibility\r\nasync function testAccessibility(page) {\r\n  try {\r\n    const results = { passed: true, details: {} };\r\n\r\n    // Check for alt attributes on images\r\n    const imagesWithoutAlt = await page.$$eval('img:not([alt])', imgs => imgs.length);\r\n    results.details.imagesWithoutAlt = imagesWithoutAlt;\r\n\r\n    // Check for headings structure\r\n    const headings = await page.$$eval('h1, h2, h3, h4, h5, h6', \r\n      headings => headings.map(h => h.tagName)\r\n    );\r\n    results.details.headingsStructure = headings;\r\n    results.details.hasH1 = headings.includes('H1');\r\n\r\n    // Check for form labels\r\n    const inputsWithoutLabels = await page.evaluate(() => {\r\n      const inputs = document.querySelectorAll('input[type=\"text\"], input[type=\"email\"], input[type=\"password\"]');\r\n      let count = 0;\r\n      inputs.forEach(input => {\r\n        const hasLabel = document.querySelector(`label[for=\"${input.id}\"]`) || \r\n                         input.closest('label') ||\r\n                         input.getAttribute('aria-label') ||\r\n                         input.getAttribute('placeholder');\r\n        if (!hasLabel) count++;\r\n      });\r\n      return count;\r\n    });\r\n\r\n    results.details.inputsWithoutLabels = inputsWithoutLabels;\r\n\r\n    // Basic accessibility score\r\n    const issues = imagesWithoutAlt + inputsWithoutLabels + (results.details.hasH1 ? 0 : 1);\r\n    results.passed = issues === 0;\r\n    results.details.accessibilityScore = Math.max(0, 100 - (issues * 10));\r\n\r\n    return results;\r\n  } catch (error) {\r\n    return {\r\n      passed: false,\r\n      error: error.message\r\n    };\r\n  }\r\n}\r\n\r\n// Run comprehensive tests for all church sites\r\nasync function testAllChurchSites() {\r\n  try {\r\n    const db = require('../../config/db');\r\n    \r\n    const [sites] = await db.execute(`\r\n      SELECT site_slug, site_url, language_preference, church_name\r\n      FROM church_provision_queue \r\n      WHERE status = 'provisioned' AND site_url IS NOT NULL\r\n    `);\r\n\r\n    const results = [];\r\n\r\n    for (const site of sites) {\r\n      try {\r\n        const testResult = await testDeployedSite({\r\n          siteUrl: site.site_url,\r\n          language: site.language_preference\r\n        });\r\n\r\n        results.push({\r\n          churchName: site.church_name,\r\n          siteSlug: site.site_slug,\r\n          ...testResult\r\n        });\r\n\r\n        // Add delay between tests\r\n        await new Promise(resolve => setTimeout(resolve, 2000));\r\n\r\n      } catch (error) {\r\n        results.push({\r\n          churchName: site.church_name,\r\n          siteSlug: site.site_slug,\r\n          success: false,\r\n          error: error.message\r\n        });\r\n      }\r\n    }\r\n\r\n    return {\r\n      success: true,\r\n      totalSites: sites.length,\r\n      results\r\n    };\r\n\r\n  } catch (error) {\r\n    logger.error('Failed to test all church sites:', error);\r\n    return {\r\n      success: false,\r\n      error: error.message\r\n    };\r\n  }\r\n}\r\n\r\nmodule.exports = {\r\n  testDeployedSite,\r\n  testAllChurchSites,\r\n  TEST_CONFIG,\r\n  LANGUAGE_TESTS\r\n};\r\n"
    },
    "complexity": {
      "totalLines": 509,
      "codeLines": 381,
      "commentLines": 46,
      "commentRatio": 0.10772833723653395,
      "averageLineLength": 33.07259953161593
    },
    "lastAnalyzed": "2025-07-28T07:20:01.288Z"
  },
  "contentHash": "07453ad3e3e15c26b90e8eaa554561d9813c04f8e9110a9c84abf9b97e32a9bb",
  "discoveredAt": "2025-07-28T07:20:01.288Z"
}