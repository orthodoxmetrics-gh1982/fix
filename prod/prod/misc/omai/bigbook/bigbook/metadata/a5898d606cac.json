{
  "id": "a5898d606cac",
  "originalPath": "/var/www/orthodox-church-mgmt/orthodoxmetrics/prod/server/scripts/fetch-headlines.js",
  "relativePath": "server/scripts/fetch-headlines.js",
  "name": "fetch-headlines.js",
  "extension": ".js",
  "size": 23068,
  "modified": "2025-07-23T00:42:33.814Z",
  "created": "2025-07-22T23:37:44.737Z",
  "classification": {
    "type": "Server Scripts",
    "category": "Backend > Server",
    "confidence": 3
  },
  "metadata": {
    "fileStats": {
      "lines": 660,
      "characters": 22968,
      "words": 2010
    },
    "classification": {
      "type": "Server Scripts",
      "category": "Backend > Server",
      "confidence": 3
    },
    "dependencies": [
      {
        "type": "npm_package",
        "name": "axios",
        "line": 8
      },
      {
        "type": "npm_package",
        "name": "rss-parser",
        "line": 9
      },
      {
        "type": "npm_package",
        "name": "cheerio",
        "line": 10
      },
      {
        "type": "npm_package",
        "name": "mysql2/promise",
        "line": 11
      },
      {
        "type": "npm_package",
        "name": "readline",
        "line": 12
      }
    ],
    "security": {
      "findings": [
        {
          "type": "sensitive_data",
          "pattern": "(?:password|pwd|pass)\\s*[:=]\\s*['\"]([^'\"]+)['\"]",
          "line": 103,
          "redacted": true
        }
      ],
      "hasSecurityIssues": true,
      "redactedContent": "#!/usr/bin/env node\r\n/**\r\n * Orthodox News Headlines Aggregator\r\n * Fetches headlines from curated RSS feeds and HTML pages, stores in MariaDB\r\n * Supports multilingual Orthodox news sources (English, Greek, Russian, Romanian)\r\n */\r\n\r\nconst axios = require('axios');\r\nconst Parser = require('rss-parser');\r\nconst cheerio = require('cheerio');\r\nconst mysql = require('mysql2/promise');\r\nconst readline = require('readline');\r\n\r\n// Configuration\r\nconst CONFIG = {\r\n    REQUEST_TIMEOUT: 30000,\r\n    USER_AGENT: 'OrthodoxMetrics-NewsAggregator/1.0 (https://orthodoxmetrics.com)',\r\n    MAX_ARTICLES_PER_SOURCE: 20,\r\n    UTC_TIMEZONE: true\r\n};\r\n\r\n// Global database connection\r\nlet dbConnection = null;\r\n\r\n// Orthodox news sources with language tags (as specified)\r\nconst NEWS_SOURCES = [\r\n    {\r\n        name: \"Orthodox Times\",\r\n        feed_url: \"https://orthodoxtimes.com/feed/\",\r\n        language: \"en\"\r\n    },\r\n    {\r\n        name: \"Romfea\", \r\n        feed_url: \"https://www.romfea.gr/feed\",\r\n        language: \"gr\"\r\n    },\r\n    {\r\n        name: \"Patriarchate of Moscow\",\r\n        feed_url: \"https://mospat.ru/en/rss/\",\r\n        language: \"en\"\r\n    },\r\n    {\r\n        name: \"Basilica.ro\",\r\n        feed_url: \"https://basilica.ro/feed/\",\r\n        language: \"ro\"\r\n    },\r\n    // Additional reliable Orthodox sources\r\n    {\r\n        name: \"OrthoChristian\",\r\n        feed_url: \"https://orthochristian.com/rss.xml\",\r\n        language: \"en\"\r\n    },\r\n    {\r\n        name: \"Greek Orthodox Archdiocese\",\r\n        feed_url: \"https://www.goarch.org/news/rss\",\r\n        language: \"en\"\r\n    },\r\n    {\r\n        name: \"Orthodox Church in America\",\r\n        feed_url: \"https://www.oca.org/news/rss\",\r\n        language: \"en\"\r\n    },\r\n    {\r\n        name: \"Pravoslavie.ru\",\r\n        feed_url: \"https://pravoslavie.ru/news.xml\",\r\n        language: \"ru\"\r\n    }\r\n];\r\n\r\n/**\r\n * Prompt for database credentials\r\n */\r\nfunction promptCredentials(existingCreds = {}) {\r\n    const rl = readline.createInterface({\r\n        input: process.stdin,\r\n        output: process.stdout\r\n    });\r\n\r\n    return new Promise((resolve) => {\r\n        const credentials = {};\r\n        \r\n        console.log('\\nüîê Database Configuration');\r\n        console.log('=========================');\r\n        console.log('Press Enter to use default values shown in parentheses');\r\n        \r\n        const hostPrompt = `Database Host (${existingCreds.host || 'localhost'}): `;\r\n        rl.question(hostPrompt, (host) => {\r\n            credentials.host = host || existingCreds.host || 'localhost';\r\n            \r\n            const portPrompt = `Database Port (${existingCreds.port || 3306}): `;\r\n            rl.question(portPrompt, (port) => {\r\n                credentials.port = parseInt(port) || existingCreds.port || 3306;\r\n                \r\n                const dbPrompt = `Database Name (${existingCreds.database || 'orthodoxmetrics_db'}): `;\r\n                rl.question(dbPrompt, (database) => {\r\n                    credentials.database = database || existingCreds.database || 'orthodoxmetrics_db';\r\n                    \r\n                    const userPrompt = `Database User (${existingCreds.user || 'root'}): `;\r\n                    rl.question(userPrompt, (user) => {\r\n                        credentials.user = user || existingCreds.user || 'root';\r\n                        \r\n                        // Password is always required to be entered\r\n                        rl.question('Database Password: '[REDACTED]'';\r\n                            rl.close();\r\n                            resolve(credentials);\r\n                        });\r\n                    });\r\n                });\r\n            });\r\n        });\r\n    });\r\n}\r\n\r\n/**\r\n * Parse credentials from command line arguments\r\n */\r\nfunction parseCredentialsFromArgs(args) {\r\n    const credentials = {};\r\n    \r\n    for (let i = 0; i < args.length; i++) {\r\n        switch (args[i]) {\r\n            case '--db-host':\r\n                credentials.host = args[++i];\r\n                break;\r\n            case '--db-port':\r\n                credentials.port = parseInt(args[++i]);\r\n                break;\r\n            case '--db-name':\r\n                credentials.database = args[++i];\r\n                break;\r\n            case '--db-user':\r\n                credentials.user = args[++i];\r\n                break;\r\n            case '--db-password':\r\n                credentials.password = args[++i];\r\n                break;\r\n        }\r\n    }\r\n    \r\n    return credentials;\r\n}\r\n\r\n/**\r\n * Create database connection pool\r\n */\r\nasync function createDatabaseConnection(credentials) {\r\n    console.log(`\\nüîå Connecting to database: ${credentials.user}@${credentials.host}:${credentials.port}/${credentials.database}`);\r\n    \r\n    try {\r\n        // Create connection pool for better performance\r\n        dbConnection = mysql.createPool({\r\n            host: credentials.host,\r\n            port: credentials.port,\r\n            user: credentials.user,\r\n            password: credentials.password,\r\n            database: credentials.database,\r\n            charset: 'utf8mb4',\r\n            waitForConnections: true,\r\n            connectionLimit: 10,\r\n            queueLimit: 0,\r\n            acquireTimeout: 30000,\r\n            timeout: 60000\r\n        });\r\n        \r\n        // Test connection\r\n        const [result] = await dbConnection.execute('SELECT 1 as test');\r\n        console.log('‚úÖ Database connection successful!');\r\n        console.log(`   Pool created with connection limit: 10`);\r\n        \r\n        return true;\r\n    } catch (error) {\r\n        console.error('‚ùå Database connection failed:', error.message);\r\n        console.error('   Please check your credentials and database server');\r\n        dbConnection = null;\r\n        return false;\r\n    }\r\n}\r\n\r\n/**\r\n * Load configuration from database\r\n */\r\nasync function loadDatabaseConfig() {\r\n    if (!dbConnection) {\r\n        console.log('‚ö†Ô∏è No database connection, using default configuration');\r\n        return null;\r\n    }\r\n\r\n    try {\r\n        // Load enabled sources from database\r\n        const [dbSources] = await dbConnection.execute(`\r\n            SELECT id, name, feed_url, language, enabled, categories, description\r\n            FROM headlines_sources \r\n            WHERE enabled = 1\r\n            ORDER BY name ASC\r\n        `);\r\n\r\n        // Load global configuration (use first available config)\r\n        const [configs] = await dbConnection.execute(`\r\n            SELECT * FROM headlines_config \r\n            WHERE enabled = 1 \r\n            ORDER BY user_id IS NULL, id DESC \r\n            LIMIT 1\r\n        `);\r\n\r\n        const dbConfig = configs.length > 0 ? configs[0] : null;\r\n\r\n        return {\r\n            sources: dbSources.map(source => ({\r\n                name: source.name,\r\n                feed_url: source.feed_url,\r\n                language: source.language,\r\n                categories: source.categories ? JSON.parse(source.categories) : [],\r\n                description: source.description\r\n            })),\r\n            config: dbConfig ? {\r\n                maxArticlesPerSource: dbConfig.max_articles_per_source || 20,\r\n                languages: dbConfig.languages ? JSON.parse(dbConfig.languages) : ['en'],\r\n                enabledCategories: dbConfig.categories ? JSON.parse(dbConfig.categories) : []\r\n            } : null\r\n        };\r\n    } catch (error) {\r\n        console.error('‚ùå Error loading database configuration:', error.message);\r\n        return null;\r\n    }\r\n}\r\n\r\n/**\r\n * Main function to fetch all headlines\r\n */\r\nasync function fetchAllHeadlines(options = {}) {\r\n    console.log('üóûÔ∏è Starting Orthodox Headlines Aggregation');\r\n    console.log(`üìÖ ${new Date().toISOString()}`);\r\n    console.log('===============================================');\r\n    \r\n    const { language, source, useDbConfig } = options;\r\n    let totalFetched = 0;\r\n    let totalSaved = 0;\r\n    const results = [];\r\n\r\n    // Load sources - either from database or default\r\n    let sources = NEWS_SOURCES;\r\n    let maxArticles = CONFIG.MAX_ARTICLES_PER_SOURCE;\r\n\r\n    if (useDbConfig && dbConnection) {\r\n        console.log('üóÑÔ∏è Loading configuration from database...');\r\n        const dbData = await loadDatabaseConfig();\r\n        \r\n        if (dbData && dbData.sources.length > 0) {\r\n            sources = dbData.sources;\r\n            console.log(`‚úÖ Loaded ${sources.length} sources from database`);\r\n            \r\n            if (dbData.config) {\r\n                maxArticles = dbData.config.maxArticlesPerSource;\r\n                console.log(`‚úÖ Using database config: max ${maxArticles} articles per source`);\r\n                \r\n                if (dbData.config.languages.length > 0 && !language) {\r\n                    const dbLanguages = dbData.config.languages;\r\n                    sources = sources.filter(s => dbLanguages.includes(s.language));\r\n                    console.log(`‚úÖ Filtering by database languages: ${dbLanguages.join(', ')}`);\r\n                }\r\n            }\r\n        } else {\r\n            console.log('‚ö†Ô∏è No enabled sources found in database, using defaults');\r\n        }\r\n    }\r\n\r\n    // Apply CLI filters (override database config if specified)\r\n    if (language) {\r\n        sources = sources.filter(s => s.language === language);\r\n        console.log(`üîç CLI override: Filtering by language: ${language}`);\r\n    }\r\n    if (source) {\r\n        sources = sources.filter(s => s.name.toLowerCase().includes(source.toLowerCase()));\r\n        console.log(`üîç CLI override: Filtering by source: ${source}`);\r\n    }\r\n\r\n    // Update max articles config\r\n    CONFIG.MAX_ARTICLES_PER_SOURCE = maxArticles;\r\n\r\n    console.log(`üì∞ Processing ${sources.length} sources (max ${maxArticles} articles each)...\\n`);\r\n\r\n    for (const newsSource of sources) {\r\n        try {\r\n            console.log(`üì° Fetching from: ${newsSource.name} (${newsSource.language})`);\r\n            console.log(`   URL: ${newsSource.feed_url}`);\r\n            \r\n            const articles = await fetchRSSFeed(newsSource);\r\n            console.log(`   üìÑ Found ${articles.length} articles`);\r\n            \r\n            totalFetched += articles.length;\r\n\r\n            // Save to database with deduplication\r\n            const saved = await saveArticles(articles, newsSource.name);\r\n            console.log(`   üíæ Saved ${saved} new articles`);\r\n            \r\n            totalSaved += saved;\r\n            \r\n            results.push({\r\n                source: newsSource.name,\r\n                language: newsSource.language,\r\n                fetched: articles.length,\r\n                saved: saved,\r\n                success: true\r\n            });\r\n\r\n            // Rate limiting - wait 2 seconds between sources\r\n            await sleep(2000);\r\n\r\n        } catch (error) {\r\n            console.error(`‚ùå Error fetching from ${newsSource.name}:`, error.message);\r\n            results.push({\r\n                source: newsSource.name,\r\n                language: newsSource.language,\r\n                fetched: 0,\r\n                saved: 0,\r\n                success: false,\r\n                error: error.message\r\n            });\r\n        }\r\n    }\r\n\r\n    // Summary\r\n    console.log('\\nüìä Aggregation Summary:');\r\n    console.log('========================');\r\n    console.log(`üîç Total articles fetched: ${totalFetched}`);\r\n    console.log(`üíæ Total articles saved: ${totalSaved}`);\r\n    console.log(`‚úÖ Successful sources: ${results.filter(r => r.success).length}`);\r\n    console.log(`‚ùå Failed sources: ${results.filter(r => !r.success).length}`);\r\n    \r\n    // Detailed results\r\n    console.log('\\nüìã Source Details:');\r\n    results.forEach(result => {\r\n        const status = result.success ? '‚úÖ' : '‚ùå';\r\n        console.log(`   ${status} ${result.source} (${result.language}): ${result.saved}/${result.fetched} saved`);\r\n        if (!result.success) {\r\n            console.log(`      Error: ${result.error}`);\r\n        }\r\n    });\r\n\r\n    return {\r\n        totalFetched,\r\n        totalSaved,\r\n        results,\r\n        summary: `Processed ${sources.length} sources, saved ${totalSaved} articles`\r\n    };\r\n}\r\n\r\n/**\r\n * Fetch and parse RSS feed\r\n */\r\nasync function fetchRSSFeed(source) {\r\n    const parser = new Parser({\r\n        timeout: CONFIG.REQUEST_TIMEOUT,\r\n        headers: {\r\n            'User-Agent': CONFIG.USER_AGENT\r\n        }\r\n    });\r\n\r\n    try {\r\n        const feed = await parser.parseURL(source.feed_url);\r\n        \r\n        return feed.items\r\n            .slice(0, CONFIG.MAX_ARTICLES_PER_SOURCE)\r\n            .map(item => {\r\n                // Extract image from content or media elements\r\n                let imageUrl = null;\r\n                if (item.enclosure && item.enclosure.url && item.enclosure.type?.startsWith('image/')) {\r\n                    imageUrl = item.enclosure.url;\r\n                } else if (item.content) {\r\n                    const imgMatch = item.content.match(/<img[^>]+src=\"([^\"]+)\"/i);\r\n                    if (imgMatch) {\r\n                        imageUrl = imgMatch[1];\r\n                    }\r\n                } else if (item['media:content'] && item['media:content']['$'] && item['media:content']['$'].url) {\r\n                    imageUrl = item['media:content']['$'].url;\r\n                }\r\n\r\n                return {\r\n                    title: cleanText(item.title || ''),\r\n                    url: item.link || item.guid || '',\r\n                    summary: cleanText(item.contentSnippet || item.content || item.summary || ''),\r\n                    image_url: imageUrl,\r\n                    published_at: parseDate(item.pubDate || item.isoDate),\r\n                    language: source.language,\r\n                    source: source.name\r\n                };\r\n            })\r\n            .filter(article => article.title && article.url);\r\n            \r\n    } catch (error) {\r\n        if (error.message.includes('fetch')) {\r\n            throw new Error(`Failed to fetch RSS feed: ${error.message}`);\r\n        }\r\n        throw new Error(`Failed to parse RSS feed: ${error.message}`);\r\n    }\r\n}\r\n\r\n/**\r\n * Save articles to database with deduplication\r\n */\r\nasync function saveArticles(articles, sourceName) {\r\n    if (!articles.length) return 0;\r\n\r\n    // Check if database connection is available\r\n    if (!dbConnection) {\r\n        console.log(`   üß™ TEST MODE: Would save ${articles.length} articles from ${sourceName}`);\r\n        // Show sample articles in test mode\r\n        articles.slice(0, 3).forEach((article, i) => {\r\n            console.log(`      ${i+1}. ${article.title.substring(0, 80)}...`);\r\n        });\r\n        return articles.length; // Return count as if saved\r\n    }\r\n\r\n    let savedCount = 0;\r\n\r\n    console.log(`   üíæ Saving ${articles.length} articles to database...`);\r\n\r\n    for (const article of articles) {\r\n        try {\r\n            // Check for duplicates by URL (primary) or title+source (secondary)\r\n            const [existing] = await dbConnection.execute(\r\n                'SELECT id FROM news_headlines WHERE url = ? OR (title = ? AND source = ?)',\r\n                [article.url, article.title, sourceName]\r\n            );\r\n\r\n            if (existing.length > 0) {\r\n                console.log(`      üìã Duplicate skipped: ${article.title.substring(0, 50)}...`);\r\n                continue; // Skip duplicate\r\n            }\r\n\r\n            // Insert new article with UTF-8 support\r\n            const [result] = await dbConnection.execute(`\r\n                INSERT INTO news_headlines \r\n                (title, url, summary, image_url, published_at, language, source)\r\n                VALUES (?, ?, ?, ?, ?, ?, ?)\r\n            `, [\r\n                article.title.substring(0, 1000), // Prevent text overflow\r\n                article.url.substring(0, 1000),\r\n                article.summary ? article.summary.substring(0, 2000) : null,\r\n                article.image_url ? article.image_url.substring(0, 1000) : null,\r\n                article.published_at,\r\n                article.language,\r\n                article.source\r\n            ]);\r\n\r\n            if (result.insertId) {\r\n                savedCount++;\r\n                console.log(`      ‚úÖ Saved: ${article.title.substring(0, 60)}...`);\r\n            }\r\n\r\n        } catch (error) {\r\n            console.error(`   ‚ùå Error saving article: ${error.message}`);\r\n            console.error(`      Title: ${article.title.substring(0, 100)}...`);\r\n            \r\n            // Log more details for debugging\r\n            if (error.code) {\r\n                console.error(`      Error Code: ${error.code}`);\r\n            }\r\n            if (error.errno) {\r\n                console.error(`      Error Number: ${error.errno}`);\r\n            }\r\n        }\r\n    }\r\n\r\n    console.log(`   üìä Saved ${savedCount}/${articles.length} articles from ${sourceName}`);\r\n    return savedCount;\r\n}\r\n\r\n/**\r\n * Utility functions\r\n */\r\nfunction cleanText(text) {\r\n    if (!text) return '';\r\n    return text\r\n        .replace(/<[^>]*>/g, '') // Remove HTML tags\r\n        .replace(/&[#\\w]+;/g, '') // Remove HTML entities\r\n        .replace(/\\s+/g, ' ') // Normalize whitespace\r\n        .trim();\r\n}\r\n\r\nfunction parseDate(dateStr) {\r\n    if (!dateStr) return new Date();\r\n    \r\n    const parsed = new Date(dateStr);\r\n    return isNaN(parsed.getTime()) ? new Date() : parsed;\r\n}\r\n\r\nfunction sleep(ms) {\r\n    return new Promise(resolve => setTimeout(resolve, ms));\r\n}\r\n\r\n/**\r\n * CLI handling\r\n */\r\nfunction showHelp() {\r\n    console.log(`\r\nüì∞ Orthodox News Headlines Aggregator\r\n\r\nUsage:\r\n  node fetch-headlines.js [options]\r\n\r\nOptions:\r\n  --language <lang>    Filter by language (en, gr, ru, ro)\r\n  --source <name>      Filter by source name (partial match)\r\n  --test              Run in test mode (no database saves)\r\n  --use-db-config     Use sources and settings from web interface\r\n  --help              Show this help\r\n\r\nDatabase Options:\r\n  --db-host <host>     Database host (default: localhost)\r\n  --db-port <port>     Database port (default: 3306)\r\n  --db-name <name>     Database name (default: orthodoxmetrics_db)\r\n  --db-user <user>     Database user (default: root)\r\n  --db-password <pwd>  Database password (will prompt if not provided)\r\n\r\nExamples:\r\n  node fetch-headlines.js                    # Prompt for database credentials\r\n  node fetch-headlines.js --language en      # English sources only\r\n  node fetch-headlines.js --source \"Orthodox Times\"  # Specific source\r\n  node fetch-headlines.js --test             # Test mode (dry run)\r\n  node fetch-headlines.js --use-db-config    # Use web interface configuration\r\n  \r\nDatabase Examples:\r\n  node fetch-headlines.js --db-host localhost --db-user root --db-password mypass\r\n  node fetch-headlines.js --db-name orthodoxmetrics_db --test\r\n\r\nSources:\r\n${NEWS_SOURCES.map(s => `  ‚Ä¢ ${s.name} (${s.language}): ${s.feed_url}`).join('\\n')}\r\n`);\r\n}\r\n\r\n/**\r\n * Test function for CLI testing\r\n */\r\nasync function testRun(options = {}) {\r\n    console.log('üß™ TEST MODE - No database writes will be performed');\r\n    console.log('===================================================\\n');\r\n    \r\n    // In test mode, dbConnection will be null, so saveArticles will automatically handle it\r\n    const result = await fetchAllHeadlines(options);\r\n    \r\n    return result;\r\n}\r\n\r\n/**\r\n * Main execution\r\n */\r\nasync function main() {\r\n    const args = process.argv.slice(2);\r\n    \r\n    // Parse CLI arguments\r\n    const options = {};\r\n    let testMode = false;\r\n    let credentials = parseCredentialsFromArgs(args);\r\n    \r\n    for (let i = 0; i < args.length; i++) {\r\n        switch (args[i]) {\r\n            case '--language':\r\n                options.language = args[++i];\r\n                break;\r\n            case '--source':\r\n                options.source = args[++i];\r\n                break;\r\n            case '--test':\r\n                testMode = true;\r\n                break;\r\n            case '--use-db-config':\r\n                options.useDbConfig = true;\r\n                break;\r\n            case '--help':\r\n                showHelp();\r\n                return;\r\n            case '--db-host':\r\n            case '--db-port':\r\n            case '--db-name':\r\n            case '--db-user':\r\n            case '--db-password':\r\n                // Skip these as they're handled by parseCredentialsFromArgs\r\n                i++; // Skip the value\r\n                break;\r\n        }\r\n    }\r\n    \r\n    // Set defaults for missing credentials\r\n    credentials.host = credentials.host || 'localhost';\r\n    credentials.port = credentials.port || 3306;\r\n    credentials.database = credentials.database || 'orthodoxmetrics_db';\r\n    credentials.user = credentials.user || 'root';\r\n    \r\n    // Prompt for missing credentials if not provided via CLI\r\n    const missingCreds = !credentials.password || \r\n                        !credentials.host || \r\n                        !credentials.user || \r\n                        !credentials.database;\r\n    \r\n    if (missingCreds && !testMode) {\r\n        console.log('\\nüîç Missing database credentials. Please provide them:');\r\n        const promptedCreds = await promptCredentials(credentials);\r\n        // Update credentials with prompted values\r\n        credentials = promptedCreds;\r\n    } else if (missingCreds && testMode) {\r\n        console.log('\\nüß™ Test mode: skipping database connection');\r\n        options.skipDatabase = true;\r\n    }\r\n\r\n    try {\r\n        // Setup database connection unless in test mode without database operations\r\n        if (!testMode || !options.skipDatabase) {\r\n            const connected = await createDatabaseConnection(credentials);\r\n            if (!connected) {\r\n                console.error('‚ùå Failed to connect to database. Please check your credentials.');\r\n                process.exit(1);\r\n            }\r\n        }\r\n        \r\n        let result;\r\n        if (testMode) {\r\n            result = await testRun(options);\r\n        } else {\r\n            result = await fetchAllHeadlines(options);\r\n        }\r\n        \r\n        // Close database connection pool\r\n        if (dbConnection) {\r\n            await dbConnection.end();\r\n            console.log('üîå Database connection pool closed');\r\n        }\r\n        \r\n        console.log(`\\n‚úÖ ${result.summary}`);\r\n        process.exit(0);\r\n        \r\n    } catch (error) {\r\n        // Close database connection pool on error\r\n        if (dbConnection) {\r\n            try {\r\n                await dbConnection.end();\r\n                console.log('üîå Database connection pool closed (after error)');\r\n            } catch (closeError) {\r\n                console.error('‚ö†Ô∏è Error closing database pool:', closeError.message);\r\n            }\r\n        }\r\n        \r\n        console.error('‚ùå Fatal error:', error.message);\r\n        process.exit(1);\r\n    }\r\n}\r\n\r\n// Execute if run directly\r\nif (require.main === module) {\r\n    main();\r\n}\r\n\r\nmodule.exports = {\r\n    fetchAllHeadlines,\r\n    fetchRSSFeed,\r\n    saveArticles,\r\n    NEWS_SOURCES,\r\n    CONFIG\r\n}; "
    },
    "complexity": {
      "totalLines": 660,
      "codeLines": 500,
      "commentLines": 71,
      "commentRatio": 0.1243432574430823,
      "averageLineLength": 38.364273204903675
    },
    "lastAnalyzed": "2025-07-28T07:20:01.032Z"
  },
  "contentHash": "8870bc880b75810ca74d0c4b9d6d063cc0c3a5a26a9146472a3140d7d2550014",
  "discoveredAt": "2025-07-28T07:20:01.032Z"
}