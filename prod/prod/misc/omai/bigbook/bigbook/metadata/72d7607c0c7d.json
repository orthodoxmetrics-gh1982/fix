{
  "id": "72d7607c0c7d",
  "originalPath": "/var/www/orthodox-church-mgmt/orthodoxmetrics/prod/server/routes/jit-terminal.js",
  "relativePath": "server/routes/jit-terminal.js",
  "name": "jit-terminal.js",
  "extension": ".js",
  "size": 17744,
  "modified": "2025-07-25T22:45:58.491Z",
  "created": "2025-07-25T20:03:52.016Z",
  "classification": {
    "type": "Server Scripts",
    "category": "Backend > Server",
    "confidence": 7
  },
  "metadata": {
    "fileStats": {
      "lines": 562,
      "characters": 17744,
      "words": 1696
    },
    "classification": {
      "type": "Server Scripts",
      "category": "Backend > Server",
      "confidence": 7
    },
    "dependencies": [
      {
        "type": "npm_package",
        "name": "express",
        "line": 4
      },
      {
        "type": "npm_package",
        "name": "ws",
        "line": 9
      },
      {
        "type": "npm_package",
        "name": "path",
        "line": 10
      },
      {
        "type": "npm_package",
        "name": "fs",
        "line": 11
      }
    ],
    "security": {
      "findings": [
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 551,
          "redacted": true
        }
      ],
      "hasSecurityIssues": true,
      "redactedContent": "// JIT Terminal API Routes\r\n// Express routes for managing JIT (Just-In-Time) terminal sessions\r\n\r\nconst express = require('express');\r\nconst router = express.Router();\r\nconst { authMiddleware, requireRole } = require('../middleware/auth');\r\nconst JITSessionManager = require('../services/jitSessionManager');\r\nconst TerminalManager = require('../services/terminalManager');\r\nconst WebSocket = require('ws');\r\nconst path = require('path');\r\nconst fs = require('fs').promises;\r\n\r\n// Initialize managers\r\nconst jitManager = new JITSessionManager();\r\nconst terminalManager = new TerminalManager();\r\n\r\n/**\r\n * GET /api/jit/config\r\n * Get JIT Terminal configuration\r\n */\r\nrouter.get('/config', authMiddleware, requireRole(['super_admin']), async (req, res) => {\r\n  try {\r\n    const config = await jitManager.getConfig();\r\n    res.json(config);\r\n  } catch (error) {\r\n    console.error('[JIT API] Failed to get config:', error);\r\n    res.status(500).json({ message: 'Failed to retrieve configuration' });\r\n  }\r\n});\r\n\r\n/**\r\n * PUT /api/jit/config\r\n * Update JIT Terminal configuration\r\n */\r\nrouter.put('/config', authMiddleware, requireRole(['super_admin']), async (req, res) => {\r\n  try {\r\n    const config = req.body;\r\n    \r\n    // Validate configuration\r\n    const validation = validateJITConfig(config);\r\n    if (!validation.valid) {\r\n      return res.status(400).json({ \r\n        message: 'Invalid configuration',\r\n        errors: validation.errors \r\n      });\r\n    }\r\n\r\n    await jitManager.updateConfig(config, req.user);\r\n    \r\n    // Log configuration change\r\n    console.log(`[JIT API] Configuration updated by ${req.user.name} (${req.user.id})`);\r\n    \r\n    res.json({ message: 'Configuration updated successfully' });\r\n  } catch (error) {\r\n    console.error('[JIT API] Failed to update config:', error);\r\n    res.status(500).json({ message: 'Failed to update configuration' });\r\n  }\r\n});\r\n\r\n/**\r\n * GET /api/jit/sessions\r\n * Get all JIT Terminal sessions for current user or all (super_admin)\r\n */\r\nrouter.get('/sessions', authMiddleware, requireRole(['super_admin']), async (req, res) => {\r\n  try {\r\n    const sessions = await jitManager.getSessions(req.user.id, true); // Get all sessions for super_admin\r\n    res.json(sessions);\r\n  } catch (error) {\r\n    console.error('[JIT API] Failed to get sessions:', error);\r\n    res.status(500).json({ message: 'Failed to retrieve sessions' });\r\n  }\r\n});\r\n\r\n/**\r\n * POST /api/jit/start-session\r\n * Create a new JIT Terminal session\r\n */\r\nrouter.post('/start-session', authMiddleware, requireRole(['super_admin']), async (req, res) => {\r\n  try {\r\n    const { timeoutMinutes, password } = req.body;\r\n    \r\n    // Check if JIT is enabled\r\n    const config = await jitManager.getConfig();\r\n    if (!config.enabled) {\r\n      return res.status(403).json({ \r\n        message: 'JIT Terminal is currently disabled' \r\n      });\r\n    }\r\n\r\n    // Check production environment restrictions\r\n    if (isProduction() && !config.allowInProduction) {\r\n      return res.status(403).json({ \r\n        message: 'JIT Terminal is disabled in production environment' \r\n      });\r\n    }\r\n\r\n    // Check concurrent session limit\r\n    const activeSessions = await jitManager.getActiveSessions(req.user.id);\r\n    if (activeSessions.length >= config.maxConcurrentSessions) {\r\n      return res.status(429).json({ \r\n        message: `Maximum concurrent sessions limit reached (${config.maxConcurrentSessions})` \r\n      });\r\n    }\r\n\r\n    // Verify user password if required\r\n    if (config.requirePassword && password) {\r\n      const passwordValid = await verifyUserPassword(req.user.id, password);\r\n      if (!passwordValid) {\r\n        return res.status(401).json({ \r\n          message: 'Invalid password' \r\n        });\r\n      }\r\n    }\r\n\r\n    // Create new session\r\n    const session = await jitManager.createSession({\r\n      userId: req.user.id,\r\n      userName: req.user.name || req.user.email || 'Unknown User',\r\n      timeoutMinutes: timeoutMinutes || config.defaultTimeoutMinutes,\r\n      ipAddress: req.ip,\r\n      userAgent: req.get('User-Agent')\r\n    });\r\n\r\n    console.log(`[JIT API] Session created for ${req.user.name || req.user.email} (${req.user.id}) - Session ID: ${session.id}`);\r\n\r\n    res.json({\r\n      message: 'Session created successfully',\r\n      sessionId: session.id,\r\n      session: {\r\n        id: session.id,\r\n        expiresAt: session.expiresAt,\r\n        accessUrl: `/api/jit/access/${session.id}`\r\n      }\r\n    });\r\n  } catch (error) {\r\n    console.error('[JIT API] Failed to create session:', error);\r\n    res.status(500).json({ message: 'Failed to create session' });\r\n  }\r\n});\r\n\r\n/**\r\n * GET /api/jit/access/:sessionId\r\n * Access JIT Terminal session\r\n */\r\nrouter.get('/access/:sessionId', authMiddleware, requireRole(['super_admin']), async (req, res) => {\r\n  try {\r\n    const { sessionId } = req.params;\r\n    \r\n    // Validate session\r\n    const session = await jitManager.getSession(sessionId);\r\n    if (!session) {\r\n      return res.status(404).json({ message: 'Session not found' });\r\n    }\r\n\r\n    // Check if session is expired\r\n    if (new Date() > new Date(session.expiresAt)) {\r\n      await jitManager.terminateSession(sessionId);\r\n      return res.status(410).json({ message: 'Session has expired' });\r\n    }\r\n\r\n    // Check if user has access to this session\r\n    if (session.userId !== req.user.id && req.user.role !== 'super_admin') {\r\n      return res.status(403).json({ message: 'Access denied to this session' });\r\n    }\r\n\r\n    // Update session activity\r\n    await jitManager.updateSessionActivity(sessionId);\r\n\r\n    // Return session access information\r\n    res.json({\r\n      session: {\r\n        id: session.id,\r\n        expiresAt: session.expiresAt,\r\n        isActive: true\r\n      }\r\n    });\r\n  } catch (error) {\r\n    console.error('[JIT API] Failed to access session:', error);\r\n    res.status(500).json({ message: 'Failed to access session' });\r\n  }\r\n});\r\n\r\n/**\r\n * DELETE /api/jit/sessions/:sessionId\r\n * Terminate a JIT Terminal session\r\n */\r\nrouter.delete('/sessions/:sessionId', authMiddleware, requireRole(['super_admin']), async (req, res) => {\r\n  try {\r\n    const { sessionId } = req.params;\r\n    \r\n    // Check if session exists\r\n    const session = await jitManager.getSession(sessionId);\r\n    if (!session) {\r\n      return res.status(404).json({ message: 'Session not found' });\r\n    }\r\n\r\n    // Check if user has permission to terminate this session\r\n    if (session.userId !== req.user.id && req.user.role !== 'super_admin') {\r\n      return res.status(403).json({ message: 'Access denied to terminate this session' });\r\n    }\r\n\r\n    // Terminate session\r\n    await jitManager.terminateSession(sessionId);\r\n    \r\n    console.log(`[JIT API] Session ${sessionId} terminated by ${req.user.name} (${req.user.id})`);\r\n    \r\n    res.json({ message: 'Session terminated successfully' });\r\n  } catch (error) {\r\n    console.error('[JIT API] Failed to terminate session:', error);\r\n    res.status(500).json({ message: 'Failed to terminate session' });\r\n  }\r\n});\r\n\r\n/**\r\n * POST /api/jit/end-session\r\n * End a JIT Terminal session (alternative endpoint for frontend)\r\n */\r\nrouter.post('/end-session', authMiddleware, requireRole(['super_admin']), async (req, res) => {\r\n  try {\r\n    const { sessionId } = req.body;\r\n    \r\n    if (!sessionId) {\r\n      return res.status(400).json({ message: 'Session ID is required' });\r\n    }\r\n    \r\n    // Check if session exists\r\n    const session = await jitManager.getSession(sessionId);\r\n    if (!session) {\r\n      return res.status(404).json({ message: 'Session not found' });\r\n    }\r\n\r\n    // Check if user has permission to terminate this session\r\n    if (session.userId !== req.user.id && req.user.role !== 'super_admin') {\r\n      return res.status(403).json({ message: 'Access denied to terminate this session' });\r\n    }\r\n\r\n    // Terminate session\r\n    await jitManager.terminateSession(sessionId);\r\n    \r\n    console.log(`[JIT API] Session ${sessionId} ended by ${req.user.name} (${req.user.id})`);\r\n    \r\n    res.json({ message: 'Session ended successfully' });\r\n  } catch (error) {\r\n    console.error('[JIT API] Failed to end session:', error);\r\n    res.status(500).json({ message: 'Failed to end session' });\r\n  }\r\n});\r\n\r\n/**\r\n * GET /api/jit/status\r\n * Get JIT Terminal system status\r\n */\r\nrouter.get('/status', authMiddleware, requireRole(['super_admin']), async (req, res) => {\r\n  try {\r\n    const status = await jitManager.getSystemStatus();\r\n    const activeSessions = terminalManager.getActiveSessions();\r\n    \r\n    res.json({\r\n      ...status,\r\n      terminals: {\r\n        activeSessions: activeSessions.length,\r\n        sessions: activeSessions\r\n      }\r\n    });\r\n  } catch (error) {\r\n    console.error('[JIT API] Failed to get status:', error);\r\n    res.status(500).json({ message: 'Failed to retrieve system status' });\r\n  }\r\n});\r\n\r\n/**\r\n * POST /api/jit/test-terminal\r\n * Test terminal functionality\r\n */\r\nrouter.post('/test-terminal', authMiddleware, requireRole(['super_admin']), async (req, res) => {\r\n  try {\r\n    console.log(`[JIT API] Terminal test requested by ${req.user.name} (${req.user.id})`);\r\n    \r\n    const testResult = await terminalManager.testTerminal();\r\n    \r\n    res.json({\r\n      success: true,\r\n      message: 'Terminal test completed successfully',\r\n      test: testResult\r\n    });\r\n  } catch (error) {\r\n    console.error('[JIT API] Terminal test failed:', error);\r\n    res.status(500).json({ \r\n      success: false,\r\n      message: 'Terminal test failed',\r\n      error: error.message \r\n    });\r\n  }\r\n});\r\n\r\n// WebSocket setup function\r\nfunction setupJITWebSocket(server) {\r\n  const wss = new WebSocket.Server({ \r\n    server,\r\n    path: '/api/jit/ws'\r\n  });\r\n  \r\n  wss.on('connection', (ws, req) => {\r\n    console.log('[JIT WebSocket] New connection established');\r\n    \r\n    // Extract session ID from URL\r\n    const url = new URL(req.url, 'http://localhost');\r\n    const sessionId = url.searchParams.get('sessionId');\r\n    \r\n    if (!sessionId) {\r\n      ws.close(1008, 'Session ID required');\r\n      return;\r\n    }\r\n    \r\n    // Validate session\r\n    jitManager.getSession(sessionId).then(async session => {\r\n      if (!session || new Date() > new Date(session.expiresAt)) {\r\n        ws.close(1008, 'Invalid or expired session');\r\n        return;\r\n      }\r\n      \r\n      // Store session info in WebSocket\r\n      ws.sessionId = sessionId;\r\n      ws.userId = session.userId;\r\n      \r\n      console.log(`[JIT WebSocket] Session ${sessionId} connected for user ${session.userId}`);\r\n      \r\n      try {\r\n        // Create actual terminal session\r\n        const terminalResult = await terminalManager.createTerminal(sessionId, {\r\n          cols: 80,\r\n          rows: 24\r\n        });\r\n        \r\n        console.log(`[JIT WebSocket] Terminal created for session ${sessionId}:`, terminalResult);\r\n        \r\n        // Get terminal process for event handling\r\n        const ptyProcess = terminalManager.getTerminalProcess(sessionId);\r\n        \r\n        if (ptyProcess) {\r\n          // Set up terminal data handler\r\n          ptyProcess.on('session_data', (terminalSessionId, data) => {\r\n            if (terminalSessionId === sessionId && ws.readyState === WebSocket.OPEN) {\r\n              ws.send(JSON.stringify({\r\n                type: 'terminal_data',\r\n                data: data.toString()\r\n              }));\r\n            }\r\n          });\r\n          \r\n          // Set up terminal exit handler\r\n          ptyProcess.on('session_exit', (terminalSessionId, code, signal) => {\r\n            if (terminalSessionId === sessionId && ws.readyState === WebSocket.OPEN) {\r\n              ws.send(JSON.stringify({\r\n                type: 'terminal_exit',\r\n                code: code,\r\n                signal: signal,\r\n                message: `Terminal session ended (code: ${code})`\r\n              }));\r\n            }\r\n          });\r\n          \r\n          // Set up terminal error handler\r\n          ptyProcess.on('session_error', (terminalSessionId, error) => {\r\n            if (terminalSessionId === sessionId && ws.readyState === WebSocket.OPEN) {\r\n              ws.send(JSON.stringify({\r\n                type: 'terminal_error',\r\n                message: error.message,\r\n                error: error.toString()\r\n              }));\r\n            }\r\n          });\r\n        }\r\n        \r\n        // Send welcome message with terminal info\r\n        ws.send(JSON.stringify({\r\n          type: 'welcome',\r\n          message: 'JIT Terminal connected successfully',\r\n          sessionId: sessionId,\r\n          terminal: {\r\n            pid: terminalResult.pid,\r\n            shell: terminalResult.shell\r\n          }\r\n        }));\r\n        \r\n      } catch (error) {\r\n        console.error(`[JIT WebSocket] Failed to create terminal for session ${sessionId}:`, error);\r\n        ws.send(JSON.stringify({\r\n          type: 'error',\r\n          message: 'Failed to create terminal session',\r\n          error: error.message\r\n        }));\r\n        ws.close(1011, 'Terminal creation failed');\r\n        return;\r\n      }\r\n      \r\n    }).catch(error => {\r\n      console.error('[JIT WebSocket] Session validation failed:', error);\r\n      ws.close(1008, 'Session validation failed');\r\n    });\r\n    \r\n    ws.on('message', (message) => {\r\n      try {\r\n        const data = JSON.parse(message);\r\n        console.log(`[JIT WebSocket] Received message from session ${ws.sessionId}:`, data.type);\r\n        \r\n        // Handle different message types\r\n        switch (data.type) {\r\n          case 'terminal_input':\r\n            handleTerminalInput(ws, data);\r\n            break;\r\n          case 'terminal_resize':\r\n            handleTerminalResize(ws, data);\r\n            break;\r\n          case 'ping':\r\n            ws.send(JSON.stringify({ type: 'pong' }));\r\n            break;\r\n          default:\r\n            ws.send(JSON.stringify({ \r\n              type: 'error', \r\n              message: 'Unknown message type' \r\n            }));\r\n        }\r\n      } catch (error) {\r\n        console.error('[JIT WebSocket] Message handling error:', error);\r\n        ws.send(JSON.stringify({ \r\n          type: 'error', \r\n          message: 'Invalid message format' \r\n        }));\r\n      }\r\n    });\r\n    \r\n    ws.on('close', async () => {\r\n      console.log(`[JIT WebSocket] Session ${ws.sessionId} disconnected`);\r\n      \r\n      // Close terminal session\r\n      if (ws.sessionId) {\r\n        try {\r\n          await terminalManager.closeTerminal(ws.sessionId);\r\n          console.log(`[JIT WebSocket] Terminal closed for session ${ws.sessionId}`);\r\n        } catch (error) {\r\n          console.error(`[JIT WebSocket] Failed to close terminal for session ${ws.sessionId}:`, error);\r\n        }\r\n      }\r\n    });\r\n  });\r\n  \r\n  return wss;\r\n}\r\n\r\n// Handle terminal input\r\nasync function handleTerminalInput(ws, data) {\r\n  try {\r\n    const { input } = data;\r\n    \r\n    if (!input) {\r\n      ws.send(JSON.stringify({\r\n        type: 'error',\r\n        message: 'Input data is required'\r\n      }));\r\n      return;\r\n    }\r\n    \r\n    // Update session activity\r\n    await jitManager.updateSessionActivity(ws.sessionId);\r\n    \r\n    // Write input to terminal\r\n    await terminalManager.writeToTerminal(ws.sessionId, input);\r\n    \r\n    console.log(`[JIT WebSocket] Input sent to terminal ${ws.sessionId}: ${input.trim()}`);\r\n    \r\n  } catch (error) {\r\n    console.error('[JIT WebSocket] Terminal input error:', error);\r\n    ws.send(JSON.stringify({\r\n      type: 'error',\r\n      message: 'Failed to process terminal input',\r\n      error: error.message\r\n    }));\r\n  }\r\n}\r\n\r\n// Handle terminal resize\r\nasync function handleTerminalResize(ws, data) {\r\n  try {\r\n    const { cols, rows } = data;\r\n    \r\n    if (!cols || !rows) {\r\n      ws.send(JSON.stringify({\r\n        type: 'error',\r\n        message: 'Columns and rows are required for resize'\r\n      }));\r\n      return;\r\n    }\r\n    \r\n    // Update session activity\r\n    await jitManager.updateSessionActivity(ws.sessionId);\r\n    \r\n    // Resize terminal\r\n    await terminalManager.resizeTerminal(ws.sessionId, cols, rows);\r\n    \r\n    console.log(`[JIT WebSocket] Terminal ${ws.sessionId} resized to ${cols}x${rows}`);\r\n    \r\n    ws.send(JSON.stringify({\r\n      type: 'terminal_resized',\r\n      cols: cols,\r\n      rows: rows\r\n    }));\r\n    \r\n  } catch (error) {\r\n    console.error('[JIT WebSocket] Terminal resize error:', error);\r\n    ws.send(JSON.stringify({\r\n      type: 'error',\r\n      message: 'Failed to resize terminal',\r\n      error: error.message\r\n    }));\r\n  }\r\n}\r\n\r\n// Configuration validation\r\nfunction validateJITConfig(config) {\r\n  const errors = [];\r\n  \r\n  if (typeof config.enabled !== 'boolean') {\r\n    errors.push('enabled must be a boolean');\r\n  }\r\n  \r\n  if (typeof config.maxConcurrentSessions !== 'number' || config.maxConcurrentSessions < 1) {\r\n    errors.push('maxConcurrentSessions must be a positive number');\r\n  }\r\n  \r\n  if (typeof config.defaultTimeoutMinutes !== 'number' || config.defaultTimeoutMinutes < 1) {\r\n    errors.push('defaultTimeoutMinutes must be a positive number');\r\n  }\r\n  \r\n  if (typeof config.requirePassword !== 'boolean') {\r\n    errors.push('requirePassword must be a boolean');\r\n  }\r\n  \r\n  if (typeof config.allowInProduction !== 'boolean') {\r\n    errors.push('allowInProduction must be a boolean');\r\n  }\r\n  \r\n  return {\r\n    valid: errors.length === 0,\r\n    errors: errors\r\n  };\r\n}\r\n\r\n// Environment check\r\nfunction isProduction() {\r\n  return process.env.[REDACTED] === 'production';\r\n}\r\n\r\n// Password verification stub\r\nasync function verifyUserPassword(userId, password) {\r\n  // This would be implemented to verify the user's password\r\n  // For now, return true as a stub\r\n  return true;\r\n}\r\n\r\nmodule.exports = router;\r\nmodule.exports.setupJITWebSocket = setupJITWebSocket; "
    },
    "complexity": {
      "totalLines": 562,
      "codeLines": 397,
      "commentLines": 80,
      "commentRatio": 0.16771488469601678,
      "averageLineLength": 35.34591194968554
    },
    "lastAnalyzed": "2025-07-28T07:20:00.492Z"
  },
  "contentHash": "5c81e2ce6d3fb7f0f8e24f50a7597ccad463fe37a42c590d439289191f775c27",
  "discoveredAt": "2025-07-28T07:20:00.492Z"
}