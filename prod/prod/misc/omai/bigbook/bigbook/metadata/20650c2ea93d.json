{
  "id": "20650c2ea93d",
  "originalPath": "/var/www/orthodox-church-mgmt/orthodoxmetrics/prod/server/routes/billing.js",
  "relativePath": "server/routes/billing.js",
  "name": "billing.js",
  "extension": ".js",
  "size": 20383,
  "modified": "2025-07-04T23:08:08.000Z",
  "created": "2025-07-09T00:48:38.478Z",
  "classification": {
    "type": "Server Scripts",
    "category": "Backend > Server",
    "confidence": 7
  },
  "metadata": {
    "fileStats": {
      "lines": 615,
      "characters": 20379,
      "words": 2079
    },
    "classification": {
      "type": "Server Scripts",
      "category": "Backend > Server",
      "confidence": 7
    },
    "dependencies": [
      {
        "type": "npm_package",
        "name": "express",
        "line": 2
      },
      {
        "type": "npm_package",
        "name": "stripe",
        "line": 11
      }
    ],
    "security": {
      "findings": [
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 10,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 11,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 458,
          "redacted": true
        }
      ],
      "hasSecurityIssues": true,
      "redactedContent": "// server/routes/billing.js\r\nconst express = require('express');\r\nconst { promisePool } = require('../../config/db');\r\nconst { BillingInvoiceGenerator } = require('../utils/billingInvoiceGenerator');\r\nconst { requireAuth } = require('../middleware/auth');\r\nconst { cleanRecord, cleanRecords } = require('../utils/dateFormatter');\r\n\r\n// Initialize Stripe only if API key is provided\r\nlet stripe = null;\r\nif (process.env.[REDACTED]) {\r\n  stripe = require('stripe')(process.env.[REDACTED]);\r\n} else {\r\n  console.warn('⚠️  STRIPE_SECRET_KEY not found in environment variables. Stripe functionality will be disabled.');\r\n}\r\n\r\nconst router = express.Router();\r\n\r\n// Helper function to generate invoice number\r\nfunction generateInvoiceNumber() {\r\n  const date = new Date();\r\n  const year = date.getFullYear();\r\n  const month = String(date.getMonth() + 1).padStart(2, '0');\r\n  const random = Math.floor(Math.random() * 1000).toString().padStart(3, '0');\r\n  return `INV-${year}${month}-${random}`;\r\n}\r\n\r\n// Debug endpoint to check auth\r\nrouter.get('/auth-check', requireAuth, (req, res) => {\r\n  res.json({\r\n    authenticated: true,\r\n    user: req.user,\r\n    sessionUser: req.session?.user,\r\n    timestamp: new Date().toISOString()\r\n  });\r\n});\r\n\r\n// GET /api/billing/plans - Get all billing plans\r\nrouter.get('/plans', async (req, res) => {\r\n  try {\r\n    const [plans] = await promisePool.query(`\r\n      SELECT * FROM billing_plans \r\n      WHERE is_active = TRUE \r\n      ORDER BY price_monthly ASC\r\n    `);\r\n    \r\n    res.json({ plans });\r\n  } catch (error) {\r\n    console.error('Error fetching billing plans:', error);\r\n    res.status(500).json({ error: 'Failed to fetch billing plans' });\r\n  }\r\n});\r\n\r\n// GET /api/billing/subscription/:churchId - Get church subscription\r\nrouter.get('/subscription/:churchId', requireAuth, async (req, res) => {\r\n  try {\r\n    const { churchId } = req.params;\r\n    \r\n    const [subscriptions] = await promisePool.query(`\r\n      SELECT s.*, bp.name as plan_name, bp.plan_code, bp.features, c.name as church_name\r\n      FROM subscriptions s\r\n      JOIN billing_plans bp ON s.plan_id = bp.id\r\n      JOIN churches c ON s.church_id = c.id\r\n      WHERE s.church_id = ? AND s.status != 'cancelled'\r\n      ORDER BY s.created_at DESC\r\n      LIMIT 1\r\n    `, [churchId]);\r\n    \r\n    if (subscriptions.length === 0) {\r\n      return res.status(404).json({ error: 'No active subscription found' });\r\n    }\r\n    \r\n    res.json({ subscription: cleanRecord(subscriptions[0]) });\r\n  } catch (error) {\r\n    console.error('Error fetching subscription:', error);\r\n    res.status(500).json({ error: 'Failed to fetch subscription' });\r\n  }\r\n});\r\n\r\n// POST /api/billing/subscription - Create or update subscription\r\nrouter.post('/subscription', requireAuth, async (req, res) => {\r\n  try {\r\n    const { \r\n      churchId, \r\n      planId, \r\n      billingCycle, \r\n      paymentMethodId \r\n    } = req.body;\r\n\r\n    if (!churchId || !planId || !billingCycle) {\r\n      return res.status(400).json({ error: 'Missing required fields' });\r\n    }\r\n\r\n    // Get plan details\r\n    const [plans] = await promisePool.query(\r\n      'SELECT * FROM billing_plans WHERE id = ?', \r\n      [planId]\r\n    );\r\n    \r\n    if (plans.length === 0) {\r\n      return res.status(404).json({ error: 'Plan not found' });\r\n    }\r\n    \r\n    const plan = plans[0];\r\n    let amount;\r\n    \r\n    switch (billingCycle) {\r\n      case 'monthly':\r\n        amount = plan.price_monthly;\r\n        break;\r\n      case 'quarterly':\r\n        amount = plan.price_quarterly;\r\n        break;\r\n      case 'yearly':\r\n        amount = plan.price_yearly;\r\n        break;\r\n      default:\r\n        return res.status(400).json({ error: 'Invalid billing cycle' });\r\n    }\r\n\r\n    // Calculate renewal date\r\n    const startDate = new Date();\r\n    const renewalDate = new Date(startDate);\r\n    \r\n    switch (billingCycle) {\r\n      case 'monthly':\r\n        renewalDate.setMonth(renewalDate.getMonth() + 1);\r\n        break;\r\n      case 'quarterly':\r\n        renewalDate.setMonth(renewalDate.getMonth() + 3);\r\n        break;\r\n      case 'yearly':\r\n        renewalDate.setFullYear(renewalDate.getFullYear() + 1);\r\n        break;\r\n    }\r\n\r\n    // Check for existing subscription\r\n    const [existingSubs] = await promisePool.query(\r\n      'SELECT id FROM subscriptions WHERE church_id = ? AND status = \"active\"',\r\n      [churchId]\r\n    );\r\n\r\n    let subscriptionId;\r\n    \r\n    if (existingSubs.length > 0) {\r\n      // Update existing subscription\r\n      subscriptionId = existingSubs[0].id;\r\n      await promisePool.query(`\r\n        UPDATE subscriptions \r\n        SET plan_id = ?, billing_cycle = ?, amount = ?, renewal_date = ?, updated_at = CURRENT_TIMESTAMP\r\n        WHERE id = ?\r\n      `, [planId, billingCycle, amount, renewalDate, subscriptionId]);\r\n    } else {\r\n      // Create new subscription\r\n      const [result] = await promisePool.query(`\r\n        INSERT INTO subscriptions (church_id, plan_id, billing_cycle, start_date, renewal_date, status, amount)\r\n        VALUES (?, ?, ?, ?, ?, 'active', ?)\r\n      `, [churchId, planId, billingCycle, startDate, renewalDate, amount]);\r\n      \r\n      subscriptionId = result.insertId;\r\n    }\r\n\r\n    // Create initial invoice\r\n    const invoiceNumber = generateInvoiceNumber();\r\n    const dueDate = new Date();\r\n    dueDate.setDate(dueDate.getDate() + 14); // 14 days to pay\r\n\r\n    const [invoiceResult] = await promisePool.query(`\r\n      INSERT INTO invoices (invoice_number, church_id, subscription_id, date, due_date, total_amount, status)\r\n      VALUES (?, ?, ?, ?, ?, ?, 'pending')\r\n    `, [invoiceNumber, churchId, subscriptionId, startDate, dueDate, amount]);\r\n    \r\n    const invoiceId = invoiceResult.insertId;\r\n\r\n    // Add invoice item\r\n    await promisePool.query(`\r\n      INSERT INTO invoice_items (invoice_id, description, amount, quantity, line_total, item_type)\r\n      VALUES (?, ?, ?, 1, ?, 'subscription')\r\n    `, [invoiceId, `${plan.name} - ${billingCycle} billing`, amount, amount]);\r\n\r\n    // Log billing event\r\n    await promisePool.query(`\r\n      INSERT INTO billing_events (church_id, event_type, reference_id, data)\r\n      VALUES (?, 'subscription_created', ?, ?)\r\n    `, [churchId, subscriptionId, JSON.stringify({ plan: plan.name, billing_cycle: billingCycle, amount })]);\r\n\r\n    res.json({ \r\n      success: true, \r\n      subscriptionId, \r\n      invoiceId,\r\n      invoiceNumber,\r\n      message: 'Subscription created successfully' \r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error creating subscription:', error);\r\n    res.status(500).json({ error: 'Failed to create subscription' });\r\n  }\r\n});\r\n\r\n// GET /api/billing/invoices/:churchId - Get invoices for a church\r\nrouter.get('/invoices/:churchId', requireAuth, async (req, res) => {\r\n  try {\r\n    const { churchId } = req.params;\r\n    const { page = 1, limit = 10, status } = req.query;\r\n    const userId = req.user?.id;\r\n    \r\n    // Basic authorization check\r\n    if (!userId) {\r\n      return res.status(401).json({ error: 'User not authenticated' });\r\n    }\r\n\r\n    console.log(`User ${userId} requesting invoices for church ${churchId}`);\r\n    \r\n    let whereClause = 'WHERE i.church_id = ?';\r\n    let queryParams = [churchId];\r\n    \r\n    if (status) {\r\n      whereClause += ' AND i.status = ?';\r\n      queryParams.push(status);\r\n    }\r\n    \r\n    const offset = (page - 1) * limit;\r\n    \r\n    const [invoices] = await promisePool.query(`\r\n      SELECT i.*, c.name as church_name, s.billing_cycle\r\n      FROM invoices i\r\n      LEFT JOIN churches c ON i.church_id = c.id\r\n      LEFT JOIN subscriptions s ON i.subscription_id = s.id\r\n      ${whereClause}\r\n      ORDER BY i.date DESC\r\n      LIMIT ? OFFSET ?\r\n    `, [...queryParams, parseInt(limit), parseInt(offset)]);\r\n    \r\n    // Get total count\r\n    const [countResult] = await promisePool.query(`\r\n      SELECT COUNT(*) as total \r\n      FROM invoices i \r\n      ${whereClause}\r\n    `, queryParams);\r\n    \r\n    res.json({ \r\n      invoices: cleanRecords(invoices), \r\n      pagination: {\r\n        page: parseInt(page),\r\n        limit: parseInt(limit),\r\n        total: countResult[0].total,\r\n        pages: Math.ceil(countResult[0].total / limit)\r\n      }\r\n    });\r\n  } catch (error) {\r\n    console.error('Error fetching invoices:', error);\r\n    res.status(500).json({ error: 'Failed to fetch invoices' });\r\n  }\r\n});\r\n\r\n// GET /api/billing/invoice/:invoiceId - Get specific invoice with items\r\nrouter.get('/invoice/:invoiceId', requireAuth, async (req, res) => {\r\n  try {\r\n    const { invoiceId } = req.params;\r\n    \r\n    // Get invoice details\r\n    const [invoices] = await promisePool.query(`\r\n      SELECT i.*, c.name as church_name, c.address, c.city, c.country, c.preferred_language\r\n      FROM invoices i\r\n      JOIN churches c ON i.church_id = c.id\r\n      WHERE i.id = ?\r\n    `, [invoiceId]);\r\n    \r\n    if (invoices.length === 0) {\r\n      return res.status(404).json({ error: 'Invoice not found' });\r\n    }\r\n    \r\n    const invoice = invoices[0];\r\n    \r\n    // Get invoice items\r\n    const [items] = await promisePool.query(`\r\n      SELECT * FROM invoice_items WHERE invoice_id = ? ORDER BY id\r\n    `, [invoiceId]);\r\n    \r\n    invoice.items = items;\r\n    \r\n    res.json({ invoice: cleanRecord(invoice) });\r\n  } catch (error) {\r\n    console.error('Error fetching invoice:', error);\r\n    res.status(500).json({ error: 'Failed to fetch invoice' });\r\n  }\r\n});\r\n\r\n// POST /api/billing/invoice/:invoiceId/generate - Generate invoice HTML/PDF\r\nrouter.post('/invoice/:invoiceId/generate', requireAuth, async (req, res) => {\r\n  try {\r\n    const { invoiceId } = req.params;\r\n    const { language = 'en', format = 'html' } = req.body;\r\n    \r\n    // Get invoice data\r\n    const [invoices] = await promisePool.query(`\r\n      SELECT i.*, c.name as church_name, c.address, c.city, c.country, c.preferred_language\r\n      FROM invoices i\r\n      JOIN churches c ON i.church_id = c.id\r\n      WHERE i.id = ?\r\n    `, [invoiceId]);\r\n    \r\n    if (invoices.length === 0) {\r\n      return res.status(404).json({ error: 'Invoice not found' });\r\n    }\r\n    \r\n    const invoice = invoices[0];\r\n    \r\n    // Get invoice items\r\n    const [items] = await promisePool.query(`\r\n      SELECT * FROM invoice_items WHERE invoice_id = ? ORDER BY id\r\n    `, [invoiceId]);\r\n    \r\n    // Format invoice data for generator\r\n    const invoiceData = {\r\n      invoiceNumber: invoice.invoice_number,\r\n      date: invoice.date,\r\n      dueDate: invoice.due_date,\r\n      church: {\r\n        name: invoice.church_name,\r\n        address: invoice.address,\r\n        city: invoice.city,\r\n        country: invoice.country\r\n      },\r\n      items: items.map(item => ({\r\n        description: item.description,\r\n        quantity: item.quantity,\r\n        unitPrice: parseFloat(item.amount),\r\n        total: parseFloat(item.line_total)\r\n      })),\r\n      subtotal: parseFloat(invoice.total_amount),\r\n      tax: parseFloat(invoice.tax_amount || 0),\r\n      total: parseFloat(invoice.total_amount) + parseFloat(invoice.tax_amount || 0),\r\n      currency: invoice.currency,\r\n      notes: invoice.notes,\r\n      status: invoice.status\r\n    };\r\n    \r\n    const generator = new BillingInvoiceGenerator();\r\n    const html = generator.generateBillingInvoice(invoiceData, language || invoice.preferred_language || 'en');\r\n    \r\n    // Save HTML content to database\r\n    await promisePool.query(\r\n      'UPDATE invoices SET html_content = ?, language = ? WHERE id = ?',\r\n      [html, language, invoiceId]\r\n    );\r\n    \r\n    if (format === 'pdf') {\r\n      // TODO: Implement PDF generation using Puppeteer or similar\r\n      return res.status(501).json({ error: 'PDF generation not yet implemented' });\r\n    }\r\n    \r\n    res.json({ html, invoiceData });\r\n  } catch (error) {\r\n    console.error('Error generating invoice:', error);\r\n    res.status(500).json({ error: 'Failed to generate invoice' });\r\n  }\r\n});\r\n\r\n// POST /api/billing/charge - Process payment\r\nrouter.post('/charge', requireAuth, async (req, res) => {\r\n  try {\r\n    // Check if Stripe is available\r\n    if (!stripe) {\r\n      return res.status(503).json({ \r\n        error: 'Payment processing unavailable. Stripe not configured.' \r\n      });\r\n    }\r\n\r\n    const { invoiceId, paymentMethodId, amount } = req.body;\r\n    \r\n    if (!invoiceId || !paymentMethodId || !amount) {\r\n      return res.status(400).json({ error: 'Missing required fields' });\r\n    }\r\n    \r\n    // Get invoice\r\n    const [invoices] = await promisePool.query(\r\n      'SELECT * FROM invoices WHERE id = ?',\r\n      [invoiceId]\r\n    );\r\n    \r\n    if (invoices.length === 0) {\r\n      return res.status(404).json({ error: 'Invoice not found' });\r\n    }\r\n    \r\n    const invoice = invoices[0];\r\n    \r\n    if (invoice.status === 'paid') {\r\n      return res.status(400).json({ error: 'Invoice already paid' });\r\n    }\r\n    \r\n    // Create Stripe payment intent\r\n    const paymentIntent = await stripe.paymentIntents.create({\r\n      amount: Math.round(amount * 100), // Convert to cents\r\n      currency: invoice.currency.toLowerCase(),\r\n      payment_method: paymentMethodId,\r\n      confirmation_method: 'manual',\r\n      confirm: true,\r\n      metadata: {\r\n        invoice_id: invoiceId,\r\n        church_id: invoice.church_id\r\n      }\r\n    });\r\n    \r\n    // Record transaction\r\n    const [transactionResult] = await promisePool.query(`\r\n      INSERT INTO payment_transactions (invoice_id, church_id, stripe_payment_intent_id, amount, currency, status)\r\n      VALUES (?, ?, ?, ?, ?, ?)\r\n    `, [invoiceId, invoice.church_id, paymentIntent.id, amount, invoice.currency, paymentIntent.status]);\r\n    \r\n    if (paymentIntent.status === 'succeeded') {\r\n      // Mark invoice as paid\r\n      await promisePool.query(\r\n        'UPDATE invoices SET status = \"paid\", payment_date = CURRENT_TIMESTAMP WHERE id = ?',\r\n        [invoiceId]\r\n      );\r\n      \r\n      // Update transaction\r\n      await promisePool.query(\r\n        'UPDATE payment_transactions SET status = \"succeeded\", processed_at = CURRENT_TIMESTAMP WHERE id = ?',\r\n        [transactionResult.insertId]\r\n      );\r\n      \r\n      // Log event\r\n      await promisePool.query(`\r\n        INSERT INTO billing_events (church_id, event_type, reference_id, data)\r\n        VALUES (?, 'payment_succeeded', ?, ?)\r\n      `, [invoice.church_id, invoiceId, JSON.stringify({ amount, currency: invoice.currency })]);\r\n    }\r\n    \r\n    res.json({ \r\n      success: paymentIntent.status === 'succeeded',\r\n      paymentIntent: {\r\n        id: paymentIntent.id,\r\n        status: paymentIntent.status,\r\n        amount: paymentIntent.amount\r\n      }\r\n    });\r\n    \r\n  } catch (error) {\r\n    console.error('Error processing payment:', error);\r\n    res.status(500).json({ error: 'Failed to process payment' });\r\n  }\r\n});\r\n\r\n// POST /api/billing/webhook - Stripe webhook handler\r\nrouter.post('/webhook', express.raw({type: 'application/json'}), async (req, res) => {\r\n  // Check if Stripe is available\r\n  if (!stripe) {\r\n    console.warn('Webhook received but Stripe not configured');\r\n    return res.status(503).json({ error: 'Stripe not configured' });\r\n  }\r\n\r\n  const sig = req.headers['stripe-signature'];\r\n  let event;\r\n\r\n  try {\r\n    event = stripe.webhooks.constructEvent(req.body, sig, process.env.[REDACTED]);\r\n  } catch (err) {\r\n    console.error('Webhook signature verification failed:', err.message);\r\n    return res.status(400).send(`Webhook Error: ${err.message}`);\r\n  }\r\n\r\n  try {\r\n    switch (event.type) {\r\n      case 'invoice.payment_succeeded':\r\n        const invoice = event.data.object;\r\n        // Handle successful payment\r\n        await handleInvoicePaymentSucceeded(invoice);\r\n        break;\r\n        \r\n      case 'invoice.payment_failed':\r\n        const failedInvoice = event.data.object;\r\n        // Handle failed payment\r\n        await handleInvoicePaymentFailed(failedInvoice);\r\n        break;\r\n        \r\n      case 'customer.subscription.deleted':\r\n        const subscription = event.data.object;\r\n        // Handle subscription cancellation\r\n        await handleSubscriptionDeleted(subscription);\r\n        break;\r\n        \r\n      default:\r\n        console.log(`Unhandled event type ${event.type}`);\r\n    }\r\n    \r\n    res.json({received: true});\r\n  } catch (error) {\r\n    console.error('Error handling webhook:', error);\r\n    res.status(500).json({ error: 'Webhook handler failed' });\r\n  }\r\n});\r\n\r\n// Helper functions for webhook handlers\r\nasync function handleInvoicePaymentSucceeded(stripeInvoice) {\r\n  const [invoices] = await promisePool.query(\r\n    'SELECT * FROM invoices WHERE stripe_invoice_id = ?',\r\n    [stripeInvoice.id]\r\n  );\r\n  \r\n  if (invoices.length > 0) {\r\n    const invoice = invoices[0];\r\n    await promisePool.query(\r\n      'UPDATE invoices SET status = \"paid\", payment_date = CURRENT_TIMESTAMP WHERE id = ?',\r\n      [invoice.id]\r\n    );\r\n    \r\n    await promisePool.query(`\r\n      INSERT INTO billing_events (church_id, event_type, reference_id, data)\r\n      VALUES (?, 'invoice_paid', ?, ?)\r\n    `, [invoice.church_id, invoice.id, JSON.stringify({ stripe_invoice_id: stripeInvoice.id })]);\r\n  }\r\n}\r\n\r\nasync function handleInvoicePaymentFailed(stripeInvoice) {\r\n  const [invoices] = await promisePool.query(\r\n    'SELECT * FROM invoices WHERE stripe_invoice_id = ?',\r\n    [stripeInvoice.id]\r\n  );\r\n  \r\n  if (invoices.length > 0) {\r\n    const invoice = invoices[0];\r\n    await promisePool.query(\r\n      'UPDATE invoices SET status = \"failed\" WHERE id = ?',\r\n      [invoice.id]\r\n    );\r\n    \r\n    await promisePool.query(`\r\n      INSERT INTO billing_events (church_id, event_type, reference_id, data)\r\n      VALUES (?, 'invoice_failed', ?, ?)\r\n    `, [invoice.church_id, invoice.id, JSON.stringify({ stripe_invoice_id: stripeInvoice.id })]);\r\n  }\r\n}\r\n\r\nasync function handleSubscriptionDeleted(stripeSubscription) {\r\n  const [subscriptions] = await promisePool.query(\r\n    'SELECT * FROM subscriptions WHERE stripe_subscription_id = ?',\r\n    [stripeSubscription.id]\r\n  );\r\n  \r\n  if (subscriptions.length > 0) {\r\n    const subscription = subscriptions[0];\r\n    await promisePool.query(\r\n      'UPDATE subscriptions SET status = \"cancelled\" WHERE id = ?',\r\n      [subscription.id]\r\n    );\r\n    \r\n    await promisePool.query(`\r\n      INSERT INTO billing_events (church_id, event_type, reference_id, data)\r\n      VALUES (?, 'subscription_cancelled', ?, ?)\r\n    `, [subscription.church_id, subscription.id, JSON.stringify({ stripe_subscription_id: stripeSubscription.id })]);\r\n  }\r\n}\r\n\r\n// GET /api/billing/dashboard/:churchId - Get billing dashboard data\r\nrouter.get('/dashboard/:churchId', requireAuth, async (req, res) => {\r\n  try {\r\n    const { churchId } = req.params;\r\n    const userId = req.user?.id;\r\n    \r\n    // Basic authorization: users can only access their own church data\r\n    // For now, allow access if churchId matches userId (simplified)\r\n    if (!userId) {\r\n      return res.status(401).json({ error: 'User not authenticated' });\r\n    }\r\n\r\n    console.log(`User ${userId} requesting billing dashboard for church ${churchId}`);\r\n    \r\n    // Get current subscription\r\n    const [subscriptions] = await promisePool.query(`\r\n      SELECT s.*, bp.name as plan_name, bp.plan_code, bp.features\r\n      FROM subscriptions s\r\n      LEFT JOIN billing_plans bp ON s.plan_id = bp.id\r\n      WHERE s.church_id = ? AND s.status = 'active'\r\n      ORDER BY s.created_at DESC\r\n      LIMIT 1\r\n    `, [churchId]);\r\n    \r\n    // Get recent invoices\r\n    const [recentInvoices] = await promisePool.query(`\r\n      SELECT * FROM invoices \r\n      WHERE church_id = ? \r\n      ORDER BY date DESC \r\n      LIMIT 5\r\n    `, [churchId]);\r\n    \r\n    // Get payment method\r\n    const [paymentMethods] = await promisePool.query(`\r\n      SELECT * FROM payment_methods \r\n      WHERE church_id = ? AND is_default = TRUE\r\n      LIMIT 1\r\n    `, [churchId]);\r\n    \r\n    // If no data exists, return empty/default data rather than error\r\n    res.json({\r\n      subscription: subscriptions[0] || null,\r\n      recentInvoices: cleanRecords(recentInvoices) || [],\r\n      paymentMethod: paymentMethods[0] || null,\r\n      usage: {\r\n        // Add usage statistics here\r\n        users: 0,\r\n        records: 0,\r\n        // etc.\r\n      }\r\n    });\r\n    \r\n  } catch (error) {\r\n    console.error('Error fetching billing dashboard:', error);\r\n    res.status(500).json({ error: 'Failed to fetch dashboard data' });\r\n  }\r\n});\r\n\r\nmodule.exports = router;\r\n"
    },
    "complexity": {
      "totalLines": 615,
      "codeLines": 469,
      "commentLines": 50,
      "commentRatio": 0.09633911368015415,
      "averageLineLength": 37.40655105973025
    },
    "lastAnalyzed": "2025-07-28T07:20:00.423Z"
  },
  "contentHash": "45a7565c182a52961adc5f8f9002f78f54f78855d901c7ca645a0aead071497a",
  "discoveredAt": "2025-07-28T07:20:00.424Z"
}