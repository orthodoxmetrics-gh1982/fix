{
  "id": "4ef3e2cce24f",
  "originalPath": "/var/www/orthodox-church-mgmt/orthodoxmetrics/prod/server/utils/omaiCommandExecutor.js",
  "relativePath": "server/utils/omaiCommandExecutor.js",
  "name": "omaiCommandExecutor.js",
  "extension": ".js",
  "size": 14369,
  "modified": "2025-07-26T04:57:09.365Z",
  "created": "2025-07-26T04:57:07.824Z",
  "classification": {
    "type": "Server Scripts",
    "category": "Backend > Server",
    "confidence": 3
  },
  "metadata": {
    "fileStats": {
      "lines": 498,
      "characters": 14369,
      "words": 1355
    },
    "classification": {
      "type": "Server Scripts",
      "category": "Backend > Server",
      "confidence": 3
    },
    "dependencies": [
      {
        "type": "npm_package",
        "name": "fs",
        "line": 1
      },
      {
        "type": "npm_package",
        "name": "path",
        "line": 2
      },
      {
        "type": "npm_package",
        "name": "child_process",
        "line": 3
      },
      {
        "type": "npm_package",
        "name": "js-yaml",
        "line": 4
      },
      {
        "type": "npm_package",
        "name": "crypto",
        "line": 5
      }
    ],
    "security": {
      "findings": [
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 292,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 311,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 328,
          "redacted": true
        }
      ],
      "hasSecurityIssues": true,
      "redactedContent": "const fs = require('fs').promises;\r\nconst path = require('path');\r\nconst { execSync, spawn } = require('child_process');\r\nconst yaml = require('js-yaml');\r\nconst crypto = require('crypto');\r\nconst logger = require('./logger');\r\n\r\nclass OMAICommandExecutor {\r\n  constructor() {\r\n    this.configPath = path.join(process.cwd(), 'omai_commands.yaml');\r\n    this.config = null;\r\n    this.memoryCache = new Map();\r\n    this.commandHistory = [];\r\n    this.handsonMode = false;\r\n    this.logFile = '/var/log/omai/executed.log';\r\n    this.cacheFile = '/var/log/omai/command_cache.json';\r\n    this.initialized = false;\r\n  }\r\n\r\n  /**\r\n   * Initialize the OMAI Command Executor\r\n   */\r\n  async initialize() {\r\n    try {\r\n      await this.ensureLogDirectory();\r\n      await this.loadConfig();\r\n      await this.loadMemoryCache();\r\n      this.initialized = true;\r\n      logger.info('OMAI Command Executor initialized successfully');\r\n    } catch (error) {\r\n      logger.error('Failed to initialize OMAI Command Executor:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Ensure log directory exists\r\n   */\r\n  async ensureLogDirectory() {\r\n    const logDir = path.dirname(this.logFile);\r\n    try {\r\n      await fs.mkdir(logDir, { recursive: true, mode: 0o755 });\r\n    } catch (error) {\r\n      if (error.code !== 'EEXIST') {\r\n        throw error;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Load OMAI commands configuration\r\n   */\r\n  async loadConfig() {\r\n    try {\r\n      const configContent = await fs.readFile(this.configPath, 'utf8');\r\n      this.config = yaml.load(configContent);\r\n      logger.info('OMAI commands configuration loaded');\r\n    } catch (error) {\r\n      logger.error('Failed to load OMAI commands configuration:', error);\r\n      throw new Error('Could not load omai_commands.yaml configuration file');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Load memory cache from file\r\n   */\r\n  async loadMemoryCache() {\r\n    try {\r\n      const cacheContent = await fs.readFile(this.cacheFile, 'utf8');\r\n      const cacheData = JSON.parse(cacheContent);\r\n      \r\n      // Load cache entries\r\n      for (const [key, entry] of Object.entries(cacheData.commands || {})) {\r\n        if (this.isCacheEntryValid(entry)) {\r\n          this.memoryCache.set(key, entry);\r\n        }\r\n      }\r\n      \r\n      logger.info(`Loaded ${this.memoryCache.size} cached commands`);\r\n    } catch (error) {\r\n      if (error.code !== 'ENOENT') {\r\n        logger.warn('Could not load memory cache:', error.message);\r\n      }\r\n      // Create empty cache if file doesn't exist\r\n      this.memoryCache = new Map();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if cache entry is still valid\r\n   */\r\n  isCacheEntryValid(entry) {\r\n    const cacheHours = this.config?.memory?.cache_duration_hours || 24;\r\n    const cacheMs = cacheHours * 60 * 60 * 1000;\r\n    const now = Date.now();\r\n    \r\n    return (now - entry.timestamp) < cacheMs;\r\n  }\r\n\r\n  /**\r\n   * Save memory cache to file\r\n   */\r\n  async saveMemoryCache() {\r\n    try {\r\n      const cacheData = {\r\n        version: '1.0.0',\r\n        updated_at: new Date().toISOString(),\r\n        commands: {}\r\n      };\r\n      \r\n      // Convert Map to object for JSON serialization\r\n      for (const [key, entry] of this.memoryCache.entries()) {\r\n        cacheData.commands[key] = entry;\r\n      }\r\n      \r\n      await fs.writeFile(this.cacheFile, JSON.stringify(cacheData, null, 2));\r\n    } catch (error) {\r\n      logger.warn('Could not save memory cache:', error.message);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Enable hands-on mode\r\n   */\r\n  enableHandsOnMode() {\r\n    this.handsonMode = true;\r\n    logger.info('OMAI Hands-On Mode enabled');\r\n  }\r\n\r\n  /**\r\n   * Disable hands-on mode\r\n   */\r\n  disableHandsOnMode() {\r\n    this.handsonMode = false;\r\n    logger.info('OMAI Hands-On Mode disabled');\r\n  }\r\n\r\n  /**\r\n   * Parse natural language instruction and find matching command\r\n   */\r\n  async parseInstruction(instruction) {\r\n    if (!this.initialized) {\r\n      await this.initialize();\r\n    }\r\n    \r\n    const normalizedInstruction = instruction.toLowerCase().trim();\r\n    \r\n    // Check memory cache first\r\n    const cacheKey = this.generateCacheKey(normalizedInstruction);\r\n    if (this.memoryCache.has(cacheKey)) {\r\n      const cachedEntry = this.memoryCache.get(cacheKey);\r\n      cachedEntry.frequency++;\r\n      cachedEntry.last_used = Date.now();\r\n      await this.saveMemoryCache();\r\n      \r\n      logger.info(`Found cached command for: \"${instruction}\"`);\r\n      return cachedEntry.command_info;\r\n    }\r\n    \r\n    // Search through command categories\r\n    for (const [categoryName, category] of Object.entries(this.config.categories || {})) {\r\n      for (const [commandName, commandInfo] of Object.entries(category.commands || {})) {\r\n        for (const pattern of commandInfo.patterns || []) {\r\n          if (this.matchesPattern(normalizedInstruction, pattern.toLowerCase())) {\r\n            await this.updateMemoryCache(normalizedInstruction, commandName, commandInfo);\r\n            return { ...commandInfo, name: commandName, category: categoryName };\r\n          }\r\n        }\r\n      }\r\n    }\r\n    \r\n    // Check aliases\r\n    for (const [alias, commandName] of Object.entries(this.config.aliases || {})) {\r\n      if (normalizedInstruction.includes(alias)) {\r\n        const commandInfo = this.findCommandByName(commandName);\r\n        if (commandInfo) {\r\n          await this.updateMemoryCache(normalizedInstruction, commandName, commandInfo);\r\n          return { ...commandInfo, name: commandName, alias: alias };\r\n        }\r\n      }\r\n    }\r\n    \r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Check if instruction matches pattern\r\n   */\r\n  matchesPattern(instruction, pattern) {\r\n    // Simple fuzzy matching - can be enhanced with better NLP\r\n    const instructionWords = instruction.split(/\\s+/);\r\n    const patternWords = pattern.split(/\\s+/);\r\n    \r\n    // Check if at least 70% of pattern words are in instruction\r\n    const matches = patternWords.filter(word => \r\n      instructionWords.some(instrWord => \r\n        instrWord.includes(word) || word.includes(instrWord)\r\n      )\r\n    );\r\n    \r\n    return matches.length / patternWords.length >= 0.7;\r\n  }\r\n\r\n  /**\r\n   * Find command by name across all categories\r\n   */\r\n  findCommandByName(commandName) {\r\n    for (const category of Object.values(this.config.categories || {})) {\r\n      if (category.commands && category.commands[commandName]) {\r\n        return category.commands[commandName];\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Update memory cache with command usage\r\n   */\r\n  async updateMemoryCache(instruction, commandName, commandInfo) {\r\n    const cacheKey = this.generateCacheKey(instruction);\r\n    const frequencyThreshold = this.config?.memory?.frequency_threshold || 3;\r\n    \r\n    if (this.memoryCache.has(cacheKey)) {\r\n      const entry = this.memoryCache.get(cacheKey);\r\n      entry.frequency++;\r\n      entry.last_used = Date.now();\r\n    } else {\r\n      this.memoryCache.set(cacheKey, {\r\n        instruction,\r\n        command_name: commandName,\r\n        command_info: commandInfo,\r\n        frequency: 1,\r\n        timestamp: Date.now(),\r\n        last_used: Date.now()\r\n      });\r\n    }\r\n    \r\n    // Check if we need to save cache (auto-cache after threshold)\r\n    const entry = this.memoryCache.get(cacheKey);\r\n    if (entry.frequency >= frequencyThreshold) {\r\n      await this.saveMemoryCache();\r\n      logger.info(`Auto-cached command \"${commandName}\" after ${entry.frequency} uses`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generate cache key for instruction\r\n   */\r\n  generateCacheKey(instruction) {\r\n    return crypto.createHash('md5').update(instruction).digest('hex').substring(0, 16);\r\n  }\r\n\r\n  /**\r\n   * Execute a command with safety checks\r\n   */\r\n  async executeCommand(commandInfo, options = {}) {\r\n    if (!this.initialized) {\r\n      await this.initialize();\r\n    }\r\n    \r\n    if (!this.handsonMode && !options.force) {\r\n      throw new Error('Command execution requires hands-on mode or force flag');\r\n    }\r\n    \r\n    const {\r\n      command,\r\n      safety = 'moderate',\r\n      requires_sudo = false,\r\n      trusted = false,\r\n      description = 'No description',\r\n      name = 'unknown'\r\n    } = commandInfo;\r\n    \r\n    // Safety checks\r\n    if (safety === 'dangerous' && !options.force) {\r\n      throw new Error('Dangerous command requires --force flag');\r\n    }\r\n    \r\n    if (requires_sudo && !trusted && !options.confirmSudo) {\r\n      throw new Error('Sudo command requires explicit confirmation');\r\n    }\r\n    \r\n    // Log command execution attempt\r\n    await this.logCommand({\r\n      command,\r\n      name,\r\n      description,\r\n      safety,\r\n      requires_sudo,\r\n      trusted,\r\n      timestamp: new Date().toISOString(),\r\n      user: process.env.[REDACTED] || 'unknown',\r\n      status: 'attempting'\r\n    });\r\n    \r\n    try {\r\n      logger.info(`Executing OMAI command: ${name} - ${description}`);\r\n      logger.info(`Command: ${command}`);\r\n      \r\n      const result = await this.runCommand(command, options);\r\n      \r\n      // Log successful execution\r\n      await this.logCommand({\r\n        command,\r\n        name,\r\n        description,\r\n        safety,\r\n        requires_sudo,\r\n        trusted,\r\n        timestamp: new Date().toISOString(),\r\n        user: process.env.[REDACTED] || 'unknown',\r\n        status: 'success',\r\n        output: result.stdout,\r\n        error: result.stderr\r\n      });\r\n      \r\n      return result;\r\n    } catch (error) {\r\n      // Log failed execution\r\n      await this.logCommand({\r\n        command,\r\n        name,\r\n        description,\r\n        safety,\r\n        requires_sudo,\r\n        trusted,\r\n        timestamp: new Date().toISOString(),\r\n        user: process.env.[REDACTED] || 'unknown',\r\n        status: 'failed',\r\n        error: error.message\r\n      });\r\n      \r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Run the actual command\r\n   */\r\n  async runCommand(command, options = {}) {\r\n    const timeout = options.timeout || this.config?.settings?.timeout_seconds * 1000 || 300000;\r\n    const workingDir = options.cwd || this.config?.settings?.working_directory || process.cwd();\r\n    \r\n    return new Promise((resolve, reject) => {\r\n      const child = spawn('bash', ['-c', command], {\r\n        cwd: workingDir,\r\n        timeout: timeout,\r\n        stdio: 'pipe'\r\n      });\r\n      \r\n      let stdout = '';\r\n      let stderr = '';\r\n      \r\n      child.stdout.on('data', (data) => {\r\n        stdout += data.toString();\r\n      });\r\n      \r\n      child.stderr.on('data', (data) => {\r\n        stderr += data.toString();\r\n      });\r\n      \r\n      child.on('close', (code) => {\r\n        if (code === 0) {\r\n          resolve({ stdout, stderr, exitCode: code });\r\n        } else {\r\n          reject(new Error(`Command failed with exit code ${code}: ${stderr}`));\r\n        }\r\n      });\r\n      \r\n      child.on('error', (error) => {\r\n        reject(error);\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Log command execution to file\r\n   */\r\n  async logCommand(logEntry) {\r\n    try {\r\n      const logLine = JSON.stringify(logEntry) + '\\n';\r\n      await fs.appendFile(this.logFile, logLine);\r\n    } catch (error) {\r\n      logger.warn('Could not write to command log:', error.message);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get command history\r\n   */\r\n  async getCommandHistory(limit = 50) {\r\n    try {\r\n      const logContent = await fs.readFile(this.logFile, 'utf8');\r\n      const lines = logContent.trim().split('\\n').filter(line => line.trim());\r\n      \r\n      const history = lines\r\n        .slice(-limit)\r\n        .map(line => {\r\n          try {\r\n            return JSON.parse(line);\r\n          } catch {\r\n            return null;\r\n          }\r\n        })\r\n        .filter(entry => entry !== null)\r\n        .reverse(); // Most recent first\r\n      \r\n      return history;\r\n    } catch (error) {\r\n      logger.warn('Could not read command history:', error.message);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get memory cache statistics\r\n   */\r\n  getMemoryStats() {\r\n    const stats = {\r\n      total_cached_commands: this.memoryCache.size,\r\n      cache_file: this.cacheFile,\r\n      most_used_commands: [],\r\n      recent_commands: []\r\n    };\r\n    \r\n    // Get most used commands\r\n    const sortedByFrequency = Array.from(this.memoryCache.entries())\r\n      .sort(([,a], [,b]) => b.frequency - a.frequency)\r\n      .slice(0, 10);\r\n    \r\n    stats.most_used_commands = sortedByFrequency.map(([key, entry]) => ({\r\n      instruction: entry.instruction,\r\n      command: entry.command_name,\r\n      frequency: entry.frequency,\r\n      last_used: new Date(entry.last_used).toISOString()\r\n    }));\r\n    \r\n    // Get recent commands\r\n    const sortedByRecent = Array.from(this.memoryCache.entries())\r\n      .sort(([,a], [,b]) => b.last_used - a.last_used)\r\n      .slice(0, 10);\r\n    \r\n    stats.recent_commands = sortedByRecent.map(([key, entry]) => ({\r\n      instruction: entry.instruction,\r\n      command: entry.command_name,\r\n      last_used: new Date(entry.last_used).toISOString()\r\n    }));\r\n    \r\n    return stats;\r\n  }\r\n\r\n  /**\r\n   * List available commands\r\n   */\r\n  listCommands() {\r\n    const commands = [];\r\n    \r\n    for (const [categoryName, category] of Object.entries(this.config?.categories || {})) {\r\n      for (const [commandName, commandInfo] of Object.entries(category.commands || {})) {\r\n        commands.push({\r\n          name: commandName,\r\n          category: categoryName,\r\n          description: commandInfo.description,\r\n          safety: commandInfo.safety,\r\n          patterns: commandInfo.patterns,\r\n          requires_sudo: commandInfo.requires_sudo || false,\r\n          trusted: commandInfo.trusted || false\r\n        });\r\n      }\r\n    }\r\n    \r\n    return commands;\r\n  }\r\n\r\n  /**\r\n   * Process instruction and execute if in hands-on mode\r\n   */\r\n  async processInstruction(instruction, options = {}) {\r\n    const commandInfo = await this.parseInstruction(instruction);\r\n    \r\n    if (!commandInfo) {\r\n      throw new Error(`No command found for instruction: \"${instruction}\"`);\r\n    }\r\n    \r\n    if (this.handsonMode || options.force) {\r\n      return await this.executeCommand(commandInfo, options);\r\n    } else {\r\n      return {\r\n        found: true,\r\n        command: commandInfo,\r\n        message: 'Command found but not executed (hands-on mode disabled)',\r\n        suggestion: 'Use --mode hands-on to enable command execution'\r\n      };\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = OMAICommandExecutor; "
    },
    "complexity": {
      "totalLines": 498,
      "codeLines": 359,
      "commentLines": 75,
      "commentRatio": 0.1728110599078341,
      "averageLineLength": 31.35483870967742
    },
    "lastAnalyzed": "2025-07-28T07:20:01.263Z"
  },
  "contentHash": "8c5e91e2728243818ba014231ba5f398e9d0c7f5591a937c2f4bd78c00837571",
  "discoveredAt": "2025-07-28T07:20:01.263Z"
}