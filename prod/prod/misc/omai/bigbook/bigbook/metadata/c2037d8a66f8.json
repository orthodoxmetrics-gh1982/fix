{
  "id": "c2037d8a66f8",
  "originalPath": "/var/www/orthodox-church-mgmt/orthodoxmetrics/prod/server/models/kanbanTask.js",
  "relativePath": "server/models/kanbanTask.js",
  "name": "kanbanTask.js",
  "extension": ".js",
  "size": 23687,
  "modified": "2025-07-16T17:41:37.382Z",
  "created": "2025-07-15T19:59:36.839Z",
  "classification": {
    "type": "Server Scripts",
    "category": "Backend > Server",
    "confidence": 3
  },
  "metadata": {
    "fileStats": {
      "lines": 796,
      "characters": 23687,
      "words": 2456
    },
    "classification": {
      "type": "Server Scripts",
      "category": "Backend > Server",
      "confidence": 3
    },
    "dependencies": [
      {
        "type": "npm_package",
        "name": "mysql2/promise",
        "line": 1
      }
    ],
    "security": {
      "findings": [
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 11,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 12,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 13,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 14,
          "redacted": true
        }
      ],
      "hasSecurityIssues": true,
      "redactedContent": "const mysql = require('mysql2/promise');\r\n\r\nclass KanbanTask {\r\n  constructor() {\r\n    this.connection = null;\r\n  }\r\n\r\n  async getConnection() {\r\n    if (!this.connection) {\r\n      this.connection = await mysql.createConnection({\r\n        host: process.env.[REDACTED] || 'localhost',\r\n        user: process.env.[REDACTED] || 'root',\r\n        password: process.env.[REDACTED] || '',\r\n        database: process.env.[REDACTED] || 'orthodoxmetrics'\r\n      });\r\n    }\r\n    return this.connection;\r\n  }\r\n\r\n  async closeConnection() {\r\n    if (this.connection) {\r\n      await this.connection.end();\r\n      this.connection = null;\r\n    }\r\n  }\r\n\r\n  // Helper function to check board access\r\n  async checkBoardAccess(boardId, userId, requiredRole = 'member') {\r\n    const connection = await this.getConnection();\r\n    \r\n    const [boardAccess] = await connection.execute(`\r\n      SELECT \r\n        b.id,\r\n        b.created_by,\r\n        bm.role as user_role\r\n      FROM kanban_boards b\r\n      LEFT JOIN kanban_board_members bm ON b.id = bm.board_id AND bm.user_id = ?\r\n      WHERE b.id = ? AND (bm.user_id = ? OR b.created_by = ?)\r\n        AND b.is_archived = FALSE\r\n    `, [userId, boardId, userId, userId]);\r\n\r\n    if (boardAccess.length === 0) {\r\n      return { hasAccess: false, role: null };\r\n    }\r\n\r\n    const userRole = boardAccess[0].user_role || (boardAccess[0].created_by === userId ? 'owner' : null);\r\n    const roleHierarchy = { 'viewer': 1, 'member': 2, 'admin': 3, 'owner': 4 };\r\n    \r\n    const hasAccess = roleHierarchy[userRole] >= roleHierarchy[requiredRole];\r\n    return { hasAccess, role: userRole };\r\n  }\r\n\r\n  // Get all tasks for a board\r\n  async getBoardTasks(boardId, userId, filters = {}) {\r\n    const connection = await this.getConnection();\r\n\r\n    // Check access\r\n    const { hasAccess } = await this.checkBoardAccess(boardId, userId, 'viewer');\r\n    if (!hasAccess) {\r\n      throw new Error('Access denied to this board');\r\n    }\r\n\r\n    let whereConditions = ['t.board_id = ?'];\r\n    let queryParams = [boardId];\r\n\r\n    // Apply filters\r\n    if (filters.assigned_to) {\r\n      whereConditions.push('t.assigned_to = ?');\r\n      queryParams.push(filters.assigned_to);\r\n    }\r\n\r\n    if (filters.priority) {\r\n      whereConditions.push('t.priority = ?');\r\n      queryParams.push(filters.priority);\r\n    }\r\n\r\n    if (filters.due_this_week) {\r\n      whereConditions.push('t.due_date BETWEEN CURDATE() AND DATE_ADD(CURDATE(), INTERVAL 7 DAY)');\r\n    }\r\n\r\n    if (filters.overdue) {\r\n      whereConditions.push('t.due_date < CURDATE() AND t.completed_at IS NULL');\r\n    }\r\n\r\n    if (filters.column_id) {\r\n      whereConditions.push('t.column_id = ?');\r\n      queryParams.push(filters.column_id);\r\n    }\r\n\r\n    const whereClause = whereConditions.length > 0 ? `WHERE ${whereConditions.join(' AND ')}` : '';\r\n\r\n    // Get tasks with user information and labels\r\n    const [tasks] = await connection.execute(`\r\n      SELECT \r\n        t.id,\r\n        t.column_id,\r\n        t.title,\r\n        t.description,\r\n        t.position,\r\n        t.priority,\r\n        t.due_date,\r\n        t.assigned_to,\r\n        t.created_by,\r\n        t.created_at,\r\n        t.updated_at,\r\n        t.completed_at,\r\n        t.estimated_hours,\r\n        t.actual_hours,\r\n        t.task_color,\r\n        u_assigned.username as assigned_to_name,\r\n        u_assigned.email as assigned_to_email,\r\n        u_created.username as created_by_name,\r\n        c.name as column_name,\r\n        c.color as column_color\r\n      FROM kanban_tasks t\r\n      LEFT JOIN users u_assigned ON t.assigned_to = u_assigned.id\r\n      LEFT JOIN users u_created ON t.created_by = u_created.id\r\n      LEFT JOIN kanban_columns c ON t.column_id = c.id\r\n      ${whereClause}\r\n      ORDER BY c.position ASC, t.position ASC\r\n    `, queryParams);\r\n\r\n    // Get labels for each task\r\n    const [taskLabels] = await connection.execute(`\r\n      SELECT \r\n        tl.task_id,\r\n        l.id as label_id,\r\n        l.name as label_name,\r\n        l.color as label_color\r\n      FROM kanban_task_labels tl\r\n      JOIN kanban_labels l ON tl.label_id = l.id\r\n      JOIN kanban_tasks t ON tl.task_id = t.id\r\n      WHERE t.board_id = ?\r\n    `, [boardId]);\r\n\r\n    // Group labels by task\r\n    const taskLabelsMap = {};\r\n    taskLabels.forEach(label => {\r\n      if (!taskLabelsMap[label.task_id]) {\r\n        taskLabelsMap[label.task_id] = [];\r\n      }\r\n      taskLabelsMap[label.task_id].push({\r\n        id: label.label_id,\r\n        name: label.label_name,\r\n        color: label.label_color\r\n      });\r\n    });\r\n\r\n    // Add labels to tasks\r\n    const tasksWithLabels = tasks.map(task => ({\r\n      ...task,\r\n      labels: taskLabelsMap[task.id] || []\r\n    }));\r\n\r\n    return tasksWithLabels;\r\n  }\r\n\r\n  // Get task by ID with full details\r\n  async getTaskById(taskId, userId) {\r\n    const connection = await this.getConnection();\r\n\r\n    // Get task and check board access\r\n    const [taskInfo] = await connection.execute(`\r\n      SELECT \r\n        t.id,\r\n        t.board_id,\r\n        t.column_id,\r\n        t.title,\r\n        t.description,\r\n        t.position,\r\n        t.priority,\r\n        t.due_date,\r\n        t.assigned_to,\r\n        t.created_by,\r\n        t.created_at,\r\n        t.updated_at,\r\n        t.completed_at,\r\n        t.estimated_hours,\r\n        t.actual_hours,\r\n        t.task_color,\r\n        u_assigned.username as assigned_to_name,\r\n        u_assigned.email as assigned_to_email,\r\n        u_created.username as created_by_name,\r\n        c.name as column_name,\r\n        b.name as board_name\r\n      FROM kanban_tasks t\r\n      LEFT JOIN users u_assigned ON t.assigned_to = u_assigned.id\r\n      LEFT JOIN users u_created ON t.created_by = u_created.id\r\n      LEFT JOIN kanban_columns c ON t.column_id = c.id\r\n      LEFT JOIN kanban_boards b ON t.board_id = b.id\r\n      WHERE t.id = ?\r\n    `, [taskId]);\r\n\r\n    if (taskInfo.length === 0) {\r\n      throw new Error('Task not found');\r\n    }\r\n\r\n    const task = taskInfo[0];\r\n\r\n    // Check board access\r\n    const { hasAccess } = await this.checkBoardAccess(task.board_id, userId, 'viewer');\r\n    if (!hasAccess) {\r\n      throw new Error('Access denied to this board');\r\n    }\r\n\r\n    // Get task labels\r\n    const [labels] = await connection.execute(`\r\n      SELECT \r\n        l.id,\r\n        l.name,\r\n        l.color\r\n      FROM kanban_task_labels tl\r\n      JOIN kanban_labels l ON tl.label_id = l.id\r\n      WHERE tl.task_id = ?\r\n    `, [taskId]);\r\n\r\n    // Get task comments\r\n    const [comments] = await connection.execute(`\r\n      SELECT \r\n        c.id,\r\n        c.comment,\r\n        c.created_at,\r\n        c.updated_at,\r\n        u.username,\r\n        u.email\r\n      FROM kanban_task_comments c\r\n      JOIN users u ON c.user_id = u.id\r\n      WHERE c.task_id = ?\r\n      ORDER BY c.created_at ASC\r\n    `, [taskId]);\r\n\r\n    // Get task attachments\r\n    const [attachments] = await connection.execute(`\r\n      SELECT \r\n        a.id,\r\n        a.filename,\r\n        a.original_filename,\r\n        a.file_path,\r\n        a.file_size,\r\n        a.mime_type,\r\n        a.uploaded_at,\r\n        u.username as uploaded_by_name\r\n      FROM kanban_task_attachments a\r\n      JOIN users u ON a.uploaded_by = u.id\r\n      WHERE a.task_id = ?\r\n      ORDER BY a.uploaded_at DESC\r\n    `, [taskId]);\r\n\r\n    // Get activity history\r\n    const [activity] = await connection.execute(`\r\n      SELECT \r\n        a.id,\r\n        a.action_type,\r\n        a.description,\r\n        a.old_value,\r\n        a.new_value,\r\n        a.created_at,\r\n        u.username\r\n      FROM kanban_task_activity a\r\n      JOIN users u ON a.user_id = u.id\r\n      WHERE a.task_id = ?\r\n      ORDER BY a.created_at DESC\r\n      LIMIT 50\r\n    `, [taskId]);\r\n\r\n    return {\r\n      ...task,\r\n      labels,\r\n      comments,\r\n      attachments,\r\n      activity\r\n    };\r\n  }\r\n\r\n  // Create new task\r\n  async createTask(taskData, creatorId) {\r\n    const connection = await this.getConnection();\r\n\r\n    const {\r\n      board_id,\r\n      column_id,\r\n      title,\r\n      description = '',\r\n      priority = 'medium',\r\n      due_date,\r\n      assigned_to,\r\n      estimated_hours,\r\n      task_color,\r\n      labels = []\r\n    } = taskData;\r\n\r\n    if (!board_id || !column_id || !title || title.trim().length === 0) {\r\n      throw new Error('Board ID, Column ID, and title are required');\r\n    }\r\n\r\n    // Check board access\r\n    const { hasAccess } = await this.checkBoardAccess(board_id, creatorId, 'member');\r\n    if (!hasAccess) {\r\n      throw new Error('Access denied to this board');\r\n    }\r\n\r\n    try {\r\n      await connection.beginTransaction();\r\n\r\n      // Get next position in the column\r\n      const [positionResult] = await connection.execute(`\r\n        SELECT COALESCE(MAX(position), -1) + 1 as next_position\r\n        FROM kanban_tasks\r\n        WHERE column_id = ?\r\n      `, [column_id]);\r\n\r\n      const position = positionResult[0].next_position;\r\n\r\n      // Create the task\r\n      const [taskResult] = await connection.execute(`\r\n        INSERT INTO kanban_tasks (\r\n          board_id, column_id, title, description, position, priority,\r\n          due_date, assigned_to, created_by, estimated_hours, task_color\r\n        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\r\n      `, [\r\n        board_id, column_id, title.trim(), description, position, priority,\r\n        due_date || null, assigned_to || null, creatorId, \r\n        estimated_hours || null, task_color || null\r\n      ]);\r\n\r\n      const taskId = taskResult.insertId;\r\n\r\n      // Add labels if provided\r\n      if (labels.length > 0) {\r\n        for (const labelId of labels) {\r\n          await connection.execute(`\r\n            INSERT INTO kanban_task_labels (task_id, label_id)\r\n            VALUES (?, ?)\r\n          `, [taskId, labelId]);\r\n        }\r\n      }\r\n\r\n      // Log activity\r\n      await connection.execute(`\r\n        INSERT INTO kanban_task_activity (task_id, user_id, action_type, description)\r\n        VALUES (?, ?, 'created', ?)\r\n      `, [taskId, creatorId, `Created task \"${title.trim()}\"`]);\r\n\r\n      await connection.commit();\r\n\r\n      return {\r\n        id: taskId,\r\n        title: title.trim(),\r\n        position,\r\n        created_by: creatorId\r\n      };\r\n\r\n    } catch (error) {\r\n      await connection.rollback();\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Update task\r\n  async updateTask(taskId, updates, userId) {\r\n    const connection = await this.getConnection();\r\n\r\n    // Get task and check board access\r\n    const [taskInfo] = await connection.execute(`\r\n      SELECT board_id, title as old_title, assigned_to as old_assigned_to, \r\n             priority as old_priority, due_date as old_due_date\r\n      FROM kanban_tasks\r\n      WHERE id = ?\r\n    `, [taskId]);\r\n\r\n    if (taskInfo.length === 0) {\r\n      throw new Error('Task not found');\r\n    }\r\n\r\n    const { hasAccess } = await this.checkBoardAccess(taskInfo[0].board_id, userId, 'member');\r\n    if (!hasAccess) {\r\n      throw new Error('Access denied to this board');\r\n    }\r\n\r\n    const {\r\n      title,\r\n      description,\r\n      priority,\r\n      due_date,\r\n      assigned_to,\r\n      estimated_hours,\r\n      actual_hours,\r\n      task_color,\r\n      labels = []\r\n    } = updates;\r\n\r\n    try {\r\n      await connection.beginTransaction();\r\n\r\n      // Update the task\r\n      await connection.execute(`\r\n        UPDATE kanban_tasks \r\n        SET title = ?, description = ?, priority = ?, due_date = ?, \r\n            assigned_to = ?, estimated_hours = ?, actual_hours = ?, \r\n            task_color = ?, updated_at = CURRENT_TIMESTAMP\r\n        WHERE id = ?\r\n      `, [\r\n        title, description, priority, due_date || null, \r\n        assigned_to || null, estimated_hours || null, actual_hours || null, \r\n        task_color || null, taskId\r\n      ]);\r\n\r\n      // Update labels\r\n      await connection.execute(`DELETE FROM kanban_task_labels WHERE task_id = ?`, [taskId]);\r\n      \r\n      if (labels.length > 0) {\r\n        for (const labelId of labels) {\r\n          await connection.execute(`\r\n            INSERT INTO kanban_task_labels (task_id, label_id)\r\n            VALUES (?, ?)\r\n          `, [taskId, labelId]);\r\n        }\r\n      }\r\n\r\n      // Log significant changes\r\n      const activities = [];\r\n      \r\n      if (title !== taskInfo[0].old_title) {\r\n        activities.push(`Updated task title from \"${taskInfo[0].old_title}\" to \"${title}\"`);\r\n      }\r\n\r\n      if (assigned_to !== taskInfo[0].old_assigned_to) {\r\n        activities.push('Task assignment changed');\r\n      }\r\n\r\n      if (priority !== taskInfo[0].old_priority) {\r\n        activities.push(`Priority changed from ${taskInfo[0].old_priority} to ${priority}`);\r\n      }\r\n\r\n      if (due_date !== taskInfo[0].old_due_date) {\r\n        activities.push('Due date updated');\r\n      }\r\n\r\n      // Log activities\r\n      for (const activity of activities) {\r\n        await connection.execute(`\r\n          INSERT INTO kanban_task_activity (task_id, user_id, action_type, description)\r\n          VALUES (?, ?, 'updated', ?)\r\n        `, [taskId, userId, activity]);\r\n      }\r\n\r\n      await connection.commit();\r\n\r\n      return { success: true };\r\n\r\n    } catch (error) {\r\n      await connection.rollback();\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Move task to different column/position\r\n  async moveTask(taskId, newColumnId, newPosition, userId) {\r\n    const connection = await this.getConnection();\r\n\r\n    // Get task and check board access\r\n    const [taskInfo] = await connection.execute(`\r\n      SELECT t.board_id, t.column_id as old_column_id, t.position as old_position, t.title,\r\n             c.name as old_column_name\r\n      FROM kanban_tasks t\r\n      LEFT JOIN kanban_columns c ON t.column_id = c.id\r\n      WHERE t.id = ?\r\n    `, [taskId]);\r\n\r\n    if (taskInfo.length === 0) {\r\n      throw new Error('Task not found');\r\n    }\r\n\r\n    const { hasAccess } = await this.checkBoardAccess(taskInfo[0].board_id, userId, 'member');\r\n    if (!hasAccess) {\r\n      throw new Error('Access denied to this board');\r\n    }\r\n\r\n    try {\r\n      await connection.beginTransaction();\r\n\r\n      const oldColumnId = taskInfo[0].old_column_id;\r\n      const oldPosition = taskInfo[0].old_position;\r\n\r\n      // If moving to a different column\r\n      if (oldColumnId !== newColumnId) {\r\n        // Adjust positions in the old column (move tasks up to fill the gap)\r\n        await connection.execute(`\r\n          UPDATE kanban_tasks \r\n          SET position = position - 1\r\n          WHERE column_id = ? AND position > ?\r\n        `, [oldColumnId, oldPosition]);\r\n\r\n        // Adjust positions in the new column (make space for the moved task)\r\n        await connection.execute(`\r\n          UPDATE kanban_tasks \r\n          SET position = position + 1\r\n          WHERE column_id = ? AND position >= ?\r\n        `, [newColumnId, newPosition]);\r\n\r\n        // Move the task\r\n        await connection.execute(`\r\n          UPDATE kanban_tasks \r\n          SET column_id = ?, position = ?, updated_at = CURRENT_TIMESTAMP\r\n          WHERE id = ?\r\n        `, [newColumnId, newPosition, taskId]);\r\n\r\n        // Get new column name for activity log\r\n        const [newColumnInfo] = await connection.execute(`\r\n          SELECT name FROM kanban_columns WHERE id = ?\r\n        `, [newColumnId]);\r\n\r\n        // Log the move activity\r\n        await connection.execute(`\r\n          INSERT INTO kanban_task_activity (task_id, user_id, action_type, description)\r\n          VALUES (?, ?, 'moved', ?)\r\n        `, [taskId, userId, \r\n            `Moved task \"${taskInfo[0].title}\" from \"${taskInfo[0].old_column_name}\" to \"${newColumnInfo[0].name}\"`]);\r\n      } else {\r\n        // Moving within the same column\r\n        if (oldPosition !== newPosition) {\r\n          if (newPosition < oldPosition) {\r\n            // Moving up: shift tasks down\r\n            await connection.execute(`\r\n              UPDATE kanban_tasks \r\n              SET position = position + 1\r\n              WHERE column_id = ? AND position >= ? AND position < ?\r\n            `, [newColumnId, newPosition, oldPosition]);\r\n          } else {\r\n            // Moving down: shift tasks up\r\n            await connection.execute(`\r\n              UPDATE kanban_tasks \r\n              SET position = position - 1\r\n              WHERE column_id = ? AND position > ? AND position <= ?\r\n            `, [newColumnId, oldPosition, newPosition]);\r\n          }\r\n\r\n          // Update the task position\r\n          await connection.execute(`\r\n            UPDATE kanban_tasks \r\n            SET position = ?, updated_at = CURRENT_TIMESTAMP\r\n            WHERE id = ?\r\n          `, [newPosition, taskId]);\r\n        }\r\n      }\r\n\r\n      await connection.commit();\r\n\r\n      return { success: true };\r\n\r\n    } catch (error) {\r\n      await connection.rollback();\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Delete task\r\n  async deleteTask(taskId, userId) {\r\n    const connection = await this.getConnection();\r\n\r\n    // Get task and check permissions\r\n    const [taskInfo] = await connection.execute(`\r\n      SELECT board_id, column_id, position, title, created_by\r\n      FROM kanban_tasks\r\n      WHERE id = ?\r\n    `, [taskId]);\r\n\r\n    if (taskInfo.length === 0) {\r\n      throw new Error('Task not found');\r\n    }\r\n\r\n    const { hasAccess, role } = await this.checkBoardAccess(taskInfo[0].board_id, userId, 'member');\r\n    if (!hasAccess) {\r\n      throw new Error('Access denied to this board');\r\n    }\r\n\r\n    // Only task creator, board admin, or board owner can delete tasks\r\n    if (taskInfo[0].created_by !== userId && role !== 'admin' && role !== 'owner') {\r\n      throw new Error('Insufficient permissions to delete this task');\r\n    }\r\n\r\n    try {\r\n      await connection.beginTransaction();\r\n\r\n      // Log deletion activity before deleting\r\n      await connection.execute(`\r\n        INSERT INTO kanban_task_activity (task_id, user_id, action_type, description)\r\n        VALUES (?, ?, 'deleted', ?)\r\n      `, [taskId, userId, `Deleted task \"${taskInfo[0].title}\"`]);\r\n\r\n      // Delete the task (cascading deletes will handle related records)\r\n      await connection.execute(`DELETE FROM kanban_tasks WHERE id = ?`, [taskId]);\r\n\r\n      // Adjust positions in the column (move tasks up to fill the gap)\r\n      await connection.execute(`\r\n        UPDATE kanban_tasks \r\n        SET position = position - 1\r\n        WHERE column_id = ? AND position > ?\r\n      `, [taskInfo[0].column_id, taskInfo[0].position]);\r\n\r\n      await connection.commit();\r\n\r\n      return { success: true };\r\n\r\n    } catch (error) {\r\n      await connection.rollback();\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Add comment to task\r\n  async addComment(taskId, comment, userId) {\r\n    const connection = await this.getConnection();\r\n\r\n    if (!comment || comment.trim().length === 0) {\r\n      throw new Error('Comment cannot be empty');\r\n    }\r\n\r\n    // Check if user has access to the task's board\r\n    const [taskBoard] = await connection.execute(`\r\n      SELECT board_id, title FROM kanban_tasks WHERE id = ?\r\n    `, [taskId]);\r\n\r\n    if (taskBoard.length === 0) {\r\n      throw new Error('Task not found');\r\n    }\r\n\r\n    const { hasAccess } = await this.checkBoardAccess(taskBoard[0].board_id, userId, 'member');\r\n    if (!hasAccess) {\r\n      throw new Error('Access denied to this board');\r\n    }\r\n\r\n    try {\r\n      await connection.beginTransaction();\r\n\r\n      // Add the comment\r\n      const [commentResult] = await connection.execute(`\r\n        INSERT INTO kanban_task_comments (task_id, user_id, comment)\r\n        VALUES (?, ?, ?)\r\n      `, [taskId, userId, comment.trim()]);\r\n\r\n      // Log the comment activity\r\n      await connection.execute(`\r\n        INSERT INTO kanban_task_activity (task_id, user_id, action_type, description)\r\n        VALUES (?, ?, 'commented', ?)\r\n      `, [taskId, userId, `Added comment to task \"${taskBoard[0].title}\"`]);\r\n\r\n      await connection.commit();\r\n\r\n      return {\r\n        id: commentResult.insertId,\r\n        comment: comment.trim(),\r\n        created_at: new Date()\r\n      };\r\n\r\n    } catch (error) {\r\n      await connection.rollback();\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Get task comments\r\n  async getTaskComments(taskId, userId) {\r\n    const connection = await this.getConnection();\r\n\r\n    // Check if user has access to the task's board\r\n    const [taskBoard] = await connection.execute(`\r\n      SELECT board_id FROM kanban_tasks WHERE id = ?\r\n    `, [taskId]);\r\n\r\n    if (taskBoard.length === 0) {\r\n      throw new Error('Task not found');\r\n    }\r\n\r\n    const { hasAccess } = await this.checkBoardAccess(taskBoard[0].board_id, userId, 'viewer');\r\n    if (!hasAccess) {\r\n      throw new Error('Access denied to this board');\r\n    }\r\n\r\n    // Get comments\r\n    const [comments] = await connection.execute(`\r\n      SELECT \r\n        c.id,\r\n        c.comment,\r\n        c.created_at,\r\n        c.updated_at,\r\n        u.username,\r\n        u.email\r\n      FROM kanban_task_comments c\r\n      JOIN users u ON c.user_id = u.id\r\n      WHERE c.task_id = ?\r\n      ORDER BY c.created_at ASC\r\n    `, [taskId]);\r\n\r\n    return comments;\r\n  }\r\n\r\n  // Complete task\r\n  async completeTask(taskId, userId) {\r\n    const connection = await this.getConnection();\r\n\r\n    // Get task and check board access\r\n    const [taskInfo] = await connection.execute(`\r\n      SELECT board_id, title, completed_at FROM kanban_tasks WHERE id = ?\r\n    `, [taskId]);\r\n\r\n    if (taskInfo.length === 0) {\r\n      throw new Error('Task not found');\r\n    }\r\n\r\n    if (taskInfo[0].completed_at) {\r\n      throw new Error('Task is already completed');\r\n    }\r\n\r\n    const { hasAccess } = await this.checkBoardAccess(taskInfo[0].board_id, userId, 'member');\r\n    if (!hasAccess) {\r\n      throw new Error('Access denied to this board');\r\n    }\r\n\r\n    try {\r\n      await connection.beginTransaction();\r\n\r\n      // Mark task as completed\r\n      await connection.execute(`\r\n        UPDATE kanban_tasks \r\n        SET completed_at = CURRENT_TIMESTAMP, updated_at = CURRENT_TIMESTAMP\r\n        WHERE id = ?\r\n      `, [taskId]);\r\n\r\n      // Log completion activity\r\n      await connection.execute(`\r\n        INSERT INTO kanban_task_activity (task_id, user_id, action_type, description)\r\n        VALUES (?, ?, 'completed', ?)\r\n      `, [taskId, userId, `Completed task \"${taskInfo[0].title}\"`]);\r\n\r\n      await connection.commit();\r\n\r\n      return { success: true };\r\n\r\n    } catch (error) {\r\n      await connection.rollback();\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Reopen completed task\r\n  async reopenTask(taskId, userId) {\r\n    const connection = await this.getConnection();\r\n\r\n    // Get task and check board access\r\n    const [taskInfo] = await connection.execute(`\r\n      SELECT board_id, title, completed_at FROM kanban_tasks WHERE id = ?\r\n    `, [taskId]);\r\n\r\n    if (taskInfo.length === 0) {\r\n      throw new Error('Task not found');\r\n    }\r\n\r\n    if (!taskInfo[0].completed_at) {\r\n      throw new Error('Task is not completed');\r\n    }\r\n\r\n    const { hasAccess } = await this.checkBoardAccess(taskInfo[0].board_id, userId, 'member');\r\n    if (!hasAccess) {\r\n      throw new Error('Access denied to this board');\r\n    }\r\n\r\n    try {\r\n      await connection.beginTransaction();\r\n\r\n      // Reopen task\r\n      await connection.execute(`\r\n        UPDATE kanban_tasks \r\n        SET completed_at = NULL, updated_at = CURRENT_TIMESTAMP\r\n        WHERE id = ?\r\n      `, [taskId]);\r\n\r\n      // Log reopen activity\r\n      await connection.execute(`\r\n        INSERT INTO kanban_task_activity (task_id, user_id, action_type, description)\r\n        VALUES (?, ?, 'updated', ?)\r\n      `, [taskId, userId, `Reopened task \"${taskInfo[0].title}\"`]);\r\n\r\n      await connection.commit();\r\n\r\n      return { success: true };\r\n\r\n    } catch (error) {\r\n      await connection.rollback();\r\n      throw error;\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = KanbanTask;\r\n"
    },
    "complexity": {
      "totalLines": 796,
      "codeLines": 604,
      "commentLines": 60,
      "commentRatio": 0.09036144578313253,
      "averageLineLength": 34.248493975903614
    },
    "lastAnalyzed": "2025-07-28T07:20:00.332Z"
  },
  "contentHash": "79c43ebf76de050ad030b40bddcc141c38f05742e428978edf25b58db499f22b",
  "discoveredAt": "2025-07-28T07:20:00.332Z"
}