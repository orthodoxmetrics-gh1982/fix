{
  "id": "f9809eef44a1",
  "originalPath": "/var/www/orthodox-church-mgmt/orthodoxmetrics/prod/server/routes/blogs.js",
  "relativePath": "server/routes/blogs.js",
  "name": "blogs.js",
  "extension": ".js",
  "size": 8788,
  "modified": "2025-07-28T05:32:04.086Z",
  "created": "2025-07-28T05:32:01.107Z",
  "classification": {
    "type": "Server Scripts",
    "category": "Backend > Server",
    "confidence": 7
  },
  "metadata": {
    "fileStats": {
      "lines": 278,
      "characters": 8788,
      "words": 942
    },
    "classification": {
      "type": "Server Scripts",
      "category": "Backend > Server",
      "confidence": 7
    },
    "dependencies": [
      {
        "type": "npm_package",
        "name": "express",
        "line": 1
      },
      {
        "type": "npm_package",
        "name": "mysql2/promise",
        "line": 3
      },
      {
        "type": "npm_package",
        "name": "express-validator",
        "line": 4
      }
    ],
    "security": {
      "findings": [
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 9,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 10,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 11,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 12,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 13,
          "redacted": true
        }
      ],
      "hasSecurityIssues": true,
      "redactedContent": "const express = require('express');\r\nconst router = express.Router();\r\nconst mysql = require('mysql2/promise');\r\nconst { body, validationResult, param } = require('express-validator');\r\nconst { authenticateToken, requireRole } = require('../middleware/auth');\r\n\r\n// Database connection\r\nconst dbConfig = {\r\n  host: process.env.[REDACTED] || 'localhost',\r\n  user: process.env.[REDACTED] || 'root',\r\n  password: process.env.[REDACTED] || '',\r\n  database: process.env.[REDACTED] || 'orthodoxmetrics_db',\r\n  port: process.env.[REDACTED] || 3306\r\n};\r\n\r\n// Get all blogs with filtering and pagination\r\nrouter.get('/', async (req, res) => {\r\n  try {\r\n    const { \r\n      status = 'published', \r\n      visibility = 'public', \r\n      author_id, \r\n      page = 1, \r\n      limit = 10,\r\n      sort = 'created_at',\r\n      order = 'DESC'\r\n    } = req.query;\r\n\r\n    const offset = (page - 1) * limit;\r\n    const connection = await mysql.createConnection(dbConfig);\r\n\r\n    let whereClause = 'WHERE 1=1';\r\n    const params = [];\r\n\r\n    if (status !== 'all') {\r\n      whereClause += ' AND status = ?';\r\n      params.push(status);\r\n    }\r\n\r\n    if (visibility !== 'all') {\r\n      whereClause += ' AND visibility = ?';\r\n      params.push(visibility);\r\n    }\r\n\r\n    if (author_id) {\r\n      whereClause += ' AND author_id = ?';\r\n      params.push(author_id);\r\n    }\r\n\r\n    const validSortColumns = ['created_at', 'updated_at', 'published_at', 'title'];\r\n    const validOrder = ['ASC', 'DESC'];\r\n    const sortColumn = validSortColumns.includes(sort) ? sort : 'created_at';\r\n    const sortOrder = validOrder.includes(order.toUpperCase()) ? order.toUpperCase() : 'DESC';\r\n\r\n    const query = `\r\n      SELECT ub.*, u.name as author_name, u.email as author_email\r\n      FROM user_blogs ub\r\n      LEFT JOIN users u ON ub.author_id = u.id\r\n      ${whereClause}\r\n      ORDER BY ${sortColumn} ${sortOrder}\r\n      LIMIT ? OFFSET ?\r\n    `;\r\n\r\n    params.push(parseInt(limit), parseInt(offset));\r\n\r\n    const [blogs] = await connection.execute(query, params);\r\n\r\n    // Get total count for pagination\r\n    const countQuery = `\r\n      SELECT COUNT(*) as total\r\n      FROM user_blogs ub\r\n      ${whereClause}\r\n    `;\r\n    const [countResult] = await connection.execute(countQuery, params.slice(0, -2));\r\n\r\n    await connection.end();\r\n\r\n    res.json({\r\n      blogs,\r\n      pagination: {\r\n        page: parseInt(page),\r\n        limit: parseInt(limit),\r\n        total: countResult[0].total,\r\n        totalPages: Math.ceil(countResult[0].total / limit)\r\n      }\r\n    });\r\n  } catch (error) {\r\n    console.error('Error fetching blogs:', error);\r\n    res.status(500).json({ error: 'Internal server error' });\r\n  }\r\n});\r\n\r\n// Get single blog by slug\r\nrouter.get('/:slug', async (req, res) => {\r\n  try {\r\n    const { slug } = req.params;\r\n    const connection = await mysql.createConnection(dbConfig);\r\n\r\n    const query = `\r\n      SELECT ub.*, u.name as author_name, u.email as author_email\r\n      FROM user_blogs ub\r\n      LEFT JOIN users u ON ub.author_id = u.id\r\n      WHERE ub.slug = ?\r\n    `;\r\n\r\n    const [blogs] = await connection.execute(query, [slug]);\r\n    await connection.end();\r\n\r\n    if (blogs.length === 0) {\r\n      return res.status(404).json({ error: 'Blog not found' });\r\n    }\r\n\r\n    res.json(blogs[0]);\r\n  } catch (error) {\r\n    console.error('Error fetching blog:', error);\r\n    res.status(500).json({ error: 'Internal server error' });\r\n  }\r\n});\r\n\r\n// Create or update blog\r\nrouter.put('/:slug', \r\n  authenticateToken,\r\n  [\r\n    param('slug').notEmpty().withMessage('Slug is required'),\r\n    body('title').notEmpty().withMessage('Title is required'),\r\n    body('content').notEmpty().withMessage('Content is required'),\r\n    body('status').isIn(['draft', 'published', 'archived']).withMessage('Invalid status'),\r\n    body('visibility').isIn(['public', 'internal', 'church-only']).withMessage('Invalid visibility')\r\n  ],\r\n  async (req, res) => {\r\n    try {\r\n      const errors = validationResult(req);\r\n      if (!errors.isEmpty()) {\r\n        return res.status(400).json({ errors: errors.array() });\r\n      }\r\n\r\n      const { slug } = req.params;\r\n      const { title, content, meta_description, status, visibility } = req.body;\r\n      const author_id = req.user.id;\r\n\r\n      const connection = await mysql.createConnection(dbConfig);\r\n\r\n      // Check if blog exists\r\n      const [existingBlogs] = await connection.execute(\r\n        'SELECT id, author_id FROM user_blogs WHERE slug = ?',\r\n        [slug]\r\n      );\r\n\r\n      let result;\r\n      if (existingBlogs.length > 0) {\r\n        // Update existing blog\r\n        const existingBlog = existingBlogs[0];\r\n        \r\n        // Check if user owns the blog or is admin\r\n        if (existingBlog.author_id !== author_id && req.user.role !== 'super_admin' && req.user.role !== 'church_admin') {\r\n          await connection.end();\r\n          return res.status(403).json({ error: 'Not authorized to edit this blog' });\r\n        }\r\n\r\n        const updateQuery = `\r\n          UPDATE user_blogs \r\n          SET title = ?, content = ?, meta_description = ?, status = ?, visibility = ?,\r\n              published_at = CASE WHEN status = 'published' AND published_at IS NULL THEN NOW() ELSE published_at END\r\n          WHERE slug = ?\r\n        `;\r\n\r\n        await connection.execute(updateQuery, [\r\n          title, JSON.stringify(content), meta_description, status, visibility, slug\r\n        ]);\r\n\r\n        // Fetch updated blog\r\n        const [updatedBlogs] = await connection.execute(\r\n          'SELECT * FROM user_blogs WHERE slug = ?',\r\n          [slug]\r\n        );\r\n        result = updatedBlogs[0];\r\n      } else {\r\n        // Create new blog\r\n        const insertQuery = `\r\n          INSERT INTO user_blogs (author_id, title, slug, content, meta_description, status, visibility, published_at)\r\n          VALUES (?, ?, ?, ?, ?, ?, ?, ?)\r\n        `;\r\n\r\n        const published_at = status === 'published' ? new Date() : null;\r\n\r\n        await connection.execute(insertQuery, [\r\n          author_id, title, slug, JSON.stringify(content), meta_description, status, visibility, published_at\r\n        ]);\r\n\r\n        // Fetch created blog\r\n        const [newBlogs] = await connection.execute(\r\n          'SELECT * FROM user_blogs WHERE slug = ?',\r\n          [slug]\r\n        );\r\n        result = newBlogs[0];\r\n      }\r\n\r\n      await connection.end();\r\n      res.json(result);\r\n    } catch (error) {\r\n      console.error('Error saving blog:', error);\r\n      res.status(500).json({ error: 'Internal server error' });\r\n    }\r\n  }\r\n);\r\n\r\n// Delete blog\r\nrouter.delete('/:slug', \r\n  authenticateToken,\r\n  async (req, res) => {\r\n    try {\r\n      const { slug } = req.params;\r\n      const connection = await mysql.createConnection(dbConfig);\r\n\r\n      // Check if blog exists and user owns it\r\n      const [blogs] = await connection.execute(\r\n        'SELECT id, author_id FROM user_blogs WHERE slug = ?',\r\n        [slug]\r\n      );\r\n\r\n      if (blogs.length === 0) {\r\n        await connection.end();\r\n        return res.status(404).json({ error: 'Blog not found' });\r\n      }\r\n\r\n      const blog = blogs[0];\r\n      \r\n      // Check authorization\r\n      if (blog.author_id !== req.user.id && req.user.role !== 'super_admin' && req.user.role !== 'church_admin') {\r\n        await connection.end();\r\n        return res.status(403).json({ error: 'Not authorized to delete this blog' });\r\n      }\r\n\r\n      await connection.execute('DELETE FROM user_blogs WHERE slug = ?', [slug]);\r\n      await connection.end();\r\n\r\n      res.json({ message: 'Blog deleted successfully' });\r\n    } catch (error) {\r\n      console.error('Error deleting blog:', error);\r\n      res.status(500).json({ error: 'Internal server error' });\r\n    }\r\n  }\r\n);\r\n\r\n// Get blogs by author (for blog admin panel)\r\nrouter.get('/author/:authorId', \r\n  authenticateToken,\r\n  async (req, res) => {\r\n    try {\r\n      const { authorId } = req.params;\r\n      \r\n      // Users can only view their own blogs unless they're admin\r\n      if (parseInt(authorId) !== req.user.id && req.user.role !== 'super_admin' && req.user.role !== 'church_admin') {\r\n        return res.status(403).json({ error: 'Not authorized' });\r\n      }\r\n\r\n      const connection = await mysql.createConnection(dbConfig);\r\n\r\n      const query = `\r\n        SELECT ub.*, u.name as author_name\r\n        FROM user_blogs ub\r\n        LEFT JOIN users u ON ub.author_id = u.id\r\n        WHERE ub.author_id = ?\r\n        ORDER BY ub.updated_at DESC\r\n      `;\r\n\r\n      const [blogs] = await connection.execute(query, [authorId]);\r\n      await connection.end();\r\n\r\n      res.json(blogs);\r\n    } catch (error) {\r\n      console.error('Error fetching author blogs:', error);\r\n      res.status(500).json({ error: 'Internal server error' });\r\n    }\r\n  }\r\n);\r\n\r\nmodule.exports = router; "
    },
    "complexity": {
      "totalLines": 278,
      "codeLines": 216,
      "commentLines": 16,
      "commentRatio": 0.06896551724137931,
      "averageLineLength": 36.400862068965516
    },
    "lastAnalyzed": "2025-07-28T07:20:00.425Z"
  },
  "contentHash": "e8aa2d0251bf79da5f17509d40c8c8de48b94dc2fb896a9a71b9fdeb03ec95e7",
  "discoveredAt": "2025-07-28T07:20:00.425Z"
}