{
  "id": "f32dbba2f0d6",
  "originalPath": "/var/www/orthodox-church-mgmt/orthodoxmetrics/prod/server/legacy/phase1-create-db-utilities.js",
  "relativePath": "server/legacy/phase1-create-db-utilities.js",
  "name": "phase1-create-db-utilities.js",
  "extension": ".js",
  "size": 16897,
  "modified": "2025-07-24T14:51:40.480Z",
  "created": "2025-07-24T14:51:40.480Z",
  "classification": {
    "type": "Database Scripts",
    "category": "Backend > Database",
    "confidence": 4
  },
  "metadata": {
    "fileStats": {
      "lines": 584,
      "characters": 16829,
      "words": 1681
    },
    "classification": {
      "type": "Database Scripts",
      "category": "Backend > Database",
      "confidence": 4
    },
    "dependencies": [
      {
        "type": "npm_package",
        "name": "fs",
        "line": 8
      },
      {
        "type": "npm_package",
        "name": "path",
        "line": 9
      },
      {
        "type": "npm_package",
        "name": "mysql2/promise",
        "line": 17
      }
    ],
    "security": {
      "findings": [
        {
          "type": "sensitive_data",
          "pattern": "(?:password|pwd|pass)\\s*[:=]\\s*['\"]([^'\"]+)['\"]",
          "line": 24,
          "redacted": true
        }
      ],
      "hasSecurityIssues": true,
      "redactedContent": "#!/usr/bin/env node\r\n\r\n/**\r\n * Phase 1: Database Schema & Core Infrastructure\r\n * Step 4: Create cross-database connection utilities\r\n */\r\n\r\nconst fs = require('fs').promises;\r\nconst path = require('path');\r\n\r\nconst DB_UTILITIES_CODE = `/**\r\n * Cross-Database Connection Utilities for OCR System\r\n * Handles connections between orthodoxmetrics_db ‚Üî ssppoc_records_db ‚Üî saints_peter_and_paul_orthodox_church_db\r\n * Generated by Phase 1 setup script\r\n */\r\n\r\nimport mysql from 'mysql2/promise';\r\nimport { promisePool as centralPool } from '../config/db';\r\n\r\n// Database Configuration\r\nconst DB_CONFIG = {\r\n  host: 'localhost',\r\n  user: 'orthodoxapps',\r\n  password: '[REDACTED]',\r\n  charset: 'utf8mb4',\r\n  connectionLimit: 10,\r\n  acquireTimeout: 60000,\r\n  timeout: 60000\r\n};\r\n\r\n// Connection pools for each database\r\nlet recordsPool: mysql.Pool | null = null;\r\nlet ocrPool: mysql.Pool | null = null;\r\n\r\n/**\r\n * Get connection pool for Records Database (ssppoc_records_db)\r\n */\r\nexport function getRecordsDbPool(): mysql.Pool {\r\n  if (!recordsPool) {\r\n    recordsPool = mysql.createPool({\r\n      ...DB_CONFIG,\r\n      database: 'ssppoc_records_db'\r\n    });\r\n  }\r\n  return recordsPool;\r\n}\r\n\r\n/**\r\n * Get connection pool for OCR Processing Database (saints_peter_and_paul_orthodox_church_db)\r\n */\r\nexport function getOcrDbPool(): mysql.Pool {\r\n  if (!ocrPool) {\r\n    ocrPool = mysql.createPool({\r\n      ...DB_CONFIG,\r\n      database: 'saints_peter_and_paul_orthodox_church_db'\r\n    });\r\n  }\r\n  return ocrPool;\r\n}\r\n\r\n/**\r\n * Get single connection to Records Database\r\n */\r\nexport async function getRecordsDbConnection(): Promise<mysql.PoolConnection> {\r\n  const pool = getRecordsDbPool();\r\n  return await pool.getConnection();\r\n}\r\n\r\n/**\r\n * Get single connection to OCR Database  \r\n */\r\nexport async function getOcrDbConnection(): Promise<mysql.PoolConnection> {\r\n  const pool = getOcrDbPool();\r\n  return await pool.getConnection();\r\n}\r\n\r\n/**\r\n * Execute query on Records Database\r\n */\r\nexport async function executeRecordsQuery<T = any>(\r\n  query: string, \r\n  params: any[] = []\r\n): Promise<[T[], mysql.FieldPacket[]]> {\r\n  const pool = getRecordsDbPool();\r\n  return await pool.execute(query, params) as [T[], mysql.FieldPacket[]];\r\n}\r\n\r\n/**\r\n * Execute query on OCR Database\r\n */\r\nexport async function executeOcrQuery<T = any>(\r\n  query: string,\r\n  params: any[] = []\r\n): Promise<[T[], mysql.FieldPacket[]]> {\r\n  const pool = getOcrDbPool();\r\n  return await pool.execute(query, params) as [T[], mysql.FieldPacket[]];\r\n}\r\n\r\n/**\r\n * Execute query on Central Database (orthodoxmetrics_db)\r\n */\r\nexport async function executeCentralQuery<T = any>(\r\n  query: string,\r\n  params: any[] = []\r\n): Promise<[T[], mysql.FieldPacket[]]> {\r\n  return await centralPool.execute(query, params) as [T[], mysql.FieldPacket[]];\r\n}\r\n\r\n/**\r\n * Transaction wrapper for Records Database\r\n */\r\nexport async function withRecordsTransaction<T>(\r\n  callback: (connection: mysql.PoolConnection) => Promise<T>\r\n): Promise<T> {\r\n  const connection = await getRecordsDbConnection();\r\n  \r\n  try {\r\n    await connection.beginTransaction();\r\n    const result = await callback(connection);\r\n    await connection.commit();\r\n    return result;\r\n  } catch (error) {\r\n    await connection.rollback();\r\n    throw error;\r\n  } finally {\r\n    connection.release();\r\n  }\r\n}\r\n\r\n/**\r\n * Transaction wrapper for OCR Database\r\n */\r\nexport async function withOcrTransaction<T>(\r\n  callback: (connection: mysql.PoolConnection) => Promise<T>\r\n): Promise<T> {\r\n  const connection = await getOcrDbConnection();\r\n  \r\n  try {\r\n    await connection.beginTransaction();\r\n    const result = await callback(connection);\r\n    await connection.commit();\r\n    return result;\r\n  } catch (error) {\r\n    await connection.rollback();\r\n    throw error;\r\n  } finally {\r\n    connection.release();\r\n  }\r\n}\r\n\r\n/**\r\n * Cross-database transaction (Records + OCR)\r\n */\r\nexport async function withCrossDbTransaction<T>(\r\n  callback: (recordsConn: mysql.PoolConnection, ocrConn: mysql.PoolConnection) => Promise<T>\r\n): Promise<T> {\r\n  const recordsConnection = await getRecordsDbConnection();\r\n  const ocrConnection = await getOcrDbConnection();\r\n  \r\n  try {\r\n    await recordsConnection.beginTransaction();\r\n    await ocrConnection.beginTransaction();\r\n    \r\n    const result = await callback(recordsConnection, ocrConnection);\r\n    \r\n    await recordsConnection.commit();\r\n    await ocrConnection.commit();\r\n    \r\n    return result;\r\n  } catch (error) {\r\n    await recordsConnection.rollback();\r\n    await ocrConnection.rollback();\r\n    throw error;\r\n  } finally {\r\n    recordsConnection.release();\r\n    ocrConnection.release();\r\n  }\r\n}\r\n\r\n/**\r\n * Get church information from central database\r\n */\r\nexport async function getChurchInfo(churchId: number): Promise<any> {\r\n  const [rows] = await executeCentralQuery(\r\n    'SELECT * FROM churches WHERE id = ?',\r\n    [churchId]\r\n  );\r\n  \r\n  if (rows.length === 0) {\r\n    throw new Error(\\`Church not found: \\${churchId}\\`);\r\n  }\r\n  \r\n  return rows[0];\r\n}\r\n\r\n/**\r\n * Validate user permissions for OCR operations\r\n */\r\nexport async function validateUserPermissions(\r\n  userId: number, \r\n  action: string,\r\n  churchId?: number\r\n): Promise<boolean> {\r\n  try {\r\n    // Get user role and permissions\r\n    const [userRows] = await executeCentralQuery(\r\n      \\`SELECT u.*, ur.role_name \r\n       FROM users u \r\n       LEFT JOIN user_roles ur ON u.role_id = ur.id \r\n       WHERE u.id = ?\\`,\r\n      [userId]\r\n    );\r\n    \r\n    if (userRows.length === 0) {\r\n      return false;\r\n    }\r\n    \r\n    const user = userRows[0];\r\n    \r\n    // Super admin can do everything\r\n    if (user.email === 'superadmin@orthodoxmetrics.com') {\r\n      return true;\r\n    }\r\n    \r\n    // Check church-specific permissions if churchId provided\r\n    if (churchId) {\r\n      const [permRows] = await executeCentralQuery(\r\n        \\`SELECT * FROM church_permissions \r\n         WHERE user_id = ? AND church_id = ? AND permission_type = ?\\`,\r\n        [userId, churchId, action]\r\n      );\r\n      \r\n      if (permRows.length > 0) {\r\n        return true;\r\n      }\r\n    }\r\n    \r\n    // Check role-based permissions\r\n    const rolePermissions: Record<string, string[]> = {\r\n      'admin': ['ocr_upload', 'ocr_review', 'ocr_approve', 'ocr_configure'],\r\n      'clergy': ['ocr_upload', 'ocr_review', 'ocr_approve'],\r\n      'volunteer': ['ocr_upload']\r\n    };\r\n    \r\n    const allowedActions = rolePermissions[user.role_name] || [];\r\n    return allowedActions.includes(action);\r\n    \r\n  } catch (error) {\r\n    console.error('Permission validation error:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Test all database connections\r\n */\r\nexport async function testConnections(): Promise<{ success: boolean; results: any }> {\r\n  const results = {\r\n    central: { connected: false, error: null },\r\n    records: { connected: false, error: null },\r\n    ocr: { connected: false, error: null }\r\n  };\r\n  \r\n  try {\r\n    // Test central database\r\n    const [centralRows] = await executeCentralQuery('SELECT 1 as test');\r\n    results.central.connected = true;\r\n  } catch (error) {\r\n    results.central.error = error.message;\r\n  }\r\n  \r\n  try {\r\n    // Test records database\r\n    const [recordsRows] = await executeRecordsQuery('SELECT 1 as test');\r\n    results.records.connected = true;\r\n  } catch (error) {\r\n    results.records.error = error.message;\r\n  }\r\n  \r\n  try {\r\n    // Test OCR database\r\n    const [ocrRows] = await executeOcrQuery('SELECT 1 as test');\r\n    results.ocr.connected = true;\r\n  } catch (error) {\r\n    results.ocr.error = error.message;\r\n  }\r\n  \r\n  const success = results.central.connected && results.records.connected && results.ocr.connected;\r\n  \r\n  return { success, results };\r\n}\r\n\r\n/**\r\n * Close all database connections\r\n */\r\nexport async function closeAllConnections(): Promise<void> {\r\n  const promises = [];\r\n  \r\n  if (recordsPool) {\r\n    promises.push(recordsPool.end());\r\n    recordsPool = null;\r\n  }\r\n  \r\n  if (ocrPool) {\r\n    promises.push(ocrPool.end());\r\n    ocrPool = null;\r\n  }\r\n  \r\n  await Promise.all(promises);\r\n}\r\n\r\n// Graceful shutdown\r\nprocess.on('SIGINT', async () => {\r\n  await closeAllConnections();\r\n  process.exit(0);\r\n});\r\n\r\nprocess.on('SIGTERM', async () => {\r\n  await closeAllConnections(); \r\n  process.exit(0);\r\n});\r\n`;\r\n\r\nconst FIELD_CONFIG_SERVICE_CODE = `/**\r\n * Field Configuration Service\r\n * Handles OCR field mapping configurations for churches\r\n * Generated by Phase 1 setup script\r\n */\r\n\r\nimport {\r\n  FieldConfig,\r\n  RecordFieldConfig,\r\n  FieldConfigResponse,\r\n  CreateFieldConfigRequest,\r\n  RecordType,\r\n  TABLE_NAMES\r\n} from '../types/ocrTypes';\r\nimport { executeRecordsQuery, withRecordsTransaction } from './dbConnections';\r\n\r\n/**\r\n * Get field configuration for a church and record type\r\n */\r\nexport async function getFieldConfig(\r\n  churchId: number,\r\n  recordType: RecordType\r\n): Promise<RecordFieldConfig | null> {\r\n  try {\r\n    const [rows] = await executeRecordsQuery<FieldConfigResponse>(\r\n      \\`SELECT * FROM \\${TABLE_NAMES.OCR_FIELD_CONFIGURATIONS} \r\n       WHERE church_id = ? AND record_type = ? AND is_active = TRUE\r\n       ORDER BY version DESC LIMIT 1\\`,\r\n      [churchId, recordType]\r\n    );\r\n    \r\n    if (rows.length === 0) {\r\n      return null;\r\n    }\r\n    \r\n    return rows[0].field_config;\r\n  } catch (error) {\r\n    console.error('Error getting field config:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Create or update field configuration\r\n */\r\nexport async function saveFieldConfig(\r\n  request: CreateFieldConfigRequest\r\n): Promise<number> {\r\n  return await withRecordsTransaction(async (connection) => {\r\n    // Deactivate existing configs for this church/record type\r\n    await connection.execute(\r\n      \\`UPDATE \\${TABLE_NAMES.OCR_FIELD_CONFIGURATIONS} \r\n       SET is_active = FALSE, updated_at = CURRENT_TIMESTAMP\r\n       WHERE church_id = ? AND record_type = ?\\`,\r\n      [request.church_id, request.record_type]\r\n    );\r\n    \r\n    // Get next version number\r\n    const [versionRows] = await connection.execute(\r\n      \\`SELECT COALESCE(MAX(version), 0) + 1 as next_version \r\n       FROM \\${TABLE_NAMES.OCR_FIELD_CONFIGURATIONS}\r\n       WHERE church_id = ? AND record_type = ?\\`,\r\n      [request.church_id, request.record_type]\r\n    );\r\n    \r\n    const nextVersion = versionRows[0].next_version;\r\n    \r\n    // Insert new configuration\r\n    const [result] = await connection.execute(\r\n      \\`INSERT INTO \\${TABLE_NAMES.OCR_FIELD_CONFIGURATIONS} \r\n       (church_id, record_type, field_config, description, version, is_active) \r\n       VALUES (?, ?, ?, ?, ?, TRUE)\\`,\r\n      [\r\n        request.church_id,\r\n        request.record_type,\r\n        JSON.stringify(request.field_config),\r\n        request.description,\r\n        nextVersion\r\n      ]\r\n    );\r\n    \r\n    return result.insertId;\r\n  });\r\n}\r\n\r\n/**\r\n * Get all field configurations for a church\r\n */\r\nexport async function getChurchFieldConfigs(churchId: number): Promise<FieldConfigResponse[]> {\r\n  const [rows] = await executeRecordsQuery<FieldConfigResponse>(\r\n    \\`SELECT * FROM \\${TABLE_NAMES.OCR_FIELD_CONFIGURATIONS}\r\n     WHERE church_id = ? AND is_active = TRUE\r\n     ORDER BY record_type, version DESC\\`,\r\n    [churchId]\r\n  );\r\n  \r\n  return rows;\r\n}\r\n\r\n/**\r\n * Get field configuration history\r\n */\r\nexport async function getFieldConfigHistory(\r\n  churchId: number,\r\n  recordType: RecordType\r\n): Promise<FieldConfigResponse[]> {\r\n  const [rows] = await executeRecordsQuery<FieldConfigResponse>(\r\n    \\`SELECT * FROM \\${TABLE_NAMES.OCR_FIELD_CONFIGURATIONS}\r\n     WHERE church_id = ? AND record_type = ?\r\n     ORDER BY version DESC\\`,\r\n    [churchId, recordType]\r\n  );\r\n  \r\n  return rows;\r\n}\r\n\r\n/**\r\n * Delete field configuration (soft delete - mark as inactive)\r\n */\r\nexport async function deleteFieldConfig(configId: number): Promise<void> {\r\n  await executeRecordsQuery(\r\n    \\`UPDATE \\${TABLE_NAMES.OCR_FIELD_CONFIGURATIONS}\r\n     SET is_active = FALSE, updated_at = CURRENT_TIMESTAMP\r\n     WHERE id = ?\\`,\r\n    [configId]\r\n  );\r\n}\r\n`;\r\n\r\nasync function createDbUtilities() {\r\n  try {\r\n    console.log('üîå PHASE 1 - Step 4: Creating database connection utilities...');\r\n    console.log('================================================================================');\r\n    \r\n    // Create utils directory if it doesn't exist\r\n    const utilsDir = path.join(__dirname, '..', 'utils');\r\n    \r\n    try {\r\n      await fs.access(utilsDir);\r\n      console.log('üìÅ Utils directory exists');\r\n    } catch {\r\n      await fs.mkdir(utilsDir, { recursive: true });\r\n      console.log('üìÅ Created utils directory');\r\n    }\r\n    \r\n    // Create services directory\r\n    const servicesDir = path.join(__dirname, '..', 'services');\r\n    \r\n    try {\r\n      await fs.access(servicesDir);\r\n      console.log('üìÅ Services directory exists');\r\n    } catch {\r\n      await fs.mkdir(servicesDir, { recursive: true });\r\n      console.log('üìÅ Created services directory');\r\n    }\r\n    \r\n    // Write database connections utility\r\n    const dbConnectionsPath = path.join(utilsDir, 'dbConnections.ts');\r\n    await fs.writeFile(dbConnectionsPath, DB_UTILITIES_CODE);\r\n    console.log(`‚úÖ Created database connections utility: ${dbConnectionsPath}`);\r\n    \r\n    // Write field configuration service\r\n    const fieldConfigPath = path.join(servicesDir, 'fieldConfigService.ts');\r\n    await fs.writeFile(fieldConfigPath, FIELD_CONFIG_SERVICE_CODE);\r\n    console.log(`‚úÖ Created field configuration service: ${fieldConfigPath}`);\r\n    \r\n    // Create a test script for the utilities\r\n    const testUtilitiesCode = `#!/usr/bin/env node\r\n\r\n/**\r\n * Test script for database utilities\r\n */\r\n\r\nimport { testConnections, getChurchInfo, validateUserPermissions } from '../utils/dbConnections';\r\nimport { getFieldConfig, getChurchFieldConfigs } from '../services/fieldConfigService';\r\n\r\nasync function testDbUtilities() {\r\n  console.log('üß™ Testing database utilities...');\r\n  \r\n  try {\r\n    // Test connections\r\n    console.log('\\\\nüîå Testing database connections...');\r\n    const connectionTest = await testConnections();\r\n    \r\n    if (connectionTest.success) {\r\n      console.log('‚úÖ All database connections successful');\r\n    } else {\r\n      console.log('‚ùå Some database connections failed:');\r\n      Object.entries(connectionTest.results).forEach(([db, result]) => {\r\n        if (result.connected) {\r\n          console.log(\\`   ‚úÖ \\${db}: Connected\\`);\r\n        } else {\r\n          console.log(\\`   ‚ùå \\${db}: \\${result.error}\\`);\r\n        }\r\n      });\r\n    }\r\n    \r\n    // Test church info retrieval\r\n    console.log('\\\\nüèõÔ∏è Testing church info retrieval...');\r\n    try {\r\n      const churchInfo = await getChurchInfo(14);\r\n      console.log(\\`‚úÖ Church info retrieved: \\${churchInfo.name}\\`);\r\n    } catch (error) {\r\n      console.log(\\`‚ùå Church info failed: \\${error.message}\\`);\r\n    }\r\n    \r\n    // Test field configuration retrieval\r\n    console.log('\\\\nüìã Testing field configuration retrieval...');\r\n    try {\r\n      const fieldConfig = await getFieldConfig(14, 'baptism');\r\n      if (fieldConfig) {\r\n        console.log(\\`‚úÖ Field config retrieved: \\${fieldConfig.fields.length} fields\\`);\r\n      } else {\r\n        console.log('‚ÑπÔ∏è  No field config found (expected for new setup)');\r\n      }\r\n    } catch (error) {\r\n      console.log(\\`‚ùå Field config failed: \\${error.message}\\`);\r\n    }\r\n    \r\n    // Test church field configs\r\n    console.log('\\\\nüìÇ Testing church field configs...');\r\n    try {\r\n      const configs = await getChurchFieldConfigs(14);\r\n      console.log(\\`‚úÖ Found \\${configs.length} field configurations for church 14\\`);\r\n    } catch (error) {\r\n      console.log(\\`‚ùå Church field configs failed: \\${error.message}\\`);\r\n    }\r\n    \r\n    console.log('\\\\nüéâ Database utilities test complete!');\r\n    \r\n  } catch (error) {\r\n    console.error('‚ùå Test failed:', error.message);\r\n    process.exit(1);\r\n  }\r\n}\r\n\r\ntestDbUtilities().catch(console.error);\r\n`;\r\n    \r\n    const testPath = path.join(__dirname, 'test-db-utilities.ts');\r\n    await fs.writeFile(testPath, testUtilitiesCode);\r\n    console.log(`‚úÖ Created test script: ${testPath}`);\r\n    \r\n    console.log('\\n================================================================================');\r\n    console.log('üîå Database Utilities Creation Complete!');\r\n    console.log('üìÅ Files created:');\r\n    console.log(`   - ${dbConnectionsPath}`);\r\n    console.log(`   - ${fieldConfigPath}`);\r\n    console.log(`   - ${testPath}`);\r\n    console.log('\\nüìù Next step: Run phase1-complete.js to finalize Phase 1 setup');\r\n    console.log('================================================================================');\r\n    \r\n  } catch (error) {\r\n    console.error('‚ùå Database utilities creation failed:', error.message);\r\n    process.exit(1);\r\n  }\r\n}\r\n\r\n// Run utility creation\r\ncreateDbUtilities().catch(console.error);\r\n"
    },
    "complexity": {
      "totalLines": 584,
      "codeLines": 403,
      "commentLines": 96,
      "commentRatio": 0.19238476953907815,
      "averageLineLength": 32.056112224448896
    },
    "lastAnalyzed": "2025-07-28T07:20:00.273Z"
  },
  "contentHash": "9871bb2ecacf26723836e2e996c0d95b0b10b6c8448ecc005122d37674171abf",
  "discoveredAt": "2025-07-28T07:20:00.273Z"
}