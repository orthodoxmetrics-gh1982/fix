{
  "id": "8a1df4fe7305",
  "originalPath": "/var/www/orthodox-church-mgmt/orthodoxmetrics/prod/backend/services/siteEditorManager.js",
  "relativePath": "backend/services/siteEditorManager.js",
  "name": "siteEditorManager.js",
  "extension": ".js",
  "size": 19347,
  "modified": "2025-07-25T06:17:46.656Z",
  "created": "2025-07-25T06:17:44.862Z",
  "classification": {
    "type": "Testing Scripts",
    "category": "DevOps > Test",
    "confidence": 2
  },
  "metadata": {
    "fileStats": {
      "lines": 619,
      "characters": 19347,
      "words": 1760
    },
    "classification": {
      "type": "Testing Scripts",
      "category": "DevOps > Test",
      "confidence": 2
    },
    "dependencies": [
      {
        "type": "npm_package",
        "name": "fs",
        "line": 4
      },
      {
        "type": "npm_package",
        "name": "path",
        "line": 5
      },
      {
        "type": "npm_package",
        "name": "crypto",
        "line": 6
      },
      {
        "type": "npm_package",
        "name": "child_process",
        "line": 7
      }
    ],
    "security": {
      "findings": [
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 13,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 14,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 20,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 21,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 22,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 23,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 24,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 25,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 28,
          "redacted": true
        }
      ],
      "hasSecurityIssues": true,
      "redactedContent": "// Site Editor Manager Service\r\n// Manages component file operations, backup, syntax validation, and audit logging\r\n\r\nconst fs = require('fs').promises;\r\nconst path = require('path');\r\nconst crypto = require('crypto');\r\nconst { execSync } = require('child_process');\r\n\r\nclass SiteEditorManager {\r\n  constructor() {\r\n    this.config = this.loadDefaultConfig();\r\n    this.auditLogs = [];\r\n    this.backupDir = process.env.[REDACTED] || '/var/log/orthodoxmetrics/backups';\r\n    this.componentsDir = process.env.[REDACTED] || path.join(process.cwd(), 'front-end/src/components');\r\n    this.ensureDirectories();\r\n  }\r\n\r\n  loadDefaultConfig() {\r\n    return {\r\n      enabled: process.env.[REDACTED] !== 'false',\r\n      allowInProduction: process.env.[REDACTED] === 'true',\r\n      lockdownMode: process.env.[REDACTED] === 'true',\r\n      autoBackup: process.env.[REDACTED] !== 'false',\r\n      maxBackups: parseInt(process.env.[REDACTED]) || 50,\r\n      backupDir: process.env.[REDACTED] || '/var/log/orthodoxmetrics/backups',\r\n      allowedExtensions: ['.tsx', '.ts', '.jsx', '.js'],\r\n      maxFileSize: 1024 * 1024, // 1MB\r\n      gitOpsEnabled: process.env.[REDACTED] === 'true'\r\n    };\r\n  }\r\n\r\n  async ensureDirectories() {\r\n    try {\r\n      await fs.mkdir(this.backupDir, { recursive: true });\r\n      await fs.mkdir(path.join(this.backupDir, 'components'), { recursive: true });\r\n    } catch (error) {\r\n      console.error('[Site Editor] Failed to create directories:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get mapping of component names to file paths\r\n   */\r\n  async getComponentsMap() {\r\n    try {\r\n      const map = {};\r\n      \r\n      // Scan components directory\r\n      await this.scanDirectory(this.componentsDir, '', map);\r\n      \r\n      return map;\r\n    } catch (error) {\r\n      console.error('[Site Editor] Failed to generate components map:', error);\r\n      return {};\r\n    }\r\n  }\r\n\r\n  async scanDirectory(dir, relativePath, map) {\r\n    try {\r\n      const entries = await fs.readdir(dir, { withFileTypes: true });\r\n      \r\n      for (const entry of entries) {\r\n        const fullPath = path.join(dir, entry.name);\r\n        const relativeFilePath = path.join(relativePath, entry.name);\r\n        \r\n        if (entry.isDirectory()) {\r\n          await this.scanDirectory(fullPath, relativeFilePath, map);\r\n        } else if (this.isValidComponentFile(entry.name)) {\r\n          const componentName = path.basename(entry.name, path.extname(entry.name));\r\n          map[entry.name] = path.posix.join('/src/components', relativeFilePath);\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.error('[Site Editor] Failed to scan directory:', dir, error);\r\n    }\r\n  }\r\n\r\n  isValidComponentFile(filename) {\r\n    const ext = path.extname(filename);\r\n    return this.config.allowedExtensions.includes(ext) && \r\n           /^[A-Z][a-zA-Z0-9]*\\.(tsx|ts|jsx|js)$/.test(filename);\r\n  }\r\n\r\n  /**\r\n   * Validate file path for security\r\n   */\r\n  validatePath(filePath) {\r\n    try {\r\n      // Normalize path\r\n      const normalizedPath = path.normalize(filePath);\r\n      \r\n      // Check for directory traversal\r\n      if (normalizedPath.includes('..') || normalizedPath.startsWith('/')) {\r\n        return { valid: false, error: 'Invalid path: directory traversal not allowed' };\r\n      }\r\n      \r\n      // Check file extension\r\n      const ext = path.extname(normalizedPath);\r\n      if (!this.config.allowedExtensions.includes(ext)) {\r\n        return { valid: false, error: `Invalid file extension: ${ext}` };\r\n      }\r\n      \r\n      // Check if path is within components directory\r\n      if (!normalizedPath.startsWith('src/components/') && !normalizedPath.startsWith('/src/components/')) {\r\n        return { valid: false, error: 'Path must be within src/components directory' };\r\n      }\r\n      \r\n      return { valid: true };\r\n    } catch (error) {\r\n      return { valid: false, error: 'Path validation failed' };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get component source code\r\n   */\r\n  async getComponentSource(componentPath) {\r\n    const validation = this.validatePath(componentPath);\r\n    if (!validation.valid) {\r\n      throw new Error(validation.error);\r\n    }\r\n\r\n    // Convert to absolute path\r\n    const absolutePath = this.getAbsolutePath(componentPath);\r\n    \r\n    try {\r\n      const source = await fs.readFile(absolutePath, 'utf8');\r\n      \r\n      // Check file size\r\n      if (source.length > this.config.maxFileSize) {\r\n        throw new Error(`File too large: ${source.length} bytes (max: ${this.config.maxFileSize})`);\r\n      }\r\n      \r\n      return source;\r\n    } catch (error) {\r\n      if (error.code === 'ENOENT') {\r\n        throw error; // Let the caller handle file not found\r\n      }\r\n      throw new Error(`Failed to read component source: ${error.message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Save component with automatic backup\r\n   */\r\n  async saveComponent({ path: componentPath, contents, user, gitOpsEnabled = false }) {\r\n    const validation = this.validatePath(componentPath);\r\n    if (!validation.valid) {\r\n      throw new Error(validation.error);\r\n    }\r\n\r\n    if (!this.config.enabled) {\r\n      throw new Error('Site Editor is disabled');\r\n    }\r\n\r\n    if (this.config.lockdownMode) {\r\n      throw new Error('Site Editor is in lockdown mode');\r\n    }\r\n\r\n    // Check file size\r\n    if (contents.length > this.config.maxFileSize) {\r\n      throw new Error(`File too large: ${contents.length} bytes (max: ${this.config.maxFileSize})`);\r\n    }\r\n\r\n    const absolutePath = this.getAbsolutePath(componentPath);\r\n    let backupToken = null;\r\n\r\n    try {\r\n      // Create backup if file exists\r\n      if (this.config.autoBackup) {\r\n        try {\r\n          const existingContent = await fs.readFile(absolutePath, 'utf8');\r\n          backupToken = await this.createBackup(componentPath, existingContent, user);\r\n        } catch (error) {\r\n          if (error.code !== 'ENOENT') {\r\n            console.warn('[Site Editor] Failed to create backup:', error);\r\n          }\r\n        }\r\n      }\r\n\r\n      // Ensure directory exists\r\n      await fs.mkdir(path.dirname(absolutePath), { recursive: true });\r\n\r\n      // Write the new content\r\n      await fs.writeFile(absolutePath, contents, 'utf8');\r\n\r\n      // Log the save action\r\n      await this.logAction(user, 'COMPONENT_SAVED', {\r\n        path: componentPath,\r\n        size: contents.length,\r\n        backupToken,\r\n        gitOpsEnabled\r\n      });\r\n\r\n      console.log(`[Site Editor] Component saved: ${componentPath} by ${user.name}`);\r\n\r\n      return {\r\n        success: true,\r\n        message: 'Component saved successfully',\r\n        backupToken,\r\n        path: componentPath,\r\n        size: contents.length,\r\n        timestamp: new Date().toISOString()\r\n      };\r\n\r\n    } catch (error) {\r\n      await this.logAction(user, 'COMPONENT_SAVE_FAILED', {\r\n        path: componentPath,\r\n        error: error.message\r\n      }, false, error.message);\r\n\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create backup of existing file\r\n   */\r\n  async createBackup(componentPath, contents, user) {\r\n    try {\r\n      const backupToken = this.generateBackupToken();\r\n      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\r\n      const componentName = path.basename(componentPath, path.extname(componentPath));\r\n      \r\n      const backupFilename = `${componentName}-${timestamp}-${backupToken}.backup`;\r\n      const backupPath = path.join(this.backupDir, 'components', backupFilename);\r\n\r\n      // Create backup metadata\r\n      const metadata = {\r\n        token: backupToken,\r\n        originalPath: componentPath,\r\n        timestamp: new Date().toISOString(),\r\n        user: {\r\n          id: user.id,\r\n          name: user.name\r\n        },\r\n        size: contents.length,\r\n        checksum: crypto.createHash('sha256').update(contents).digest('hex')\r\n      };\r\n\r\n      // Write backup file\r\n      await fs.writeFile(backupPath, contents, 'utf8');\r\n      \r\n      // Write metadata\r\n      const metadataPath = backupPath + '.meta';\r\n      await fs.writeFile(metadataPath, JSON.stringify(metadata, null, 2), 'utf8');\r\n\r\n      // Cleanup old backups\r\n      await this.cleanupOldBackups(componentPath);\r\n\r\n      console.log(`[Site Editor] Backup created: ${backupToken} for ${componentPath}`);\r\n      \r\n      return backupToken;\r\n    } catch (error) {\r\n      console.error('[Site Editor] Failed to create backup:', error);\r\n      throw new Error(`Backup creation failed: ${error.message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Rollback component to a previous version\r\n   */\r\n  async rollbackComponent({ backupToken, user }) {\r\n    try {\r\n      // Find backup file\r\n      const backupInfo = await this.findBackupByToken(backupToken);\r\n      if (!backupInfo) {\r\n        throw new Error('Backup not found');\r\n      }\r\n\r\n      // Read backup content\r\n      const backupContent = await fs.readFile(backupInfo.filePath, 'utf8');\r\n      \r\n      // Validate backup integrity\r\n      const checksum = crypto.createHash('sha256').update(backupContent).digest('hex');\r\n      if (checksum !== backupInfo.metadata.checksum) {\r\n        throw new Error('Backup file corrupted');\r\n      }\r\n\r\n      // Create a backup of current state before rollback\r\n      const currentPath = this.getAbsolutePath(backupInfo.metadata.originalPath);\r\n      let currentBackupToken = null;\r\n      \r\n      try {\r\n        const currentContent = await fs.readFile(currentPath, 'utf8');\r\n        currentBackupToken = await this.createBackup(\r\n          backupInfo.metadata.originalPath, \r\n          currentContent, \r\n          user\r\n        );\r\n      } catch (error) {\r\n        console.warn('[Site Editor] Failed to backup current state before rollback:', error);\r\n      }\r\n\r\n      // Restore the backup\r\n      await fs.writeFile(currentPath, backupContent, 'utf8');\r\n\r\n      // Log rollback action\r\n      await this.logAction(user, 'COMPONENT_ROLLBACK', {\r\n        backupToken,\r\n        path: backupInfo.metadata.originalPath,\r\n        currentBackupToken,\r\n        rollbackTimestamp: backupInfo.metadata.timestamp\r\n      });\r\n\r\n      console.log(`[Site Editor] Component rolled back: ${backupInfo.metadata.originalPath} to ${backupInfo.metadata.timestamp}`);\r\n\r\n      return {\r\n        success: true,\r\n        message: 'Component rolled back successfully',\r\n        path: backupInfo.metadata.originalPath,\r\n        rollbackTo: backupInfo.metadata.timestamp,\r\n        currentBackupToken\r\n      };\r\n\r\n    } catch (error) {\r\n      await this.logAction(user, 'COMPONENT_ROLLBACK_FAILED', {\r\n        backupToken,\r\n        error: error.message\r\n      }, false, error.message);\r\n\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get backups for a component\r\n   */\r\n  async getBackups(componentName) {\r\n    try {\r\n      const backupsDir = path.join(this.backupDir, 'components');\r\n      const files = await fs.readdir(backupsDir);\r\n      \r\n      const backups = [];\r\n      \r\n      for (const file of files) {\r\n        if (file.startsWith(componentName) && file.endsWith('.backup.meta')) {\r\n          try {\r\n            const metadataPath = path.join(backupsDir, file);\r\n            const metadata = JSON.parse(await fs.readFile(metadataPath, 'utf8'));\r\n            \r\n            const backupPath = metadataPath.replace('.meta', '');\r\n            const stats = await fs.stat(backupPath);\r\n            \r\n            backups.push({\r\n              token: metadata.token,\r\n              timestamp: metadata.timestamp,\r\n              path: metadata.originalPath,\r\n              size: stats.size,\r\n              user: metadata.user,\r\n              checksum: metadata.checksum\r\n            });\r\n          } catch (error) {\r\n            console.warn('[Site Editor] Failed to read backup metadata:', file, error);\r\n          }\r\n        }\r\n      }\r\n      \r\n      return backups.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());\r\n    } catch (error) {\r\n      console.error('[Site Editor] Failed to get backups:', error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get backup content\r\n   */\r\n  async getBackupContent(backupToken) {\r\n    const backupInfo = await this.findBackupByToken(backupToken);\r\n    if (!backupInfo) {\r\n      throw new Error('Backup not found');\r\n    }\r\n\r\n    return await fs.readFile(backupInfo.filePath, 'utf8');\r\n  }\r\n\r\n  /**\r\n   * Validate TypeScript/JavaScript syntax\r\n   */\r\n  async validateSyntax(contents, filePath = 'temp.tsx') {\r\n    try {\r\n      // Create temporary file for validation\r\n      const tempFile = path.join(this.backupDir, `temp-${Date.now()}-${Math.random().toString(36).substr(2, 9)}.tsx`);\r\n      \r\n      await fs.writeFile(tempFile, contents, 'utf8');\r\n      \r\n      try {\r\n        // Use TypeScript compiler to check syntax\r\n        const command = `npx tsc --noEmit --jsx react-jsx --target esnext --module esnext --allowSyntheticDefaultImports --esModuleInterop \"${tempFile}\"`;\r\n        execSync(command, { stdio: 'pipe' });\r\n        \r\n        return {\r\n          valid: true,\r\n          errors: []\r\n        };\r\n      } catch (error) {\r\n        // Parse TypeScript errors\r\n        const output = error.stdout ? error.stdout.toString() : error.stderr.toString();\r\n        const errors = this.parseTypeScriptErrors(output);\r\n        \r\n        return {\r\n          valid: false,\r\n          errors\r\n        };\r\n      } finally {\r\n        // Cleanup temp file\r\n        try {\r\n          await fs.unlink(tempFile);\r\n        } catch (error) {\r\n          console.warn('[Site Editor] Failed to cleanup temp file:', tempFile);\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.error('[Site Editor] Syntax validation failed:', error);\r\n      return {\r\n        valid: false,\r\n        errors: [{ message: 'Validation failed: ' + error.message, line: 1, column: 1 }]\r\n      };\r\n    }\r\n  }\r\n\r\n  parseTypeScriptErrors(output) {\r\n    const errors = [];\r\n    const lines = output.split('\\n');\r\n    \r\n    for (const line of lines) {\r\n      const match = line.match(/^(.+)\\((\\d+),(\\d+)\\): error TS\\d+: (.+)$/);\r\n      if (match) {\r\n        errors.push({\r\n          file: match[1],\r\n          line: parseInt(match[2]),\r\n          column: parseInt(match[3]),\r\n          message: match[4]\r\n        });\r\n      }\r\n    }\r\n    \r\n    return errors;\r\n  }\r\n\r\n  /**\r\n   * Log Site Editor actions\r\n   */\r\n  async logAction(user, action, details = {}, success = true, errorMessage = null) {\r\n    const logEntry = {\r\n      id: crypto.randomUUID(),\r\n      timestamp: new Date().toISOString(),\r\n      userId: user.id,\r\n      userName: user.name,\r\n      action,\r\n      details: {\r\n        ...details,\r\n        userAgent: 'Site Editor',\r\n        sessionId: this.getSessionId()\r\n      },\r\n      success,\r\n      errorMessage\r\n    };\r\n\r\n    this.auditLogs.push(logEntry);\r\n\r\n    // Keep only recent logs in memory\r\n    if (this.auditLogs.length > 1000) {\r\n      this.auditLogs = this.auditLogs.slice(-1000);\r\n    }\r\n\r\n    // Write to audit log file\r\n    try {\r\n      const auditLogFile = path.join(this.backupDir, 'site-editor.log');\r\n      const logLine = JSON.stringify(logEntry) + '\\n';\r\n      await fs.appendFile(auditLogFile, logLine);\r\n    } catch (error) {\r\n      console.error('[Site Editor] Failed to write audit log:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get audit logs with filtering\r\n   */\r\n  async getAuditLogs(filters = {}) {\r\n    let logs = [...this.auditLogs];\r\n\r\n    if (filters.userId) {\r\n      logs = logs.filter(log => log.userId === filters.userId);\r\n    }\r\n\r\n    if (filters.action) {\r\n      logs = logs.filter(log => log.action === filters.action);\r\n    }\r\n\r\n    if (filters.component) {\r\n      logs = logs.filter(log => \r\n        log.details.path && log.details.path.includes(filters.component)\r\n      );\r\n    }\r\n\r\n    if (filters.startDate) {\r\n      logs = logs.filter(log => new Date(log.timestamp) >= filters.startDate);\r\n    }\r\n\r\n    if (filters.endDate) {\r\n      logs = logs.filter(log => new Date(log.timestamp) <= filters.endDate);\r\n    }\r\n\r\n    return logs.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());\r\n  }\r\n\r\n  /**\r\n   * Get configuration\r\n   */\r\n  async getConfig() {\r\n    return { ...this.config };\r\n  }\r\n\r\n  /**\r\n   * Update configuration\r\n   */\r\n  async updateConfig(newConfig, user) {\r\n    const oldConfig = { ...this.config };\r\n    this.config = { ...this.config, ...newConfig };\r\n\r\n    // Update backup directory if changed\r\n    if (newConfig.backupDir && newConfig.backupDir !== oldConfig.backupDir) {\r\n      this.backupDir = newConfig.backupDir;\r\n      await this.ensureDirectories();\r\n    }\r\n\r\n    // Log configuration change\r\n    await this.logAction(user, 'CONFIG_UPDATED', {\r\n      oldConfig,\r\n      newConfig,\r\n      changedFields: Object.keys(newConfig)\r\n    });\r\n\r\n    console.log(`[Site Editor] Configuration updated by ${user.name}`);\r\n  }\r\n\r\n  // Helper methods\r\n\r\n  getAbsolutePath(componentPath) {\r\n    // Remove leading slash if present\r\n    const cleanPath = componentPath.startsWith('/') ? componentPath.substring(1) : componentPath;\r\n    \r\n    // Remove src/components prefix if present\r\n    const relativePath = cleanPath.startsWith('src/components/') ? \r\n      cleanPath.substring('src/components/'.length) : cleanPath;\r\n    \r\n    return path.join(this.componentsDir, relativePath);\r\n  }\r\n\r\n  generateBackupToken() {\r\n    return crypto.randomBytes(16).toString('hex');\r\n  }\r\n\r\n  async findBackupByToken(token) {\r\n    try {\r\n      const backupsDir = path.join(this.backupDir, 'components');\r\n      const files = await fs.readdir(backupsDir);\r\n      \r\n      for (const file of files) {\r\n        if (file.includes(token) && file.endsWith('.backup.meta')) {\r\n          const metadataPath = path.join(backupsDir, file);\r\n          const metadata = JSON.parse(await fs.readFile(metadataPath, 'utf8'));\r\n          \r\n          if (metadata.token === token) {\r\n            return {\r\n              filePath: metadataPath.replace('.meta', ''),\r\n              metadataPath,\r\n              metadata\r\n            };\r\n          }\r\n        }\r\n      }\r\n      \r\n      return null;\r\n    } catch (error) {\r\n      console.error('[Site Editor] Failed to find backup:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  async cleanupOldBackups(componentPath) {\r\n    try {\r\n      const componentName = path.basename(componentPath, path.extname(componentPath));\r\n      const backups = await this.getBackups(componentName);\r\n      \r\n      if (backups.length > this.config.maxBackups) {\r\n        const toDelete = backups.slice(this.config.maxBackups);\r\n        \r\n        for (const backup of toDelete) {\r\n          await this.deleteBackup(backup.token);\r\n        }\r\n        \r\n        console.log(`[Site Editor] Cleaned up ${toDelete.length} old backups for ${componentName}`);\r\n      }\r\n    } catch (error) {\r\n      console.error('[Site Editor] Failed to cleanup old backups:', error);\r\n    }\r\n  }\r\n\r\n  async deleteBackup(token) {\r\n    const backupInfo = await this.findBackupByToken(token);\r\n    if (backupInfo) {\r\n      try {\r\n        await fs.unlink(backupInfo.filePath);\r\n        await fs.unlink(backupInfo.metadataPath);\r\n      } catch (error) {\r\n        console.error('[Site Editor] Failed to delete backup:', token, error);\r\n      }\r\n    }\r\n  }\r\n\r\n  getSessionId() {\r\n    return 'site-editor-' + Date.now();\r\n  }\r\n}\r\n\r\nmodule.exports = SiteEditorManager; "
    },
    "complexity": {
      "totalLines": 619,
      "codeLines": 444,
      "commentLines": 74,
      "commentRatio": 0.14285714285714285,
      "averageLineLength": 35.52509652509652
    },
    "lastAnalyzed": "2025-07-28T07:19:56.507Z"
  },
  "contentHash": "6aefd38677258fb32f55edc9dba751160d8b085d6d0ab75a6b6068ddbc0209aa",
  "discoveredAt": "2025-07-28T07:19:56.507Z"
}