{
  "id": "3c19ff6c145c",
  "originalPath": "/var/www/orthodox-church-mgmt/orthodoxmetrics/prod/server/services/websocketService.js",
  "relativePath": "server/services/websocketService.js",
  "name": "websocketService.js",
  "extension": ".js",
  "size": 20145,
  "modified": "2025-07-22T01:52:16.081Z",
  "created": "2025-07-22T01:52:13.709Z",
  "classification": {
    "type": "Server Scripts",
    "category": "Backend > Server",
    "confidence": 4
  },
  "metadata": {
    "fileStats": {
      "lines": 568,
      "characters": 20101,
      "words": 1595
    },
    "classification": {
      "type": "Server Scripts",
      "category": "Backend > Server",
      "confidence": 4
    },
    "dependencies": [
      {
        "type": "npm_package",
        "name": "socket.io",
        "line": 1
      },
      {
        "type": "npm_package",
        "name": "express-session",
        "line": 3
      }
    ],
    "security": {
      "findings": [
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 19,
          "redacted": true
        }
      ],
      "hasSecurityIssues": true,
      "redactedContent": "const { Server } = require('socket.io');\r\nconst { promisePool } = require('../../config/db');\r\nconst session = require('express-session');\r\n\r\nclass WebSocketService {\r\n    constructor() {\r\n        this.io = null;\r\n        this.userSockets = new Map(); // userId -> Set of socket IDs\r\n        this.socketUsers = new Map(); // socketId -> userId\r\n        this.conversationRooms = new Map(); // conversationId -> Set of user IDs\r\n    }\r\n\r\n    /**\r\n     * Initialize WebSocket server with Express app\r\n     */\r\n    initialize(server, sessionMiddleware) {\r\n        this.io = new Server(server, {\r\n            cors: {\r\n                origin: process.env.[REDACTED] || \"http://localhost:3000\",\r\n                methods: [\"GET\", \"POST\"],\r\n                credentials: true\r\n            },\r\n            transports: ['websocket', 'polling']\r\n        });\r\n\r\n        // Use session middleware for authentication\r\n        this.io.use((socket, next) => {\r\n            sessionMiddleware(socket.request, {}, next);\r\n        });\r\n\r\n        // Authentication middleware\r\n        this.io.use(async (socket, next) => {\r\n            try {\r\n                const session = socket.request.session;\r\n                \r\n                if (!session || !session.user) {\r\n                    console.log('üîí WebSocket connection rejected: No session');\r\n                    return next(new Error('Authentication required'));\r\n                }\r\n\r\n                socket.userId = session.user.id;\r\n                socket.userEmail = session.user.email;\r\n                socket.userName = `${session.user.first_name} ${session.user.last_name}`;\r\n                \r\n                console.log(`üîå WebSocket authenticated: ${socket.userEmail} (${socket.userId})`);\r\n                next();\r\n            } catch (error) {\r\n                console.error('üîí WebSocket auth error:', error);\r\n                next(new Error('Authentication failed'));\r\n            }\r\n        });\r\n\r\n        this.setupEventHandlers();\r\n        console.log('üöÄ WebSocket service initialized');\r\n    }\r\n\r\n    /**\r\n     * Set up all WebSocket event handlers\r\n     */\r\n    setupEventHandlers() {\r\n        this.io.on('connection', (socket) => {\r\n            this.handleConnection(socket);\r\n            \r\n            // Chat events\r\n            socket.on('join_conversation', (data) => this.handleJoinConversation(socket, data));\r\n            socket.on('leave_conversation', (data) => this.handleLeaveConversation(socket, data));\r\n            socket.on('send_message', (data) => this.handleSendMessage(socket, data));\r\n            socket.on('typing_start', (data) => this.handleTypingStart(socket, data));\r\n            socket.on('typing_stop', (data) => this.handleTypingStop(socket, data));\r\n            socket.on('message_read', (data) => this.handleMessageRead(socket, data));\r\n            \r\n            // Notification events\r\n            socket.on('mark_notification_read', (data) => this.handleMarkNotificationRead(socket, data));\r\n            \r\n            // Presence events\r\n            socket.on('update_presence', (data) => this.handleUpdatePresence(socket, data));\r\n            \r\n            // Disconnect\r\n            socket.on('disconnect', () => this.handleDisconnection(socket));\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Handle new WebSocket connection\r\n     */\r\n    async handleConnection(socket) {\r\n        const userId = socket.userId;\r\n        \r\n        try {\r\n            // Track user socket\r\n            if (!this.userSockets.has(userId)) {\r\n                this.userSockets.set(userId, new Set());\r\n            }\r\n            this.userSockets.get(userId).add(socket.id);\r\n            this.socketUsers.set(socket.id, userId);\r\n\r\n            // Update user online status\r\n            await this.updateUserOnlineStatus(userId, true);\r\n\r\n            // Join user to their personal notification room\r\n            socket.join(`user_${userId}`);\r\n\r\n            // Get user's active conversations and join them\r\n            await this.joinUserConversations(socket, userId);\r\n\r\n            // Notify friends about online status\r\n            await this.broadcastPresenceUpdate(userId, true);\r\n\r\n            console.log(`‚úÖ User ${socket.userEmail} connected (${socket.id})`);\r\n            \r\n            // Send initial data\r\n            socket.emit('connection_success', {\r\n                message: 'Connected to real-time service',\r\n                timestamp: new Date().toISOString()\r\n            });\r\n\r\n        } catch (error) {\r\n            console.error('‚ùå Error handling connection:', error);\r\n            socket.disconnect();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle WebSocket disconnection\r\n     */\r\n    async handleDisconnection(socket) {\r\n        const userId = socket.userId;\r\n        \r\n        try {\r\n            // Remove socket from tracking\r\n            if (this.userSockets.has(userId)) {\r\n                this.userSockets.get(userId).delete(socket.id);\r\n                \r\n                // If no more sockets for this user, mark offline\r\n                if (this.userSockets.get(userId).size === 0) {\r\n                    this.userSockets.delete(userId);\r\n                    await this.updateUserOnlineStatus(userId, false);\r\n                    await this.broadcastPresenceUpdate(userId, false);\r\n                }\r\n            }\r\n            \r\n            this.socketUsers.delete(socket.id);\r\n            console.log(`‚ùå User ${socket.userEmail} disconnected (${socket.id})`);\r\n            \r\n        } catch (error) {\r\n            console.error('‚ùå Error handling disconnection:', error);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Join user to their active conversations\r\n     */\r\n    async joinUserConversations(socket, userId) {\r\n        try {\r\n            const [conversations] = await promisePool.query(`\r\n                SELECT DISTINCT c.id \r\n                FROM chat_conversations c\r\n                JOIN chat_participants p ON c.id = p.conversation_id\r\n                WHERE p.user_id = ? AND p.is_active = 1 AND c.is_active = 1\r\n            `, [userId]);\r\n\r\n            for (const conv of conversations) {\r\n                socket.join(`conversation_${conv.id}`);\r\n                \r\n                // Track conversation membership\r\n                if (!this.conversationRooms.has(conv.id)) {\r\n                    this.conversationRooms.set(conv.id, new Set());\r\n                }\r\n                this.conversationRooms.get(conv.id).add(userId);\r\n            }\r\n\r\n            console.log(`üë• User ${userId} joined ${conversations.length} conversations`);\r\n        } catch (error) {\r\n            console.error('‚ùå Error joining user conversations:', error);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle joining a specific conversation\r\n     */\r\n    async handleJoinConversation(socket, data) {\r\n        const { conversationId } = data;\r\n        const userId = socket.userId;\r\n\r\n        try {\r\n            // Verify user is a participant\r\n            const [participant] = await promisePool.query(`\r\n                SELECT id FROM chat_participants \r\n                WHERE conversation_id = ? AND user_id = ? AND is_active = 1\r\n            `, [conversationId, userId]);\r\n\r\n            if (participant.length === 0) {\r\n                socket.emit('error', { message: 'Not authorized for this conversation' });\r\n                return;\r\n            }\r\n\r\n            socket.join(`conversation_${conversationId}`);\r\n            \r\n            // Track conversation membership\r\n            if (!this.conversationRooms.has(conversationId)) {\r\n                this.conversationRooms.set(conversationId, new Set());\r\n            }\r\n            this.conversationRooms.get(conversationId).add(userId);\r\n\r\n            console.log(`üë• User ${userId} joined conversation ${conversationId}`);\r\n            \r\n            socket.emit('conversation_joined', { conversationId });\r\n            \r\n        } catch (error) {\r\n            console.error('‚ùå Error joining conversation:', error);\r\n            socket.emit('error', { message: 'Failed to join conversation' });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle leaving a conversation\r\n     */\r\n    handleLeaveConversation(socket, data) {\r\n        const { conversationId } = data;\r\n        const userId = socket.userId;\r\n\r\n        socket.leave(`conversation_${conversationId}`);\r\n        \r\n        if (this.conversationRooms.has(conversationId)) {\r\n            this.conversationRooms.get(conversationId).delete(userId);\r\n        }\r\n\r\n        console.log(`üëã User ${userId} left conversation ${conversationId}`);\r\n        socket.emit('conversation_left', { conversationId });\r\n    }\r\n\r\n    /**\r\n     * Handle sending a message\r\n     */\r\n    async handleSendMessage(socket, data) {\r\n        const { conversationId, content, messageType = 'text', replyToId } = data;\r\n        const userId = socket.userId;\r\n\r\n        try {\r\n            // Verify user is a participant\r\n            const [participant] = await promisePool.query(`\r\n                SELECT id FROM chat_participants \r\n                WHERE conversation_id = ? AND user_id = ?\r\n            `, [conversationId, userId]);\r\n\r\n            if (participant.length === 0) {\r\n                socket.emit('error', { message: 'Not authorized for this conversation' });\r\n                return;\r\n            }\r\n\r\n            // Save message to database\r\n            const [result] = await promisePool.query(`\r\n                INSERT INTO chat_messages (conversation_id, sender_id, content, message_type, reply_to_id)\r\n                VALUES (?, ?, ?, ?, ?)\r\n            `, [conversationId, userId, content, messageType, replyToId]);\r\n\r\n            const messageId = result.insertId;\r\n\r\n            // Get sender info for the message\r\n            const [senderInfo] = await promisePool.query(`\r\n                SELECT u.id, u.first_name, u.last_name, up.display_name, up.profile_image_url\r\n                FROM users u\r\n                LEFT JOIN user_profiles up ON up.user_id = u.id\r\n                WHERE u.id = ?\r\n            `, [userId]);\r\n\r\n            const messageData = {\r\n                id: messageId,\r\n                conversation_id: conversationId,\r\n                sender_id: userId,\r\n                content,\r\n                message_type: messageType,\r\n                reply_to_id: replyToId,\r\n                created_at: new Date().toISOString(),\r\n                sender: senderInfo[0],\r\n                is_edited: false,\r\n                is_deleted: false\r\n            };\r\n\r\n            // Update conversation last activity\r\n            await promisePool.query(`\r\n                UPDATE chat_conversations \r\n                SET last_message_id = ?, last_activity = NOW() \r\n                WHERE id = ?\r\n            `, [messageId, conversationId]);\r\n\r\n            // Broadcast to conversation participants\r\n            this.io.to(`conversation_${conversationId}`).emit('new_message', messageData);\r\n\r\n            // Send notifications to offline participants\r\n            await this.sendMessageNotifications(conversationId, userId, content, messageId);\r\n\r\n            console.log(`üí¨ Message ${messageId} sent in conversation ${conversationId}`);\r\n\r\n        } catch (error) {\r\n            console.error('‚ùå Error sending message:', error);\r\n            socket.emit('error', { message: 'Failed to send message' });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle typing indicators\r\n     */\r\n    handleTypingStart(socket, data) {\r\n        const { conversationId } = data;\r\n        const userId = socket.userId;\r\n\r\n        socket.to(`conversation_${conversationId}`).emit('user_typing', {\r\n            conversationId,\r\n            userId,\r\n            userName: socket.userName,\r\n            isTyping: true\r\n        });\r\n    }\r\n\r\n    handleTypingStop(socket, data) {\r\n        const { conversationId } = data;\r\n        const userId = socket.userId;\r\n\r\n        socket.to(`conversation_${conversationId}`).emit('user_typing', {\r\n            conversationId,\r\n            userId,\r\n            userName: socket.userName,\r\n            isTyping: false\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Handle message read receipts\r\n     */\r\n    async handleMessageRead(socket, data) {\r\n        const { conversationId, messageId } = data;\r\n        const userId = socket.userId;\r\n\r\n        try {\r\n            // Update last read timestamp\r\n            await promisePool.query(`\r\n                UPDATE chat_participants \r\n                SET last_read_at = NOW() \r\n                WHERE conversation_id = ? AND user_id = ?\r\n            `, [conversationId, userId]);\r\n\r\n            // Broadcast read receipt to conversation\r\n            socket.to(`conversation_${conversationId}`).emit('message_read', {\r\n                conversationId,\r\n                messageId,\r\n                userId,\r\n                readAt: new Date().toISOString()\r\n            });\r\n\r\n        } catch (error) {\r\n            console.error('‚ùå Error updating read receipt:', error);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle notification read\r\n     */\r\n    async handleMarkNotificationRead(socket, data) {\r\n        const { notificationId } = data;\r\n        const userId = socket.userId;\r\n\r\n        try {\r\n            await promisePool.query(`\r\n                UPDATE notifications \r\n                SET is_read = TRUE \r\n                WHERE id = ? AND user_id = ?\r\n            `, [notificationId, userId]);\r\n\r\n            socket.emit('notification_read', { notificationId });\r\n\r\n        } catch (error) {\r\n            console.error('‚ùå Error marking notification as read:', error);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle presence updates\r\n     */\r\n    async handleUpdatePresence(socket, data) {\r\n        const { status } = data; // 'online', 'away', 'busy', 'offline'\r\n        const userId = socket.userId;\r\n\r\n        try {\r\n            await promisePool.query(`\r\n                UPDATE user_profiles \r\n                SET last_seen = NOW() \r\n                WHERE user_id = ?\r\n            `, [userId]);\r\n\r\n            await this.broadcastPresenceUpdate(userId, status !== 'offline');\r\n\r\n        } catch (error) {\r\n            console.error('‚ùå Error updating presence:', error);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update user online status in database\r\n     */\r\n    async updateUserOnlineStatus(userId, isOnline) {\r\n        try {\r\n            await promisePool.query(`\r\n                INSERT INTO user_profiles (user_id, is_online, last_seen)\r\n                VALUES (?, ?, NOW())\r\n                ON DUPLICATE KEY UPDATE \r\n                is_online = VALUES(is_online), \r\n                last_seen = VALUES(last_seen)\r\n            `, [userId, isOnline]);\r\n\r\n        } catch (error) {\r\n            console.error('‚ùå Error updating online status:', error);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Broadcast presence update to friends\r\n     */\r\n    async broadcastPresenceUpdate(userId, isOnline) {\r\n        try {\r\n            // Get user's friends\r\n            const [friends] = await promisePool.query(`\r\n                SELECT friend_id FROM user_friends_view WHERE user_id = ?\r\n            `, [userId]);\r\n\r\n            // Notify each online friend\r\n            for (const friend of friends) {\r\n                if (this.userSockets.has(friend.friend_id)) {\r\n                    this.io.to(`user_${friend.friend_id}`).emit('friend_presence_update', {\r\n                        userId,\r\n                        isOnline,\r\n                        timestamp: new Date().toISOString()\r\n                    });\r\n                }\r\n            }\r\n\r\n        } catch (error) {\r\n            console.error('‚ùå Error broadcasting presence update:', error);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send message notifications to offline participants\r\n     */\r\n    async sendMessageNotifications(conversationId, senderId, content, messageId) {\r\n        try {\r\n            // Get participants who are not online\r\n            const [participants] = await promisePool.query(`\r\n                SELECT p.user_id, u.first_name, u.last_name\r\n                FROM chat_participants p\r\n                JOIN users u ON u.id = p.user_id\r\n                WHERE p.conversation_id = ? AND p.user_id != ? AND p.is_active = 1\r\n            `, [conversationId, senderId]);\r\n\r\n            // Get sender info\r\n            const [senderInfo] = await promisePool.query(`\r\n                SELECT first_name, last_name FROM users WHERE id = ?\r\n            `, [senderId]);\r\n\r\n            const senderName = `${senderInfo[0].first_name} ${senderInfo[0].last_name}`;\r\n\r\n            for (const participant of participants) {\r\n                // Check if user is online\r\n                const isOnline = this.userSockets.has(participant.user_id);\r\n                \r\n                if (isOnline) {\r\n                    // Send real-time notification\r\n                    this.io.to(`user_${participant.user_id}`).emit('new_notification', {\r\n                        type: 'chat_message',\r\n                        title: 'New Message',\r\n                        message: `${senderName}: ${content.substring(0, 50)}${content.length > 50 ? '...' : ''}`,\r\n                        data: {\r\n                            conversation_id: conversationId,\r\n                            message_id: messageId,\r\n                            sender_id: senderId\r\n                        },\r\n                        timestamp: new Date().toISOString()\r\n                    });\r\n                }\r\n\r\n                // Always create database notification for message history\r\n                await promisePool.query(`\r\n                    INSERT INTO notifications (user_id, type, title, message, sender_id, data)\r\n                    VALUES (?, 'chat_message', 'New Message', ?, ?, ?)\r\n                `, [\r\n                    participant.user_id,\r\n                    `${senderName}: ${content.substring(0, 100)}${content.length > 100 ? '...' : ''}`,\r\n                    senderId,\r\n                    JSON.stringify({\r\n                        conversation_id: conversationId,\r\n                        message_id: messageId\r\n                    })\r\n                ]);\r\n            }\r\n\r\n        } catch (error) {\r\n            console.error('‚ùå Error sending message notifications:', error);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send notification to specific user\r\n     */\r\n    async sendNotificationToUser(userId, notification) {\r\n        try {\r\n            // Send real-time notification if user is online\r\n            if (this.userSockets.has(userId)) {\r\n                this.io.to(`user_${userId}`).emit('new_notification', notification);\r\n            }\r\n\r\n            // Always save to database\r\n            await promisePool.query(`\r\n                INSERT INTO notifications (user_id, type, title, message, sender_id, data, priority)\r\n                VALUES (?, ?, ?, ?, ?, ?, ?)\r\n            `, [\r\n                userId,\r\n                notification.type,\r\n                notification.title,\r\n                notification.message,\r\n                notification.sender_id || null,\r\n                JSON.stringify(notification.data || {}),\r\n                notification.priority || 'normal'\r\n            ]);\r\n\r\n        } catch (error) {\r\n            console.error('‚ùå Error sending notification to user:', error);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Broadcast notification to multiple users\r\n     */\r\n    async broadcastNotification(userIds, notification) {\r\n        for (const userId of userIds) {\r\n            await this.sendNotificationToUser(userId, notification);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get online users count\r\n     */\r\n    getOnlineUsersCount() {\r\n        return this.userSockets.size;\r\n    }\r\n\r\n    /**\r\n     * Get user's socket instances\r\n     */\r\n    getUserSockets(userId) {\r\n        return this.userSockets.get(userId) || new Set();\r\n    }\r\n\r\n    /**\r\n     * Check if user is online\r\n     */\r\n    isUserOnline(userId) {\r\n        return this.userSockets.has(userId);\r\n    }\r\n\r\n    /**\r\n     * Get conversation participants count\r\n     */\r\n    getConversationParticipants(conversationId) {\r\n        return this.conversationRooms.get(conversationId) || new Set();\r\n    }\r\n}\r\n\r\nmodule.exports = new WebSocketService(); "
    },
    "complexity": {
      "totalLines": 568,
      "codeLines": 379,
      "commentLines": 97,
      "commentRatio": 0.20378151260504201,
      "averageLineLength": 40.37394957983193
    },
    "lastAnalyzed": "2025-07-28T07:20:01.132Z"
  },
  "contentHash": "7153ba2a08bae51d3f3d491eb540acb7cbbbfab382882a66a7adc7eb3e225a0a",
  "discoveredAt": "2025-07-28T07:20:01.132Z"
}