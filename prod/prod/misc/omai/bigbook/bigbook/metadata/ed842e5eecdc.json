{
  "id": "ed842e5eecdc",
  "originalPath": "/var/www/orthodox-church-mgmt/orthodoxmetrics/prod/server/utils/headlineCache.js",
  "relativePath": "server/utils/headlineCache.js",
  "name": "headlineCache.js",
  "extension": ".js",
  "size": 11221,
  "modified": "2025-07-22T16:27:34.306Z",
  "created": "2025-07-22T16:27:31.130Z",
  "classification": {
    "type": "Server Scripts",
    "category": "Backend > Server",
    "confidence": 3
  },
  "metadata": {
    "fileStats": {
      "lines": 362,
      "characters": 11175,
      "words": 1072
    },
    "classification": {
      "type": "Server Scripts",
      "category": "Backend > Server",
      "confidence": 3
    },
    "dependencies": [
      {
        "type": "npm_package",
        "name": "node-cache",
        "line": 7
      },
      {
        "type": "npm_package",
        "name": "redis",
        "line": 30
      }
    ],
    "security": {
      "findings": [
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 15,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 32,
          "redacted": true
        }
      ],
      "hasSecurityIssues": true,
      "redactedContent": "/**\r\n * Orthodox Headlines Caching System\r\n * Provides memory and Redis-based caching for headlines API\r\n * Reduces database load and improves performance\r\n */\r\n\r\nconst NodeCache = require('node-cache');\r\n\r\n// Configuration\r\nconst CACHE_CONFIG = {\r\n    MEMORY_TTL: 3 * 60 * 60, // 3 hours in seconds\r\n    REDIS_TTL: 6 * 60 * 60,  // 6 hours in seconds\r\n    MEMORY_CHECK_PERIOD: 60, // Check for expired keys every 60 seconds\r\n    MAX_MEMORY_KEYS: 100,    // Maximum keys in memory cache\r\n    ENABLE_REDIS: process.env.[REDACTED] ? true : false\r\n};\r\n\r\n// Memory cache instance\r\nconst memoryCache = new NodeCache({\r\n    stdTTL: CACHE_CONFIG.MEMORY_TTL,\r\n    checkperiod: CACHE_CONFIG.MEMORY_CHECK_PERIOD,\r\n    maxKeys: CACHE_CONFIG.MAX_MEMORY_KEYS,\r\n    useClones: false // Better performance, but be careful with object mutations\r\n});\r\n\r\n// Redis client (optional)\r\nlet redisClient = null;\r\nif (CACHE_CONFIG.ENABLE_REDIS) {\r\n    try {\r\n        const redis = require('redis');\r\n        redisClient = redis.createClient({\r\n            url: process.env.[REDACTED],\r\n            retry_strategy: (options) => {\r\n                if (options.error && options.error.code === 'ECONNREFUSED') {\r\n                    console.log('Redis connection refused');\r\n                    return new Error('Redis server connection refused');\r\n                }\r\n                if (options.total_retry_time > 1000 * 60 * 60) {\r\n                    return new Error('Retry time exhausted');\r\n                }\r\n                if (options.attempt > 10) {\r\n                    return undefined;\r\n                }\r\n                return Math.min(options.attempt * 100, 3000);\r\n            }\r\n        });\r\n\r\n        redisClient.on('error', (err) => {\r\n            console.log('Redis Client Error:', err);\r\n        });\r\n\r\n        redisClient.on('connect', () => {\r\n            console.log('‚úÖ Redis connected for headlines caching');\r\n        });\r\n\r\n        redisClient.connect();\r\n    } catch (error) {\r\n        console.log('‚ö†Ô∏è Redis not available, using memory cache only:', error.message);\r\n        redisClient = null;\r\n    }\r\n}\r\n\r\n/**\r\n * Headlines Cache Class\r\n */\r\nclass HeadlinesCache {\r\n    constructor() {\r\n        this.stats = {\r\n            hits: 0,\r\n            misses: 0,\r\n            sets: 0,\r\n            deletes: 0\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Generate cache key for headlines request\r\n     */\r\n    generateKey(params) {\r\n        const { source = 'all', lang = 'en', limit = 20, offset = 0 } = params;\r\n        return `headlines:${source}:${lang}:${limit}:${offset}`;\r\n    }\r\n\r\n    /**\r\n     * Generate cache key for sources list\r\n     */\r\n    generateSourcesKey() {\r\n        return 'headlines:sources';\r\n    }\r\n\r\n    /**\r\n     * Generate cache key for languages list\r\n     */\r\n    generateLanguagesKey() {\r\n        return 'headlines:languages';\r\n    }\r\n\r\n    /**\r\n     * Get cached data\r\n     */\r\n    async get(key) {\r\n        try {\r\n            // Try memory cache first (fastest)\r\n            const memoryResult = memoryCache.get(key);\r\n            if (memoryResult) {\r\n                this.stats.hits++;\r\n                console.log(`üìã Memory cache hit: ${key}`);\r\n                return memoryResult;\r\n            }\r\n\r\n            // Try Redis cache if available\r\n            if (redisClient && redisClient.isOpen) {\r\n                const redisResult = await redisClient.get(key);\r\n                if (redisResult) {\r\n                    const parsed = JSON.parse(redisResult);\r\n                    \r\n                    // Store in memory cache for faster future access\r\n                    memoryCache.set(key, parsed, CACHE_CONFIG.MEMORY_TTL);\r\n                    \r\n                    this.stats.hits++;\r\n                    console.log(`üìã Redis cache hit: ${key}`);\r\n                    return parsed;\r\n                }\r\n            }\r\n\r\n            this.stats.misses++;\r\n            console.log(`üìã Cache miss: ${key}`);\r\n            return null;\r\n        } catch (error) {\r\n            console.error('‚ùå Cache get error:', error.message);\r\n            this.stats.misses++;\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set cached data\r\n     */\r\n    async set(key, data, customTTL = null) {\r\n        try {\r\n            const memoryTTL = customTTL || CACHE_CONFIG.MEMORY_TTL;\r\n            const redisTTL = customTTL || CACHE_CONFIG.REDIS_TTL;\r\n\r\n            // Store in memory cache\r\n            memoryCache.set(key, data, memoryTTL);\r\n\r\n            // Store in Redis cache if available\r\n            if (redisClient && redisClient.isOpen) {\r\n                await redisClient.setEx(key, redisTTL, JSON.stringify(data));\r\n            }\r\n\r\n            this.stats.sets++;\r\n            console.log(`üíæ Cached: ${key} (TTL: ${memoryTTL}s)`);\r\n        } catch (error) {\r\n            console.error('‚ùå Cache set error:', error.message);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Delete cached data\r\n     */\r\n    async delete(key) {\r\n        try {\r\n            // Delete from memory cache\r\n            memoryCache.del(key);\r\n\r\n            // Delete from Redis cache if available\r\n            if (redisClient && redisClient.isOpen) {\r\n                await redisClient.del(key);\r\n            }\r\n\r\n            this.stats.deletes++;\r\n            console.log(`üóëÔ∏è Cache deleted: ${key}`);\r\n        } catch (error) {\r\n            console.error('‚ùå Cache delete error:', error.message);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clear all headlines cache\r\n     */\r\n    async clearAll() {\r\n        try {\r\n            // Clear memory cache\r\n            const memoryKeys = memoryCache.keys();\r\n            const headlineKeys = memoryKeys.filter(key => key.startsWith('headlines:'));\r\n            headlineKeys.forEach(key => memoryCache.del(key));\r\n\r\n            // Clear Redis cache if available\r\n            if (redisClient && redisClient.isOpen) {\r\n                const redisKeys = await redisClient.keys('headlines:*');\r\n                if (redisKeys.length > 0) {\r\n                    await redisClient.del(redisKeys);\r\n                }\r\n            }\r\n\r\n            console.log(`üßπ Cleared ${headlineKeys.length} cached headline entries`);\r\n        } catch (error) {\r\n            console.error('‚ùå Cache clear error:', error.message);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Cache wrapper for headlines API\r\n     */\r\n    async cacheHeadlines(params, dataLoader) {\r\n        const key = this.generateKey(params);\r\n        \r\n        // Try to get from cache first\r\n        const cached = await this.get(key);\r\n        if (cached) {\r\n            return cached;\r\n        }\r\n\r\n        // Load data from database\r\n        const data = await dataLoader();\r\n        \r\n        // Cache the result\r\n        await this.set(key, data);\r\n        \r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Cache wrapper for sources API\r\n     */\r\n    async cacheSources(dataLoader) {\r\n        const key = this.generateSourcesKey();\r\n        \r\n        // Try to get from cache first\r\n        const cached = await this.get(key);\r\n        if (cached) {\r\n            return cached;\r\n        }\r\n\r\n        // Load data from database\r\n        const data = await dataLoader();\r\n        \r\n        // Cache the result (sources change less frequently, longer TTL)\r\n        await this.set(key, data, CACHE_CONFIG.MEMORY_TTL * 2);\r\n        \r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Cache wrapper for languages API\r\n     */\r\n    async cacheLanguages(dataLoader) {\r\n        const key = this.generateLanguagesKey();\r\n        \r\n        // Try to get from cache first\r\n        const cached = await this.get(key);\r\n        if (cached) {\r\n            return cached;\r\n        }\r\n\r\n        // Load data from database\r\n        const data = await dataLoader();\r\n        \r\n        // Cache the result (languages change less frequently, longer TTL)\r\n        await this.set(key, data, CACHE_CONFIG.MEMORY_TTL * 2);\r\n        \r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Invalidate cache when new articles are added\r\n     */\r\n    async invalidateHeadlinesCache() {\r\n        try {\r\n            console.log('üîÑ Invalidating headlines cache...');\r\n            \r\n            // Get all cache keys\r\n            const memoryKeys = memoryCache.keys();\r\n            const headlineKeys = memoryKeys.filter(key => key.startsWith('headlines:'));\r\n            \r\n            // Delete all headline-related cache entries\r\n            headlineKeys.forEach(key => memoryCache.del(key));\r\n            \r\n            // Clear Redis cache if available\r\n            if (redisClient && redisClient.isOpen) {\r\n                const redisKeys = await redisClient.keys('headlines:*');\r\n                if (redisKeys.length > 0) {\r\n                    await redisClient.del(redisKeys);\r\n                }\r\n            }\r\n\r\n            console.log(`üóëÔ∏è Invalidated ${headlineKeys.length} cache entries`);\r\n        } catch (error) {\r\n            console.error('‚ùå Cache invalidation error:', error.message);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get cache statistics\r\n     */\r\n    getStats() {\r\n        const hitRate = this.stats.hits + this.stats.misses > 0 \r\n            ? (this.stats.hits / (this.stats.hits + this.stats.misses) * 100).toFixed(2)\r\n            : 0;\r\n\r\n        return {\r\n            ...this.stats,\r\n            hitRate: `${hitRate}%`,\r\n            memoryKeys: memoryCache.keys().length,\r\n            memorySize: memoryCache.getStats(),\r\n            redisConnected: redisClient ? redisClient.isOpen : false,\r\n            config: CACHE_CONFIG\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Warm up cache with popular queries\r\n     */\r\n    async warmUp(dataLoader) {\r\n        console.log('üî• Warming up headlines cache...');\r\n        \r\n        const popularQueries = [\r\n            { source: 'all', lang: 'en', limit: 20, offset: 0 },\r\n            { source: 'GOARCH', lang: 'en', limit: 20, offset: 0 },\r\n            { source: 'OCA', lang: 'en', limit: 20, offset: 0 },\r\n            { source: 'ORTHODOX_TIMES', lang: 'en', limit: 20, offset: 0 },\r\n            { source: 'all', lang: 'el', limit: 20, offset: 0 },\r\n            { source: 'all', lang: 'ru', limit: 20, offset: 0 }\r\n        ];\r\n\r\n        for (const params of popularQueries) {\r\n            try {\r\n                await this.cacheHeadlines(params, () => dataLoader(params));\r\n                await new Promise(resolve => setTimeout(resolve, 100)); // Small delay\r\n            } catch (error) {\r\n                console.error(`‚ùå Error warming up cache for ${JSON.stringify(params)}:`, error.message);\r\n            }\r\n        }\r\n\r\n        console.log('‚úÖ Cache warm-up completed');\r\n    }\r\n\r\n    /**\r\n     * Close connections\r\n     */\r\n    async close() {\r\n        try {\r\n            memoryCache.close();\r\n            if (redisClient && redisClient.isOpen) {\r\n                await redisClient.disconnect();\r\n            }\r\n            console.log('‚úÖ Headlines cache connections closed');\r\n        } catch (error) {\r\n            console.error('‚ùå Error closing cache connections:', error.message);\r\n        }\r\n    }\r\n}\r\n\r\n// Export singleton instance\r\nconst headlinesCache = new HeadlinesCache();\r\n\r\nmodule.exports = {\r\n    headlinesCache,\r\n    HeadlinesCache,\r\n    CACHE_CONFIG\r\n}; "
    },
    "complexity": {
      "totalLines": 362,
      "codeLines": 232,
      "commentLines": 75,
      "commentRatio": 0.24429967426710097,
      "averageLineLength": 34.53745928338762
    },
    "lastAnalyzed": "2025-07-28T07:20:01.254Z"
  },
  "contentHash": "ef0a53d98d084352900e94e3d88f4f1a569d18938ce133f0bb90a279f8aebc0f",
  "discoveredAt": "2025-07-28T07:20:01.254Z"
}