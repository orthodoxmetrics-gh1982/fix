{
  "id": "80285e03549f",
  "originalPath": "/var/www/orthodox-church-mgmt/orthodoxmetrics/prod/server/routes/ocrSessions.js",
  "relativePath": "server/routes/ocrSessions.js",
  "name": "ocrSessions.js",
  "extension": ".js",
  "size": 15775,
  "modified": "2025-07-07T23:08:19.000Z",
  "created": "2025-07-09T00:48:38.482Z",
  "classification": {
    "type": "Server Scripts",
    "category": "Backend > Server",
    "confidence": 7
  },
  "metadata": {
    "fileStats": {
      "lines": 532,
      "characters": 15775,
      "words": 1631
    },
    "classification": {
      "type": "Server Scripts",
      "category": "Backend > Server",
      "confidence": 7
    },
    "dependencies": [
      {
        "type": "npm_package",
        "name": "express",
        "line": 2
      },
      {
        "type": "npm_package",
        "name": "multer",
        "line": 3
      },
      {
        "type": "npm_package",
        "name": "path",
        "line": 4
      },
      {
        "type": "npm_package",
        "name": "fs",
        "line": 5
      },
      {
        "type": "npm_package",
        "name": "uuid",
        "line": 6
      },
      {
        "type": "npm_package",
        "name": "qrcode",
        "line": 7
      }
    ],
    "security": {
      "findings": [
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 16,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 27,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 280,
          "redacted": true
        }
      ],
      "hasSecurityIssues": true,
      "redactedContent": "// server/routes/ocrSessions.js\r\nconst express = require('express');\r\nconst multer = require('multer');\r\nconst path = require('path');\r\nconst fs = require('fs');\r\nconst { v4: uuidv4 } = require('uuid');\r\nconst qrcode = require('qrcode');\r\nconst { promisePool } = require('../../config/db');\r\nconst { validateUserAuth } = require('../middleware/sessionValidation');\r\n\r\nconst router = express.Router();\r\n\r\n// Configure multer for secure uploads\r\nconst storage = multer.diskStorage({\r\n  destination: (req, file, cb) => {\r\n    cb(null, process.env.[REDACTED] || './uploads');\r\n  },\r\n  filename: (req, file, cb) => {\r\n    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);\r\n    cb(null, file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname));\r\n  }\r\n});\r\n\r\nconst upload = multer({\r\n  storage,\r\n  limits: {\r\n    fileSize: parseInt(process.env.[REDACTED]) || 20 * 1024 * 1024, // 20MB\r\n    files: 1 // Only one file per upload for secure session\r\n  },\r\n  fileFilter: (req, file, cb) => {\r\n    const allowedTypes = [\r\n      'image/jpeg',\r\n      'image/png',\r\n      'image/tiff',\r\n      'image/gif',\r\n      'image/webp',\r\n      'application/pdf'\r\n    ];\r\n\r\n    if (allowedTypes.includes(file.mimetype)) {\r\n      cb(null, true);\r\n    } else {\r\n      cb(new Error(`Unsupported file type: ${file.mimetype}`), false);\r\n    }\r\n  }\r\n});\r\n\r\n// Create new OCR session with barcode\r\nrouter.post('/session', validateUserAuth, async (req, res) => {\r\n  try {\r\n    const {\r\n      churchId,\r\n      recordType = 'baptism',\r\n      expiryMinutes = 30,\r\n      userEmail,\r\n      userPhone\r\n    } = req.body;\r\n\r\n    // Generate unique session ID and PIN\r\n    const sessionId = uuidv4();\r\n    const pin = Math.floor(100000 + Math.random() * 900000).toString(); // 6-digit PIN\r\n\r\n    // Calculate expiry time\r\n    const expiresAt = new Date();\r\n    expiresAt.setMinutes(expiresAt.getMinutes() + expiryMinutes);\r\n\r\n    // Store session in database\r\n    await promisePool.query(`\r\n      INSERT INTO ocr_sessions (\r\n        session_id, \r\n        pin, \r\n        church_id, \r\n        record_type, \r\n        created_by, \r\n        expires_at, \r\n        verified, \r\n        used,\r\n        user_email,\r\n        user_phone\r\n      ) VALUES (?, ?, ?, ?, ?, ?, FALSE, FALSE, ?, ?)\r\n    `, [\r\n      sessionId,\r\n      pin,\r\n      churchId || req.session.user.churchId || 1,\r\n      recordType,\r\n      req.session.user.id,\r\n      expiresAt,\r\n      userEmail,\r\n      userPhone\r\n    ]);\r\n\r\n    // Generate QR code containing session info\r\n    const qrData = JSON.stringify({\r\n      sessionId,\r\n      pin,\r\n      type: 'ocr_session',\r\n      churchId: churchId || req.session.user.churchId || 1,\r\n      expiresAt: expiresAt.toISOString()\r\n    });\r\n\r\n    // Generate QR code as PNG buffer\r\n    const qrCodeBuffer = await qrcode.toBuffer(qrData, {\r\n      type: 'png',\r\n      quality: 0.92,\r\n      margin: 1,\r\n      color: {\r\n        dark: '#000000',\r\n        light: '#FFFFFF'\r\n      },\r\n      width: 256\r\n    });\r\n\r\n    // Also generate as data URL for immediate display\r\n    const qrCodeDataURL = await qrcode.toDataURL(qrData, {\r\n      quality: 0.92,\r\n      margin: 1,\r\n      width: 256\r\n    });\r\n\r\n    res.json({\r\n      sessionId,\r\n      pin,\r\n      expiresAt: expiresAt.toISOString(),\r\n      qrCodeDataURL,\r\n      message: 'OCR session created successfully. Please scan the QR code to verify.',\r\n      instructions: [\r\n        '1. Scan the QR code with your mobile device',\r\n        '2. Enter the 6-digit PIN when prompted',\r\n        '3. Upload your document images',\r\n        '4. Review and download OCR results'\r\n      ]\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error creating OCR session:', error);\r\n    res.status(500).json({ error: 'Failed to create OCR session' });\r\n  }\r\n});\r\n\r\n// Verify session with PIN (typically called from mobile/barcode scanner)\r\nrouter.post('/session/verify', async (req, res) => {\r\n  try {\r\n    const { sessionId, pin } = req.body;\r\n\r\n    if (!sessionId || !pin) {\r\n      return res.status(400).json({ error: 'Session ID and PIN are required' });\r\n    }\r\n\r\n    // Look up session\r\n    const [sessions] = await promisePool.query(\r\n      'SELECT * FROM ocr_sessions WHERE session_id = ? AND pin = ?',\r\n      [sessionId, pin]\r\n    );\r\n\r\n    if (sessions.length === 0) {\r\n      return res.status(404).json({ error: 'Invalid session ID or PIN' });\r\n    }\r\n\r\n    const session = sessions[0];\r\n\r\n    // Check if expired\r\n    const now = new Date();\r\n    const expiresAt = new Date(session.expires_at);\r\n\r\n    if (now > expiresAt) {\r\n      return res.status(403).json({ error: 'Session has expired' });\r\n    }\r\n\r\n    // Mark as verified\r\n    await promisePool.query(\r\n      'UPDATE ocr_sessions SET verified = TRUE, verified_at = CURRENT_TIMESTAMP WHERE session_id = ?',\r\n      [sessionId]\r\n    );\r\n\r\n    res.json({\r\n      success: true,\r\n      message: 'Session verified successfully',\r\n      sessionId,\r\n      recordType: session.record_type,\r\n      churchId: session.church_id,\r\n      expiresAt: session.expires_at\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error verifying session:', error);\r\n    res.status(500).json({ error: 'Failed to verify session' });\r\n  }\r\n});\r\n\r\n// Get session status\r\nrouter.get('/session/:sessionId/status', async (req, res) => {\r\n  try {\r\n    const { sessionId } = req.params;\r\n\r\n    const [sessions] = await promisePool.query(\r\n      'SELECT session_id, verified, used, expires_at, record_type, church_id FROM ocr_sessions WHERE session_id = ?',\r\n      [sessionId]\r\n    );\r\n\r\n    if (sessions.length === 0) {\r\n      return res.status(404).json({ error: 'Session not found' });\r\n    }\r\n\r\n    const session = sessions[0];\r\n    const now = new Date();\r\n    const expiresAt = new Date(session.expires_at);\r\n    const isExpired = now > expiresAt;\r\n\r\n    res.json({\r\n      sessionId: session.session_id,\r\n      verified: session.verified,\r\n      used: session.used,\r\n      expired: isExpired,\r\n      expiresAt: session.expires_at,\r\n      recordType: session.record_type,\r\n      churchId: session.church_id,\r\n      status: isExpired ? 'expired' :\r\n        session.used ? 'completed' :\r\n          session.verified ? 'ready' : 'pending'\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error getting session status:', error);\r\n    res.status(500).json({ error: 'Failed to get session status' });\r\n  }\r\n});\r\n\r\n// List user's sessions (for admin/debug)\r\nrouter.get('/sessions', validateUserAuth, async (req, res) => {\r\n  try {\r\n    const { limit = 20, offset = 0 } = req.query;\r\n    const userId = req.session.user.id;\r\n\r\n    const [sessions] = await promisePool.query(`\r\n      SELECT \r\n        session_id, \r\n        record_type, \r\n        church_id,\r\n        verified, \r\n        used, \r\n        created_at, \r\n        expires_at,\r\n        verified_at,\r\n        used_at\r\n      FROM ocr_sessions \r\n      WHERE created_by = ? \r\n      ORDER BY created_at DESC \r\n      LIMIT ? OFFSET ?\r\n    `, [userId, parseInt(limit), parseInt(offset)]);\r\n\r\n    // Add status to each session\r\n    const now = new Date();\r\n    const sessionsWithStatus = sessions.map(session => ({\r\n      ...session,\r\n      expired: now > new Date(session.expires_at),\r\n      status: now > new Date(session.expires_at) ? 'expired' :\r\n        session.used ? 'completed' :\r\n          session.verified ? 'ready' : 'pending'\r\n    }));\r\n\r\n    res.json({\r\n      sessions: sessionsWithStatus,\r\n      pagination: {\r\n        limit: parseInt(limit),\r\n        offset: parseInt(offset),\r\n        total: sessions.length\r\n      }\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error listing sessions:', error);\r\n    res.status(500).json({ error: 'Failed to list sessions' });\r\n  }\r\n});\r\n\r\n// Clean up expired sessions (cron job endpoint)\r\nrouter.delete('/sessions/cleanup', async (req, res) => {\r\n  try {\r\n    // Only allow admin users or system calls\r\n    if (req.session?.user?.role !== 'admin' && req.headers.authorization !== `Bearer ${process.env.[REDACTED]}`) {\r\n      return res.status(403).json({ error: 'Admin access required' });\r\n    }\r\n\r\n    const [result] = await promisePool.query(\r\n      'DELETE FROM ocr_sessions WHERE expires_at < CURRENT_TIMESTAMP'\r\n    );\r\n\r\n    res.json({\r\n      message: 'Expired sessions cleaned up',\r\n      deletedCount: result.affectedRows\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error cleaning up sessions:', error);\r\n    res.status(500).json({ error: 'Failed to clean up sessions' });\r\n  }\r\n});\r\n\r\n// Secure upload route for verified sessions\r\nrouter.post('/secure/upload', upload.single('file'), async (req, res) => {\r\n  try {\r\n    console.log('=== OCR Secure Upload Debug ===');\r\n    console.log('Request body:', req.body);\r\n    console.log('File info:', req.file ? {\r\n      filename: req.file.filename,\r\n      originalname: req.file.originalname,\r\n      size: req.file.size,\r\n      mimetype: req.file.mimetype\r\n    } : 'No file');\r\n    console.log('Session info:', req.session?.user ? {\r\n      userId: req.session.user.id,\r\n      username: req.session.user.username\r\n    } : 'No session');\r\n\r\n    const { sessionId } = req.body;\r\n\r\n    if (!sessionId) {\r\n      console.log('ERROR: No sessionId provided');\r\n      return res.status(400).json({\r\n        success: false,\r\n        message: 'Session ID is required'\r\n      });\r\n    }\r\n\r\n    if (!req.file) {\r\n      console.log('ERROR: No file uploaded');\r\n      return res.status(400).json({\r\n        success: false,\r\n        message: 'No file uploaded'\r\n      });\r\n    }\r\n\r\n    // For now, let's check both possible table structures\r\n    // First try the session-based verification table\r\n    let sessions = [];\r\n    try {\r\n      [sessions] = await promisePool.query(\r\n        'SELECT * FROM ocr_sessions WHERE session_id = ? AND verified = TRUE AND expires_at > CURRENT_TIMESTAMP AND used = FALSE',\r\n        [sessionId]\r\n      );\r\n      console.log('Session verification query result:', sessions.length > 0 ? 'Found verified session' : 'No verified session found');\r\n    } catch (error) {\r\n      console.log('Session verification table not found, checking main ocr_sessions table:', error.message);\r\n      // If that fails, check if we can create a new session entry\r\n    }\r\n\r\n    if (sessions.length === 0) {\r\n      // Try to create a new OCR session entry in the main table\r\n      try {\r\n        const userId = req.session?.user?.id || 1; // Default to user 1 if no session\r\n        const jobId = uuidv4();\r\n\r\n        console.log('Creating new OCR session entry with jobId:', jobId, 'userId:', userId);\r\n\r\n        await promisePool.query(`\r\n          INSERT INTO ocr_sessions (\r\n            session_id,\r\n            user_id,\r\n            original_filename,\r\n            file_path,\r\n            file_size,\r\n            mime_type,\r\n            status\r\n          ) VALUES (?, ?, ?, ?, ?, ?, 'processing')\r\n        `, [\r\n          jobId, // Using jobId as session_id\r\n          userId,\r\n          req.file.originalname,\r\n          req.file.path,\r\n          req.file.size,\r\n          req.file.mimetype\r\n        ]);\r\n\r\n        console.log(`OCR Processing started for job ${jobId}, file: ${req.file.originalname}`);\r\n\r\n        return res.json({\r\n          success: true,\r\n          jobId: jobId,\r\n          message: 'File uploaded successfully and processing started',\r\n          filename: req.file.originalname,\r\n          fileSize: req.file.size,\r\n          sessionId: jobId\r\n        });\r\n\r\n      } catch (dbError) {\r\n        console.error('Database error:', dbError);\r\n        // Clean up uploaded file\r\n        if (fs.existsSync(req.file.path)) {\r\n          fs.unlinkSync(req.file.path);\r\n        }\r\n        return res.status(500).json({\r\n          success: false,\r\n          message: 'Database error during upload processing'\r\n        });\r\n      }\r\n    }\r\n\r\n    // If we found a valid session, process normally\r\n    const jobId = uuidv4();\r\n    console.log(`OCR Processing started for job ${jobId}, file: ${req.file.originalname}`);\r\n\r\n    res.json({\r\n      success: true,\r\n      jobId: jobId,\r\n      message: 'File uploaded successfully and processing started',\r\n      filename: req.file.originalname,\r\n      fileSize: req.file.size,\r\n      sessionId: sessionId\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error in secure upload:', error);\r\n\r\n    // Clean up uploaded file on error\r\n    if (req.file && fs.existsSync(req.file.path)) {\r\n      fs.unlinkSync(req.file.path);\r\n    }\r\n\r\n    res.status(500).json({\r\n      success: false,\r\n      message: 'Failed to process upload'\r\n    });\r\n  }\r\n});\r\n\r\n// Get OCR job results by jobId\r\nrouter.get('/secure/results/:jobId', async (req, res) => {\r\n  try {\r\n    console.log('=== OCR Results Check ===');\r\n    console.log('JobId:', req.params.jobId);\r\n\r\n    const { jobId } = req.params;\r\n\r\n    if (!jobId) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        message: 'Job ID is required'\r\n      });\r\n    }\r\n\r\n    // Check if the job exists and get its status\r\n    const [jobs] = await promisePool.query(\r\n      'SELECT * FROM ocr_sessions WHERE session_id = ?',\r\n      [jobId]\r\n    );\r\n\r\n    console.log('Found jobs:', jobs.length);\r\n\r\n    if (jobs.length === 0) {\r\n      return res.status(404).json({\r\n        success: false,\r\n        message: 'Job not found'\r\n      });\r\n    }\r\n\r\n    const job = jobs[0];\r\n    console.log('Job status:', job.status);\r\n\r\n    // For now, simulate completion since we don't have real OCR processing\r\n    if (job.status === 'processing') {\r\n      // Simulate OCR completion after a short delay\r\n      const timeSinceCreation = Date.now() - new Date(job.created_at).getTime();\r\n\r\n      if (timeSinceCreation > 5000) { // 5 seconds simulation\r\n        // Update status to completed\r\n        await promisePool.query(\r\n          'UPDATE ocr_sessions SET status = ?, ocr_result = ?, completed_at = CURRENT_TIMESTAMP WHERE session_id = ?',\r\n          ['completed', `OCR processing completed for: ${job.original_filename}\\nThis is simulated OCR text content.`, jobId]\r\n        );\r\n\r\n        return res.json({\r\n          success: true,\r\n          completed: true,\r\n          result: {\r\n            id: jobId,\r\n            text: `OCR processing completed for: ${job.original_filename}\\nThis is simulated OCR text content.`,\r\n            confidence: 0.95,\r\n            language: 'en',\r\n            pages: 1,\r\n            downloadUrl: `/api/ocr/download/${jobId}`,\r\n            xlsxUrl: `/api/ocr/download/${jobId}/xlsx`,\r\n            pdfUrl: `/api/ocr/download/${jobId}/pdf`\r\n          }\r\n        });\r\n      } else {\r\n        // Still processing\r\n        return res.json({\r\n          success: true,\r\n          completed: false,\r\n          status: 'processing',\r\n          progress: Math.min(90, Math.floor(timeSinceCreation / 100))\r\n        });\r\n      }\r\n    } else if (job.status === 'completed') {\r\n      return res.json({\r\n        success: true,\r\n        completed: true,\r\n        result: {\r\n          id: jobId,\r\n          text: job.ocr_result || 'OCR processing completed',\r\n          confidence: job.confidence_score || 0.95,\r\n          language: 'en',\r\n          pages: 1,\r\n          downloadUrl: `/api/ocr/download/${jobId}`,\r\n          xlsxUrl: `/api/ocr/download/${jobId}/xlsx`,\r\n          pdfUrl: `/api/ocr/download/${jobId}/pdf`\r\n        }\r\n      });\r\n    } else if (job.status === 'error') {\r\n      return res.json({\r\n        success: false,\r\n        error: job.error_message || 'OCR processing failed'\r\n      });\r\n    }\r\n\r\n    return res.json({\r\n      success: true,\r\n      completed: false,\r\n      status: job.status\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error checking OCR results:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      message: 'Failed to check OCR results'\r\n    });\r\n  }\r\n});\r\n\r\nmodule.exports = router;\r\n"
    },
    "complexity": {
      "totalLines": 532,
      "codeLines": 432,
      "commentLines": 32,
      "commentRatio": 0.06896551724137931,
      "averageLineLength": 32.70905172413793
    },
    "lastAnalyzed": "2025-07-28T07:20:00.527Z"
  },
  "contentHash": "7c4a0a00a2b15a87017a7f1b95134b32870035a0751972f87cc0a14bdedb9062",
  "discoveredAt": "2025-07-28T07:20:00.527Z"
}