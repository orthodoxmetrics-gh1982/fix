{
  "id": "8d47d59d9b1d",
  "originalPath": "/var/www/orthodox-church-mgmt/orthodoxmetrics/prod/server/routes/provision.js",
  "relativePath": "server/routes/provision.js",
  "name": "provision.js",
  "extension": ".js",
  "size": 26745,
  "modified": "2025-07-04T23:08:08.000Z",
  "created": "2025-07-09T00:48:38.482Z",
  "classification": {
    "type": "Server Scripts",
    "category": "Backend > Server",
    "confidence": 7
  },
  "metadata": {
    "fileStats": {
      "lines": 877,
      "characters": 26741,
      "words": 2564
    },
    "classification": {
      "type": "Server Scripts",
      "category": "Backend > Server",
      "confidence": 7
    },
    "dependencies": [
      {
        "type": "npm_package",
        "name": "express",
        "line": 4
      },
      {
        "type": "npm_package",
        "name": "bcrypt",
        "line": 5
      },
      {
        "type": "npm_package",
        "name": "crypto",
        "line": 6
      },
      {
        "type": "npm_package",
        "name": "path",
        "line": 7
      },
      {
        "type": "npm_package",
        "name": "fs",
        "line": 8
      }
    ],
    "security": {
      "findings": [
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 765,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 806,
          "redacted": true
        }
      ],
      "hasSecurityIssues": true,
      "redactedContent": "// Church Provisioning API\r\n// Handles the automated church provisioning pipeline\r\n\r\nconst express = require('express');\r\nconst bcrypt = require('bcrypt');\r\nconst crypto = require('crypto');\r\nconst path = require('path');\r\nconst fs = require('fs').promises;\r\nconst router = express.Router();\r\nconst db = require('../../config/db');\r\nconst { requireAuth, requireRole } = require('../middleware/auth');\r\nconst { createReactSite } = require('../utils/createReactSite');\r\nconst { sendProvisionEmail } = require('../utils/sendProvisionEmail');\r\nconst { testDeployedSite } = require('../utils/testDeployedSite');\r\nconst { generateCredentials } = require('../utils/generateCredentials');\r\nconst logger = require('../utils/logger');\r\n\r\n// Get all provision queue entries (admin only)\r\nrouter.get('/queue', requireAuth, requireRole(['admin', 'supervisor']), async (req, res) => {\r\n  try {\r\n    const {\r\n      status = 'all',\r\n      stage = 'all',\r\n      limit = 50,\r\n      offset = 0,\r\n      language = 'all'\r\n    } = req.query;\r\n\r\n    let query = `\r\n      SELECT \r\n        cpq.*,\r\n        c.name as church_name,\r\n        c.location as church_location,\r\n        c.contact_email,\r\n        c.language_preference,\r\n        u.username as approved_by_username\r\n      FROM church_provision_queue cpq\r\n      LEFT JOIN churches c ON cpq.church_id = c.id\r\n      LEFT JOIN users u ON cpq.approved_by = u.id\r\n      WHERE 1=1\r\n    `;\r\n    \r\n    const params = [];\r\n\r\n    if (status !== 'all') {\r\n      query += ' AND cpq.status = ?';\r\n      params.push(status);\r\n    }\r\n\r\n    if (stage !== 'all') {\r\n      query += ' AND cpq.stage = ?';\r\n      params.push(stage);\r\n    }\r\n\r\n    if (language !== 'all') {\r\n      query += ' AND cpq.language_preference = ?';\r\n      params.push(language);\r\n    }\r\n\r\n    query += ' ORDER BY cpq.created_at DESC LIMIT ? OFFSET ?';\r\n    params.push(parseInt(limit), parseInt(offset));\r\n\r\n    const [rows] = await db.execute(query, params);\r\n\r\n    // Get total count for pagination\r\n    let countQuery = 'SELECT COUNT(*) as total FROM church_provision_queue cpq WHERE 1=1';\r\n    const countParams = [];\r\n\r\n    if (status !== 'all') {\r\n      countQuery += ' AND status = ?';\r\n      countParams.push(status);\r\n    }\r\n\r\n    if (stage !== 'all') {\r\n      countQuery += ' AND stage = ?';\r\n      countParams.push(stage);\r\n    }\r\n\r\n    if (language !== 'all') {\r\n      countQuery += ' AND language_preference = ?';\r\n      countParams.push(language);\r\n    }\r\n\r\n    const [countRows] = await db.execute(countQuery, countParams);\r\n    const total = countRows[0].total;\r\n\r\n    res.json({\r\n      success: true,\r\n      data: rows,\r\n      pagination: {\r\n        total,\r\n        limit: parseInt(limit),\r\n        offset: parseInt(offset),\r\n        hasMore: total > parseInt(offset) + parseInt(limit)\r\n      }\r\n    });\r\n\r\n  } catch (error) {\r\n    logger.error('Failed to fetch provision queue:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      message: 'Failed to fetch provision queue',\r\n      error: error.message\r\n    });\r\n  }\r\n});\r\n\r\n// Add church to provision queue\r\nrouter.post('/add', requireAuth, async (req, res) => {\r\n  const connection = await db.getConnection();\r\n  \r\n  try {\r\n    await connection.beginTransaction();\r\n\r\n    const {\r\n      churchId,\r\n      languagePreference = 'en',\r\n      domainName,\r\n      adminEmail\r\n    } = req.body;\r\n\r\n    // Validate church exists and user has permission\r\n    const [churchRows] = await connection.execute(\r\n      'SELECT * FROM churches WHERE id = ?',\r\n      [churchId]\r\n    );\r\n\r\n    if (churchRows.length === 0) {\r\n      await connection.rollback();\r\n      return res.status(404).json({\r\n        success: false,\r\n        message: 'Church not found'\r\n      });\r\n    }\r\n\r\n    const church = churchRows[0];\r\n\r\n    // Check if church is already in queue\r\n    const [existingRows] = await connection.execute(\r\n      'SELECT * FROM church_provision_queue WHERE church_id = ? AND status IN (?, ?, ?)',\r\n      [churchId, 'pending', 'approved', 'provisioning']\r\n    );\r\n\r\n    if (existingRows.length > 0) {\r\n      await connection.rollback();\r\n      return res.status(400).json({\r\n        success: false,\r\n        message: 'Church is already in provisioning queue'\r\n      });\r\n    }\r\n\r\n    // Generate unique site slug\r\n    const baseSlug = church.name.toLowerCase()\r\n      .replace(/[^a-z0-9\\s-]/g, '')\r\n      .replace(/\\s+/g, '-')\r\n      .substring(0, 50);\r\n\r\n    let siteSlug = baseSlug;\r\n    let counter = 1;\r\n\r\n    // Ensure slug is unique\r\n    while (true) {\r\n      const [slugRows] = await connection.execute(\r\n        'SELECT id FROM church_provision_queue WHERE site_slug = ?',\r\n        [siteSlug]\r\n      );\r\n\r\n      if (slugRows.length === 0) break;\r\n      \r\n      siteSlug = `${baseSlug}-${counter}`;\r\n      counter++;\r\n    }\r\n\r\n    // Insert into provision queue\r\n    const [insertResult] = await connection.execute(`\r\n      INSERT INTO church_provision_queue (\r\n        church_id, language_preference, site_slug, \r\n        domain_name, admin_email, provision_data,\r\n        status, stage\r\n      ) VALUES (?, ?, ?, ?, ?, ?, 'pending', 'pending_review')\r\n    `, [\r\n      churchId,\r\n      languagePreference,\r\n      siteSlug,\r\n      domainName,\r\n      adminEmail || church.contact_email,\r\n      JSON.stringify({\r\n        requestedBy: req.user.id,\r\n        requestedAt: new Date().toISOString(),\r\n        churchData: church\r\n      })\r\n    ]);\r\n\r\n    const queueId = insertResult.insertId;\r\n\r\n    // Update church record\r\n    await connection.execute(\r\n      'UPDATE churches SET provision_status = ?, provision_queue_id = ? WHERE id = ?',\r\n      ['pending', queueId, churchId]\r\n    );\r\n\r\n    // Create initial stage log\r\n    await connection.execute(`\r\n      INSERT INTO provision_stage_logs (\r\n        queue_id, stage, status, started_at, log_data\r\n      ) VALUES (?, 'submission', 'completed', NOW(), ?)\r\n    `, [\r\n      queueId,\r\n      JSON.stringify({\r\n        submittedBy: req.user.id,\r\n        submissionData: req.body\r\n      })\r\n    ]);\r\n\r\n    // Create pending review stage\r\n    await connection.execute(`\r\n      INSERT INTO provision_stage_logs (\r\n        queue_id, stage, status, started_at\r\n      ) VALUES (?, 'pending_review', 'pending', NOW())\r\n    `, [queueId]);\r\n\r\n    await connection.commit();\r\n\r\n    // Send notification to church about pending status\r\n    try {\r\n      await sendProvisionEmail(queueId, 'approval_pending');\r\n    } catch (emailError) {\r\n      logger.error('Failed to send pending approval email:', emailError);\r\n      // Don't fail the request if email fails\r\n    }\r\n\r\n    res.json({\r\n      success: true,\r\n      message: 'Church added to provisioning queue',\r\n      data: {\r\n        queueId,\r\n        siteSlug,\r\n        status: 'pending',\r\n        stage: 'pending_review'\r\n      }\r\n    });\r\n\r\n  } catch (error) {\r\n    await connection.rollback();\r\n    logger.error('Failed to add church to provision queue:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      message: 'Failed to add church to provision queue',\r\n      error: error.message\r\n    });\r\n  } finally {\r\n    connection.release();\r\n  }\r\n});\r\n\r\n// Approve church provisioning (admin only)\r\nrouter.post('/approve/:queueId', requireAuth, requireRole(['admin', 'supervisor']), async (req, res) => {\r\n  const connection = await db.getConnection();\r\n  \r\n  try {\r\n    await connection.beginTransaction();\r\n\r\n    const { queueId } = req.params;\r\n    const { approvalNotes } = req.body;\r\n\r\n    // Get queue entry\r\n    const [queueRows] = await connection.execute(\r\n      'SELECT * FROM church_provision_queue WHERE id = ? AND status = ?',\r\n      [queueId, 'pending']\r\n    );\r\n\r\n    if (queueRows.length === 0) {\r\n      await connection.rollback();\r\n      return res.status(404).json({\r\n        success: false,\r\n        message: 'Provision queue entry not found or not pending'\r\n      });\r\n    }\r\n\r\n    const queueEntry = queueRows[0];\r\n\r\n    // Update queue entry to approved\r\n    await connection.execute(`\r\n      UPDATE church_provision_queue \r\n      SET status = 'approved', stage = 'approval', \r\n          approved_by = ?, approved_at = NOW(),\r\n          provision_data = JSON_SET(provision_data, '$.approvalNotes', ?, '$.approvedBy', ?)\r\n      WHERE id = ?\r\n    `, [req.user.id, approvalNotes || '', req.user.id, queueId]);\r\n\r\n    // Complete pending review stage\r\n    await connection.execute(`\r\n      UPDATE provision_stage_logs \r\n      SET status = 'completed', completed_at = NOW(),\r\n          duration_seconds = TIMESTAMPDIFF(SECOND, started_at, NOW()),\r\n          log_data = JSON_SET(COALESCE(log_data, '{}'), '$.approvedBy', ?, '$.approvalNotes', ?)\r\n      WHERE queue_id = ? AND stage = 'pending_review' AND status = 'pending'\r\n    `, [req.user.id, approvalNotes || '', queueId]);\r\n\r\n    // Create approval stage\r\n    await connection.execute(`\r\n      INSERT INTO provision_stage_logs (\r\n        queue_id, stage, status, started_at, completed_at,\r\n        duration_seconds, log_data\r\n      ) VALUES (?, 'approval', 'completed', NOW(), NOW(), 0, ?)\r\n    `, [\r\n      queueId,\r\n      JSON.stringify({\r\n        approvedBy: req.user.id,\r\n        approvalNotes: approvalNotes || '',\r\n        approvedAt: new Date().toISOString()\r\n      })\r\n    ]);\r\n\r\n    await connection.commit();\r\n\r\n    // Start automatic provisioning process\r\n    setImmediate(() => {\r\n      startProvisioningProcess(queueId);\r\n    });\r\n\r\n    res.json({\r\n      success: true,\r\n      message: 'Church provisioning approved and started',\r\n      data: {\r\n        queueId,\r\n        status: 'approved',\r\n        stage: 'approval'\r\n      }\r\n    });\r\n\r\n  } catch (error) {\r\n    await connection.rollback();\r\n    logger.error('Failed to approve church provisioning:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      message: 'Failed to approve church provisioning',\r\n      error: error.message\r\n    });\r\n  } finally {\r\n    connection.release();\r\n  }\r\n});\r\n\r\n// Start automated provisioning process\r\nasync function startProvisioningProcess(queueId) {\r\n  const connection = await db.getConnection();\r\n  \r\n  try {\r\n    // Update status to provisioning\r\n    await connection.execute(\r\n      'UPDATE church_provision_queue SET status = ?, stage = ? WHERE id = ?',\r\n      ['provisioning', 'provision_site', queueId]\r\n    );\r\n\r\n    // Create provision_site stage\r\n    await connection.execute(`\r\n      INSERT INTO provision_stage_logs (\r\n        queue_id, stage, status, started_at\r\n      ) VALUES (?, 'provision_site', 'in_progress', NOW())\r\n    `, [queueId]);\r\n\r\n    // Get queue entry with church data\r\n    const [queueRows] = await connection.execute(`\r\n      SELECT cpq.*, c.name as church_name, c.location, c.contact_email\r\n      FROM church_provision_queue cpq\r\n      LEFT JOIN churches c ON cpq.church_id = c.id\r\n      WHERE cpq.id = ?\r\n    `, [queueId]);\r\n\r\n    const queueEntry = queueRows[0];\r\n\r\n    // Step 1: Create React site\r\n    logger.info(`Starting site provisioning for queue ${queueId}`);\r\n    const siteResult = await createReactSite({\r\n      queueId,\r\n      siteSlug: queueEntry.site_slug,\r\n      language: queueEntry.language_preference,\r\n      churchData: {\r\n        name: queueEntry.church_name,\r\n        location: queueEntry.location,\r\n        email: queueEntry.admin_email\r\n      }\r\n    });\r\n\r\n    if (!siteResult.success) {\r\n      throw new Error(`Site creation failed: ${siteResult.error}`);\r\n    }\r\n\r\n    // Complete provision_site stage\r\n    await updateStageStatus(connection, queueId, 'provision_site', 'completed', {\r\n      siteUrl: siteResult.siteUrl,\r\n      sitePath: siteResult.sitePath\r\n    });\r\n\r\n    // Step 2: Test deployed site\r\n    await updateStageStatus(connection, queueId, 'test_site', 'in_progress');\r\n    \r\n    const testResult = await testDeployedSite({\r\n      siteUrl: siteResult.siteUrl,\r\n      language: queueEntry.language_preference\r\n    });\r\n\r\n    if (!testResult.success) {\r\n      throw new Error(`Site testing failed: ${testResult.error}`);\r\n    }\r\n\r\n    await updateStageStatus(connection, queueId, 'test_site', 'completed', testResult);\r\n\r\n    // Step 3: Create credentials\r\n    await updateStageStatus(connection, queueId, 'create_credentials', 'in_progress');\r\n    \r\n    const credentialsResult = await generateCredentials({\r\n      queueId,\r\n      churchId: queueEntry.church_id,\r\n      adminEmail: queueEntry.admin_email,\r\n      siteSlug: queueEntry.site_slug\r\n    });\r\n\r\n    if (!credentialsResult.success) {\r\n      throw new Error(`Credential creation failed: ${credentialsResult.error}`);\r\n    }\r\n\r\n    // Update queue with credentials\r\n    await connection.execute(`\r\n      UPDATE church_provision_queue \r\n      SET admin_password_hash = ?, test_user_email = ?, test_user_password_hash = ?\r\n      WHERE id = ?\r\n    `, [\r\n      credentialsResult.adminPasswordHash,\r\n      credentialsResult.testUserEmail,\r\n      credentialsResult.testUserPasswordHash,\r\n      queueId\r\n    ]);\r\n\r\n    await updateStageStatus(connection, queueId, 'create_credentials', 'completed', {\r\n      adminCreated: true,\r\n      testUserCreated: true\r\n    });\r\n\r\n    // Step 4: Send notification email\r\n    await updateStageStatus(connection, queueId, 'notify_church', 'in_progress');\r\n    \r\n    const emailResult = await sendProvisionEmail(queueId, 'provision_completed', {\r\n      siteUrl: siteResult.siteUrl,\r\n      adminPassword: credentialsResult.adminPassword,\r\n      testPassword: credentialsResult.testPassword\r\n    });\r\n\r\n    if (!emailResult.success) {\r\n      logger.error(`Email notification failed for queue ${queueId}:`, emailResult.error);\r\n      // Don't fail the whole process if email fails\r\n    }\r\n\r\n    await updateStageStatus(connection, queueId, 'notify_church', 'completed', emailResult);\r\n\r\n    // Final step: Mark as completed\r\n    await connection.execute(`\r\n      UPDATE church_provision_queue \r\n      SET status = 'provisioned', stage = 'completed', provisioned_at = NOW()\r\n      WHERE id = ?\r\n    `, [queueId]);\r\n\r\n    // Update church record\r\n    await connection.execute(`\r\n      UPDATE churches \r\n      SET provision_status = 'provisioned', site_slug = ?, \r\n          site_url = ?, provisioned_at = NOW()\r\n      WHERE id = ?\r\n    `, [queueEntry.site_slug, siteResult.siteUrl, queueEntry.church_id]);\r\n\r\n    await updateStageStatus(connection, queueId, 'completed', 'completed');\r\n\r\n    logger.info(`Church provisioning completed successfully for queue ${queueId}`);\r\n\r\n  } catch (error) {\r\n    logger.error(`Church provisioning failed for queue ${queueId}:`, error);\r\n    \r\n    // Mark as failed\r\n    await connection.execute(`\r\n      UPDATE church_provision_queue \r\n      SET status = 'failed', error_log = CONCAT(COALESCE(error_log, ''), ?, '\\n')\r\n      WHERE id = ?\r\n    `, [`[${new Date().toISOString()}] ${error.message}`, queueId]);\r\n\r\n    // Update current stage as failed\r\n    await connection.execute(`\r\n      UPDATE provision_stage_logs \r\n      SET status = 'failed', completed_at = NOW(),\r\n          duration_seconds = TIMESTAMPDIFF(SECOND, started_at, NOW()),\r\n          error_message = ?\r\n      WHERE queue_id = ? AND status = 'in_progress'\r\n    `, [error.message, queueId]);\r\n\r\n  } finally {\r\n    connection.release();\r\n  }\r\n}\r\n\r\n// Helper function to update stage status\r\nasync function updateStageStatus(connection, queueId, stage, status, logData = null) {\r\n  if (status === 'in_progress') {\r\n    await connection.execute(`\r\n      INSERT INTO provision_stage_logs (\r\n        queue_id, stage, status, started_at\r\n      ) VALUES (?, ?, ?, NOW())\r\n    `, [queueId, stage, status]);\r\n    \r\n    await connection.execute(\r\n      'UPDATE church_provision_queue SET stage = ? WHERE id = ?',\r\n      [stage, queueId]\r\n    );\r\n  } else {\r\n    await connection.execute(`\r\n      UPDATE provision_stage_logs \r\n      SET status = ?, completed_at = NOW(),\r\n          duration_seconds = TIMESTAMPDIFF(SECOND, started_at, NOW()),\r\n          log_data = ?\r\n      WHERE queue_id = ? AND stage = ? AND status IN ('pending', 'in_progress')\r\n    `, [status, JSON.stringify(logData || {}), queueId, stage]);\r\n  }\r\n}\r\n\r\n// Get provision status\r\nrouter.get('/status/:queueId', requireAuth, async (req, res) => {\r\n  try {\r\n    const { queueId } = req.params;\r\n\r\n    const [queueRows] = await db.execute(`\r\n      SELECT cpq.*, c.name as church_name\r\n      FROM church_provision_queue cpq\r\n      LEFT JOIN churches c ON cpq.church_id = c.id\r\n      WHERE cpq.id = ?\r\n    `, [queueId]);\r\n\r\n    if (queueRows.length === 0) {\r\n      return res.status(404).json({\r\n        success: false,\r\n        message: 'Provision queue entry not found'\r\n      });\r\n    }\r\n\r\n    const [stageRows] = await db.execute(`\r\n      SELECT * FROM provision_stage_logs \r\n      WHERE queue_id = ? \r\n      ORDER BY created_at ASC\r\n    `, [queueId]);\r\n\r\n    res.json({\r\n      success: true,\r\n      data: {\r\n        queue: queueRows[0],\r\n        stages: stageRows\r\n      }\r\n    });\r\n\r\n  } catch (error) {\r\n    logger.error('Failed to get provision status:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      message: 'Failed to get provision status',\r\n      error: error.message\r\n    });\r\n  }\r\n});\r\n\r\n// Cancel provisioning (admin only)\r\nrouter.post('/cancel/:queueId', requireAuth, requireRole(['admin', 'supervisor']), async (req, res) => {\r\n  const connection = await db.getConnection();\r\n  \r\n  try {\r\n    await connection.beginTransaction();\r\n\r\n    const { queueId } = req.params;\r\n    const { reason } = req.body;\r\n\r\n    // Update queue entry\r\n    await connection.execute(`\r\n      UPDATE church_provision_queue \r\n      SET status = 'cancelled',\r\n          error_log = CONCAT(COALESCE(error_log, ''), ?)\r\n      WHERE id = ? AND status IN ('pending', 'approved', 'provisioning')\r\n    `, [`[${new Date().toISOString()}] Cancelled by ${req.user.username}: ${reason || 'No reason provided'}\\n`, queueId]);\r\n\r\n    // Update church record\r\n    await connection.execute(`\r\n      UPDATE churches \r\n      SET provision_status = 'manual', provision_queue_id = NULL\r\n      WHERE provision_queue_id = ?\r\n    `, [queueId]);\r\n\r\n    await connection.commit();\r\n\r\n    res.json({\r\n      success: true,\r\n      message: 'Provisioning cancelled successfully'\r\n    });\r\n\r\n  } catch (error) {\r\n    await connection.rollback();\r\n    logger.error('Failed to cancel provisioning:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      message: 'Failed to cancel provisioning',\r\n      error: error.message\r\n    });\r\n  } finally {\r\n    connection.release();\r\n  }\r\n});\r\n\r\n// ===== NEW SIMPLE CHURCH PROVISIONING ENDPOINTS =====\r\n\r\n// In-memory store for provisioning status (in production, use Redis or database)\r\nconst provisioningStatus = new Map();\r\n\r\n// POST /api/churches/provision - Simple church provisioning\r\nrouter.post('/churches/provision', async (req, res) => {\r\n  try {\r\n    const {\r\n      churchName,\r\n      adminEmail,\r\n      preferredLanguage,\r\n      adminFirstName,\r\n      adminLastName,\r\n      churchAddress,\r\n      phoneNumber\r\n    } = req.body;\r\n\r\n    // Validate required fields\r\n    if (!churchName || !adminEmail || !adminFirstName || !adminLastName || !churchAddress) {\r\n      return res.status(400).json({ \r\n        error: 'Missing required fields: churchName, adminEmail, adminFirstName, adminLastName, churchAddress' \r\n      });\r\n    }\r\n\r\n    // Validate email format\r\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\r\n    if (!emailRegex.test(adminEmail)) {\r\n      return res.status(400).json({ error: 'Invalid email format' });\r\n    }\r\n\r\n    // Check if admin email already exists\r\n    const [existingUser] = await db.promisePool.query(\r\n      'SELECT id FROM users WHERE email = ?',\r\n      [adminEmail]\r\n    );\r\n\r\n    if (existingUser.length > 0) {\r\n      return res.status(409).json({ error: 'A user with this email already exists' });\r\n    }\r\n\r\n    // Generate provisioning ID\r\n    const provisioningId = crypto.randomUUID();\r\n\r\n    // Store initial status\r\n    provisioningStatus.set(provisioningId, {\r\n      id: provisioningId,\r\n      status: 'processing',\r\n      message: 'Initializing church site provisioning...',\r\n      startTime: new Date(),\r\n      churchName,\r\n      adminEmail\r\n    });\r\n\r\n    // Start provisioning process (async)\r\n    provisionChurchSimple({\r\n      provisioningId,\r\n      churchName,\r\n      adminEmail,\r\n      preferredLanguage: preferredLanguage || 'en',\r\n      adminFirstName,\r\n      adminLastName,\r\n      churchAddress,\r\n      phoneNumber\r\n    });\r\n\r\n    res.json({\r\n      success: true,\r\n      provisioningId,\r\n      message: 'Church provisioning started'\r\n    });\r\n\r\n  } catch (error) {\r\n    logger.error('Simple provisioning error:', error);\r\n    res.status(500).json({ error: 'Failed to start provisioning process' });\r\n  }\r\n});\r\n\r\n// GET /api/churches/provision/status/:id\r\nrouter.get('/churches/provision/status/:id', (req, res) => {\r\n  const { id } = req.params;\r\n  const status = provisioningStatus.get(id);\r\n\r\n  if (!status) {\r\n    return res.status(404).json({ error: 'Provisioning status not found' });\r\n  }\r\n\r\n  res.json(status);\r\n});\r\n\r\n// Simple async provisioning function\r\nasync function provisionChurchSimple({\r\n  provisioningId,\r\n  churchName,\r\n  adminEmail,\r\n  preferredLanguage,\r\n  adminFirstName,\r\n  adminLastName,\r\n  churchAddress,\r\n  phoneNumber\r\n}) {\r\n  try {\r\n    // Update status: Creating database entries\r\n    updateProvisioningStatus(provisioningId, {\r\n      status: 'processing',\r\n      message: 'Creating database entries...'\r\n    });\r\n\r\n    // Create church record (check if churches table exists)\r\n    try {\r\n      const [churchResult] = await db.promisePool.query(`\r\n        INSERT INTO churches (name, address, language, phone, is_active, created_at) \r\n        VALUES (?, ?, ?, ?, true, NOW())\r\n      `, [churchName, churchAddress, preferredLanguage, phoneNumber || null]);\r\n\r\n      const churchId = churchResult.insertId;\r\n\r\n      // Generate temporary password\r\n      const temporaryPassword = generateSecurePassword();\r\n      const hashedPassword = await bcrypt.hash(temporaryPassword, 12);\r\n\r\n      // Update status: Creating admin user\r\n      updateProvisioningStatus(provisioningId, {\r\n        status: 'processing',\r\n        message: 'Creating administrator account...'\r\n      });\r\n\r\n      // Create admin user\r\n      const adminUsername = `${adminFirstName.toLowerCase()}.${adminLastName.toLowerCase()}`;\r\n      \r\n      await db.promisePool.query(`\r\n        INSERT INTO users (\r\n          email, username, password_hash, role, landing_page, \r\n          created_at, church_id, is_active\r\n        ) VALUES (?, ?, ?, 'admin', '/pages/admin/dashboard', NOW(), ?, true)\r\n      `, [adminEmail, adminUsername, hashedPassword, churchId]);\r\n\r\n      // Update status: Configuring permissions\r\n      updateProvisioningStatus(provisioningId, {\r\n        status: 'processing',\r\n        message: 'Configuring permissions and settings...'\r\n      });\r\n\r\n      // Add some initial configuration (simulate work)\r\n      await new Promise(resolve => setTimeout(resolve, 2000));\r\n\r\n      // Update status: Sending credentials\r\n      updateProvisioningStatus(provisioningId, {\r\n        status: 'processing',\r\n        message: 'Sending login credentials...'\r\n      });\r\n\r\n      // Send email with credentials\r\n      const loginUrl = `${process.env.[REDACTED] || 'http://localhost:5173'}/auth/sign-in`;\r\n      await sendProvisioningEmailSimple({\r\n        adminEmail,\r\n        adminFirstName,\r\n        adminLastName,\r\n        churchName,\r\n        adminUsername,\r\n        temporaryPassword,\r\n        loginUrl\r\n      });\r\n\r\n      // Final update: Completed\r\n      updateProvisioningStatus(provisioningId, {\r\n        status: 'completed',\r\n        message: 'Church site provisioning completed successfully!',\r\n        credentials: {\r\n          adminUsername,\r\n          temporaryPassword,\r\n          loginUrl\r\n        },\r\n        completedAt: new Date()\r\n      });\r\n\r\n      logger.info(`âœ… Church provisioning completed for: ${churchName}`);\r\n\r\n    } catch (dbError) {\r\n      // If churches table doesn't exist, create a simplified version\r\n      if (dbError.code === 'ER_NO_SUCH_TABLE') {\r\n        logger.warn('Churches table not found, using simplified provisioning');\r\n        \r\n        // Just create the user for now\r\n        const temporaryPassword = generateSecurePassword();\r\n        const hashedPassword = await bcrypt.hash(temporaryPassword, 12);\r\n        const adminUsername = `${adminFirstName.toLowerCase()}.${adminLastName.toLowerCase()}`;\r\n        \r\n        await db.promisePool.query(`\r\n          INSERT INTO users (\r\n            email, username, password_hash, role, landing_page, created_at, is_active\r\n          ) VALUES (?, ?, ?, 'admin', '/pages/admin/dashboard', NOW(), true)\r\n        `, [adminEmail, adminUsername, hashedPassword]);\r\n\r\n        const loginUrl = `${process.env.[REDACTED] || 'http://localhost:5173'}/auth/sign-in`;\r\n        \r\n        updateProvisioningStatus(provisioningId, {\r\n          status: 'completed',\r\n          message: 'Church admin account created successfully!',\r\n          credentials: {\r\n            adminUsername,\r\n            temporaryPassword,\r\n            loginUrl\r\n          },\r\n          completedAt: new Date()\r\n        });\r\n      } else {\r\n        throw dbError;\r\n      }\r\n    }\r\n\r\n  } catch (error) {\r\n    logger.error('Simple provisioning failed:', error);\r\n    updateProvisioningStatus(provisioningId, {\r\n      status: 'failed',\r\n      message: `Provisioning failed: ${error.message}`,\r\n      error: error.message,\r\n      failedAt: new Date()\r\n    });\r\n  }\r\n}\r\n\r\n// Helper function to update provisioning status\r\nfunction updateProvisioningStatus(provisioningId, updates) {\r\n  const currentStatus = provisioningStatus.get(provisioningId);\r\n  if (currentStatus) {\r\n    provisioningStatus.set(provisioningId, {\r\n      ...currentStatus,\r\n      ...updates,\r\n      lastUpdated: new Date()\r\n    });\r\n  }\r\n}\r\n\r\n// Generate secure temporary password\r\nfunction generateSecurePassword(length = 12) {\r\n  const charset = 'ABCDEFGHJKMNPQRSTUVWXYZabcdefghijkmnpqrstuvwxyz23456789!@#$%&*';\r\n  let password = '';\r\n  for (let i = 0; i < length; i++) {\r\n    password += charset.charAt(Math.floor(Math.random() * charset.length));\r\n  }\r\n  return password;\r\n}\r\n\r\n// Send simple provisioning email\r\nasync function sendProvisioningEmailSimple({\r\n  adminEmail,\r\n  adminFirstName,\r\n  adminLastName,\r\n  churchName,\r\n  adminUsername,\r\n  temporaryPassword,\r\n  loginUrl\r\n}) {\r\n  logger.info(`ðŸ“§ Would send provisioning email to: ${adminEmail}`);\r\n  logger.info(`Church: ${churchName}`);\r\n  logger.info(`Username: ${adminUsername}`);\r\n  logger.info(`Password: ${temporaryPassword}`);\r\n  logger.info(`Login URL: ${loginUrl}`);\r\n  \r\n  // For now, just log the email content\r\n  // In production, implement actual email sending\r\n}\r\n\r\nmodule.exports = router;\r\n"
    },
    "complexity": {
      "totalLines": 877,
      "codeLines": 672,
      "commentLines": 69,
      "commentRatio": 0.0931174089068826,
      "averageLineLength": 34.62887989203779
    },
    "lastAnalyzed": "2025-07-28T07:20:00.549Z"
  },
  "contentHash": "c6ff69c7c9738eabae5b5b113ef82bd19abdeba44dfe1360ab5a7d105d00cc29",
  "discoveredAt": "2025-07-28T07:20:00.549Z"
}