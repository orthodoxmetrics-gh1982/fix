{
  "id": "e79cbaed6f19",
  "originalPath": "/var/www/orthodox-church-mgmt/orthodoxmetrics/prod/bigbook/metadata/00e218f8ec1f.json",
  "relativePath": "bigbook/metadata/00e218f8ec1f.json",
  "name": "00e218f8ec1f.json",
  "extension": ".json",
  "size": 53361,
  "modified": "2025-07-26T04:17:11.058Z",
  "created": "2025-07-26T04:17:11.058Z",
  "classification": {
    "type": "Database Scripts",
    "category": "Backend > Database",
    "confidence": 4
  },
  "metadata": {
    "fileStats": {
      "lines": 72,
      "characters": 53247,
      "words": 4153
    },
    "classification": {
      "type": "Database Scripts",
      "category": "Backend > Database",
      "confidence": 4
    },
    "dependencies": [
      {
        "type": "npm_package",
        "name": "express",
        "line": 59
      },
      {
        "type": "npm_package",
        "name": "bcrypt",
        "line": 59
      },
      {
        "type": "npm_package",
        "name": "bcrypt",
        "line": 59
      }
    ],
    "security": {
      "findings": [
        {
          "type": "sensitive_data",
          "pattern": "(?:password|pwd|pass)\\s*[:=]\\s*['\"]([^'\"]+)['\"]",
          "line": 59,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "(?:password|pwd|pass)\\s*[:=]\\s*['\"]([^'\"]+)['\"]",
          "line": 59,
          "redacted": true
        }
      ],
      "hasSecurityIssues": true,
      "redactedContent": "{\n  \"id\": \"00e218f8ec1f\",\n  \"originalPath\": \"/var/www/orthodox-church-mgmt/orthodoxmetrics/prod/server/routes/admin.js\",\n  \"relativePath\": \"server/routes/admin.js\",\n  \"name\": \"admin.js\",\n  \"extension\": \".js\",\n  \"size\": 50470,\n  \"modified\": \"2025-07-22T09:24:20.424Z\",\n  \"created\": \"2025-07-09T00:48:38.478Z\",\n  \"classification\": {\n    \"type\": \"Server Scripts\",\n    \"category\": \"Backend > Server\",\n    \"confidence\": 7\n  },\n  \"metadata\": {\n    \"fileStats\": {\n      \"lines\": 1188,\n      \"characters\": 50356,\n      \"words\": 4052\n    },\n    \"classification\": {\n      \"type\": \"Server Scripts\",\n      \"category\": \"Backend > Server\",\n      \"confidence\": 7\n    },\n    \"dependencies\": [\n      {\n        \"type\": \"npm_package\",\n        \"name\": \"express\",\n        \"line\": 2\n      },\n      {\n        \"type\": \"npm_package\",\n        \"name\": \"bcrypt\",\n        \"line\": 4\n      },\n      {\n        \"type\": \"npm_package\",\n        \"name\": \"bcrypt\",\n        \"line\": 701\n      }\n    ],\n    \"security\": {\n      \"findings\": [\n        {\n          \"type\": \"sensitive_data\",\n          \"pattern\": \"(?:password|pwd|pass)\\\\s*[:=]\\\\s*['\\\"]([^'\\\"]+)['\\\"]\",\n          \"line\": 935,\n          \"redacted\": true\n        },\n        {\n          \"type\": \"sensitive_data\",\n          \"pattern\": \"(?:password|pwd|pass)\\\\s*[:=]\\\\s*['\\\"]([^'\\\"]+)['\\\"]\",\n          \"line\": 1039,\n          \"redacted\": true\n        }\n      ],\n      \"hasSecurityIssues\": true,\n      \"redactedContent\": \"// server/routes/admin.js\\nconst express = require('express');\\nconst { promisePool } = require('../../config/db');\\nconst bcrypt = require('bcrypt');\\nconst { \\n    canManageUser, \\n    canPerformDestructiveOperation, \\n    canChangeRole,\\n    isRootSuperAdmin,\\n    logUnauthorizedAttempt,\\n    ROOT_SUPERADMIN_EMAIL\\n} = require('../middleware/userAuthorization');\\n\\nconst router = express.Router();\\n\\n// Middleware to check if user is admin or super_admin\\nconst requireAdmin = async (req, res, next) => {\\n    console.log('üîí requireAdmin middleware - checking session...');\\n    console.log('   Session ID:', req.sessionID);\\n    console.log('   Session exists:', !!req.session);\\n    console.log('   Session user exists:', !!req.session?.user);\\n    console.log('   Session user:', req.session?.user);\\n    console.log('   Request headers (cookie):', req.headers.cookie);\\n    console.log('   User Agent:', req.headers['user-agent']);\\n\\n    // üîß ENHANCED DEBUG: Check session store directly\\n    if (req.sessionID && req.sessionStore) {\\n        try {\\n            const sessionData = await new Promise((resolve, reject) => {\\n                req.sessionStore.get(req.sessionID, (err, session) => {\\n                    if (err) reject(err);\\n                    else resolve(session);\\n                });\\n            });\\n            console.log('   Session from store:', sessionData);\\n        } catch (storeErr) {\\n            console.log('   Session store error:', storeErr.message);\\n        }\\n    }\\n\\n    if (!req.session || !req.session.user) {\\n        console.log('‚ùå No authenticated user found');\\n        return res.status(401).json({\\n            success: false,\\n            message: 'Authentication required',\\n            debug: {\\n                sessionExists: !!req.session,\\n                sessionId: req.sessionID,\\n                hasCookie: !!req.headers.cookie,\\n                timestamp: new Date().toISOString()\\n            }\\n        });\\n    }\\n\\n    const userRole = req.session.user.role;\\n    console.log('   User role:', userRole);\\n\\n    if (userRole !== 'admin' && userRole !== 'super_admin') {\\n        console.log('‚ùå Insufficient privileges');\\n        return res.status(403).json({\\n            success: false,\\n            message: 'Administrative privileges required'\\n        });\\n    }\\n\\n    console.log('‚úÖ Admin access granted');\\n    next();\\n};\\n\\n// Middleware to check if user is super_admin only\\nconst requireSuperAdmin = async (req, res, next) => {\\n    if (!req.session.user) {\\n        console.log('‚ùå No authenticated user found in super admin middleware');\\n        return res.status(401).json({\\n            success: false,\\n            message: 'Authentication required'\\n        });\\n    }\\n\\n    const userRole = req.session.user.role;\\n    if (userRole !== 'super_admin') {\\n        return res.status(403).json({\\n            success: false,\\n            message: 'Super administrator privileges required'\\n        });\\n    }\\n\\n    next();\\n};\\n\\n// Middleware to check if user can create/edit users with specific roles\\nconst requireRolePermission = async (req, res, next) => {\\n    if (!req.session.user) {\\n        console.log('‚ùå No authenticated user found in role permission middleware');\\n        return res.status(401).json({\\n            success: false,\\n            message: 'Authentication required'\\n        });\\n    }\\n\\n    const userRole = req.session.user.role;\\n    const targetRole = req.body.role;\\n\\n    console.log('üîç Role permission check:');\\n    console.log('  User role:', userRole);\\n    console.log('  Target role:', targetRole);\\n\\n    // Super admin can create/edit any role except super_admin\\n    if (userRole === 'super_admin') {\\n        if (targetRole === 'super_admin') {\\n            console.log('‚ùå Super admin cannot create super_admin users');\\n            return res.status(403).json({\\n                success: false,\\n                message: 'Cannot create or modify super_admin users'\\n            });\\n        }\\n        console.log('‚úÖ Super admin can create', targetRole, 'users');\\n        return next();\\n    }\\n\\n    // Regular admin can only create/edit non-admin roles\\n    if (userRole === 'admin') {\\n        if (targetRole === 'admin' || targetRole === 'super_admin') {\\n            console.log('‚ùå Regular admin cannot create admin/super_admin users');\\n            return res.status(403).json({\\n                success: false,\\n                message: 'Cannot create or modify admin or super_admin users'\\n            });\\n        }\\n        console.log('‚úÖ Regular admin can create', targetRole, 'users');\\n        return next();\\n    }\\n\\n    console.log('‚ùå No permission for role:', userRole);\\n    return res.status(403).json({\\n        success: false,\\n        message: 'Insufficient privileges'\\n    });\\n};\\n\\n// Debug middleware for admin routes\\nrouter.use((req, res, next) => {\\n    console.log(`üîß Admin route: ${req.method} ${req.path} - Original URL: ${req.originalUrl}`);\\n    next();\\n});\\n\\n// GET /admin/users - Get all users\\n\\n// POST /admin/users - Create new user\\n\\n// PUT /admin/users/:id - Update user\\n\\n// DELETE /admin/users/:id - Delete user\\n\\n// PUT /admin/users/:id/toggle-status - Toggle user active status\\n\\n// GET /admin/churches - Get all churches (for admin panel)\\n\\n// GET /admin/churches/:id - Get individual church by ID (admin only)\\nrouter.get('/churches/:id', requireAdmin, async (req, res) => {\\n    try {\\n        const churchId = parseInt(req.params.id);\\n        console.log('üîç Admin request for church ID:', churchId, 'from:', req.session.user?.email);\\n\\n        if (isNaN(churchId)) {\\n            return res.status(400).json({\\n                success: false,\\n                message: 'Invalid church ID format'\\n            });\\n        }\\n\\n        const [churchResult] = await promisePool.query(\\n            `SELECT \\n                id, name, email, phone, address, city, state_province, postal_code, \\n                country, website, preferred_language, timezone, currency, tax_id,\\n                description_multilang, settings, is_active, database_name,\\n                has_baptism_records, has_marriage_records, has_funeral_records, \\n                setup_complete, created_at, updated_at\\n            FROM churches \\n            WHERE id = ? AND is_active = 1`,\\n            [churchId]\\n        );\\n\\n        if (churchResult.length === 0) {\\n            console.log('‚ùå Church not found with ID:', churchId);\\n            return res.status(404).json({\\n                success: false,\\n                message: 'Church not found'\\n            });\\n        }\\n\\n        const church = churchResult[0];\\n        console.log('‚úÖ Church found for editing:', church.name);\\n\\n        res.json({\\n            success: true,\\n            ...church, // Return the church data directly for compatibility with frontend\\n            church_id: church.id, // Add church_id for frontend compatibility\\n            // Add backward compatibility aliases\\n            admin_email: church.email,\\n            church_name: church.name,\\n            language_preference: church.preferred_language || 'en'\\n        });\\n    } catch (error) {\\n        console.error('‚ùå Error fetching church for admin:', error);\\n        res.status(500).json({\\n            success: false,\\n            message: 'Failed to fetch church',\\n            error: error.message\\n        });\\n    }\\n});\\n\\n// POST /admin/churches - Create new church (super_admin only)\\n\\n// POST /admin/churches/wizard - Create church via comprehensive wizard (super_admin only)\\nrouter.post('/churches/wizard', requireSuperAdmin, async (req, res) => {\\n    try {\\n        console.log('üßô‚Äç‚ôÇÔ∏è Church Setup Wizard request:', req.body);\\n        \\n        const {\\n            // Basic church info\\n            name, email, phone, address, city, state_province, postal_code, country,\\n            website, preferred_language = 'en', timezone = 'UTC', currency = 'USD', is_active = true,\\n            \\n            // Template selection\\n            template_church_id = null,\\n            selected_tables = [],\\n            \\n            // Custom fields\\n            custom_fields = [],\\n            \\n            // Initial users\\n            initial_users = [],\\n            \\n            // Landing page configuration\\n            custom_landing_page = { enabled: false }\\n        } = req.body;\\n\\n        // Validate required fields\\n        if (!name || !email) {\\n            return res.status(400).json({\\n                success: false,\\n                message: 'Church name and email are required'\\n            });\\n        }\\n\\n        // Check for existing church with same name or email\\n        const [existingChurches] = await promisePool.query(\\n            'SELECT id FROM churches WHERE name = ? OR email = ?',\\n            [name, email]\\n        );\\n\\n        if (existingChurches.length > 0) {\\n            return res.status(400).json({\\n                success: false,\\n                message: 'Church with this name or email already exists'\\n            });\\n        }\\n\\n        // Validate template church if specified\\n        let templateChurch = null;\\n        if (template_church_id) {\\n            const [templateChurches] = await promisePool.query(\\n                'SELECT * FROM churches WHERE id = ? AND preferred_language = ? AND is_active = 1',\\n                [template_church_id, 'en']\\n            );\\n\\n            if (templateChurches.length === 0) {\\n                return res.status(400).json({\\n                    success: false,\\n                    message: 'Template church not found or not an active English church'\\n                });\\n            }\\n\\n            templateChurch = templateChurches[0];\\n            console.log('üéØ Using wizard template church:', templateChurch.name);\\n        }\\n\\n        // Generate unique church_id and database name\\n        const generateChurchId = (churchName) => {\\n            const prefix = churchName\\n                .split(' ')\\n                .map(word => word.charAt(0).toUpperCase())\\n                .join('')\\n                .substring(0, 6);\\n            const timestamp = Date.now().toString().slice(-6);\\n            return parseInt(`${timestamp}${Math.floor(Math.random() * 100)}`);\\n        };\\n\\n        const church_id = generateChurchId(name);\\n        const sanitizedName = name\\n            .toLowerCase()\\n            .replace(/[^a-z0-9\\\\s]/g, '')\\n            .replace(/\\\\s+/g, '_')\\n            .substring(0, 30);\\n        \\n        const database_name = `${church_id}_${sanitizedName}_db`;\\n\\n        // Insert new church into orthodoxmetrics_db.churches\\n        const [result] = await promisePool.query(`\\n            INSERT INTO churches (\\n                name, email, phone, address, city, state_province, postal_code, \\n                country, website, preferred_language, timezone, currency, is_active,\\n                database_name, setup_complete, created_at, updated_at,\\n                church_name, admin_email, language_preference\\n            ) \\n            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, ?, ?, ?)\\n        `, [\\n            name, email, phone, address, city, state_province, postal_code,\\n            country, website, preferred_language, timezone, currency, is_active ? 1 : 0,\\n            database_name, false, // Will be set to true after full setup\\n            name, email, preferred_language\\n        ]);\\n\\n        const newChurchDbId = result.insertId;\\n        console.log('‚úÖ Church created in orthodoxmetrics_db with ID:', newChurchDbId);\\n\\n        // Create individual church database with comprehensive setup\\n        try {\\n            console.log('üîÑ Creating church-specific database with wizard settings:', database_name);\\n            \\n            // Create the database\\n            await promisePool.query(`CREATE DATABASE IF NOT EXISTS \\\\`${database_name}\\\\``);\\n            await promisePool.query(`USE \\\\`${database_name}\\\\``);\\n            \\n            // Create church_info table with the same church_id\\n            await promisePool.query(`\\n                CREATE TABLE IF NOT EXISTS church_info (\\n                    id INT PRIMARY KEY AUTO_INCREMENT,\\n                    church_id INT NOT NULL DEFAULT ${church_id},\\n                    name VARCHAR(255) NOT NULL DEFAULT '${name}',\\n                    email VARCHAR(255) NOT NULL DEFAULT '${email}',\\n                    phone VARCHAR(50),\\n                    address TEXT,\\n                    city VARCHAR(100),\\n                    state_province VARCHAR(100),\\n                    country VARCHAR(100),\\n                    preferred_language VARCHAR(10) DEFAULT '${preferred_language}',\\n                    timezone VARCHAR(50) DEFAULT '${timezone}',\\n                    currency VARCHAR(10) DEFAULT '${currency}',\\n                    is_active BOOLEAN DEFAULT TRUE,\\n                    custom_landing_page JSON,\\n                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\\n                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\\n                    UNIQUE KEY uk_church_id (church_id)\\n                )\\n            `);\\n\\n            // Insert church info with landing page configuration\\n            await promisePool.query(`\\n                INSERT INTO church_info (\\n                    church_id, name, email, phone, address, city, state_province, \\n                    country, preferred_language, timezone, currency, is_active, custom_landing_page\\n                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, ?, ?, ?)\\n            `, [\\n                church_id, name, email, phone, address, city, state_province,\\n                country, preferred_language, timezone, currency, is_active ? 1 : 0,\\n                JSON.stringify(custom_landing_page)\\n            ]);\\n\\n            // If template church is specified, clone its structure\\n            if (templateChurch && templateChurch.database_name) {\\n                console.log('üéØ Cloning structure from wizard template church database:', templateChurch.database_name);\\n                \\n                try {\\n                    // Clone table structures (excluding data)\\n                    const [templateTables] = await promisePool.query(`\\n                        SELECT TABLE_NAME \\n                        FROM information_schema.TABLES \\n                        WHERE TABLE_SCHEMA = ? \\n                        AND TABLE_NAME NOT IN ('church_info')\\n                        AND TABLE_NAME IN (${selected_tables.map(() => '?').join(',')})\\n                    `, [templateChurch.database_name, ...selected_tables]);\\n\\n                    for (const table of templateTables) {\\n                        const tableName = table.TABLE_NAME;\\n                        console.log(`üìã Cloning wizard table structure: ${tableName}`);\\n                        \\n                        // Get CREATE TABLE statement from template\\n                        const [createTableResult] = await promisePool.query(`SHOW CREATE TABLE \\\\`${templateChurch.database_name}\\\\`.\\\\`${tableName}\\\\``);\\n                        let createStatement = createTableResult[0]['Create Table'];\\n                        \\n                        // Replace table name and execute in new database\\n                        createStatement = createStatement.replace(`CREATE TABLE \\\\`${tableName}\\\\``, `CREATE TABLE IF NOT EXISTS \\\\`${database_name}\\\\`.\\\\`${tableName}\\\\``);\\n                        await promisePool.query(createStatement);\\n                    }\\n                    \\n                    console.log('‚úÖ Wizard template structure cloned successfully');\\n                } catch (templateError) {\\n                    console.warn('‚ö†Ô∏è Wizard template cloning failed (non-critical):', templateError.message);\\n                }\\n            }\\n\\n            // Create all selected record tables\\n            console.log('üìã Creating wizard selected record tables:', selected_tables);\\n            \\n            const tableDefinitions = {\\n                'baptism_records': `\\n                    CREATE TABLE IF NOT EXISTS \\\\`${database_name}\\\\`.baptism_records (\\n                        id INT PRIMARY KEY AUTO_INCREMENT,\\n                        church_id INT NOT NULL DEFAULT ${church_id},\\n                        first_name VARCHAR(255) NOT NULL,\\n                        middle_name VARCHAR(255),\\n                        last_name VARCHAR(255) NOT NULL,\\n                        birth_date DATE,\\n                        baptism_date DATE NOT NULL,\\n                        birth_place VARCHAR(255),\\n                        baptism_place VARCHAR(255),\\n                        father_name VARCHAR(255),\\n                        mother_name VARCHAR(255),\\n                        godfather_name VARCHAR(255),\\n                        godmother_name VARCHAR(255),\\n                        godparents VARCHAR(500),\\n                        priest_name VARCHAR(255),\\n                        sponsors VARCHAR(500),\\n                        parents VARCHAR(500),\\n                        clergy VARCHAR(255),\\n                        certificate_number VARCHAR(100),\\n                        book_number VARCHAR(100),\\n                        page_number VARCHAR(100),\\n                        entry_number VARCHAR(100),\\n                        notes TEXT,\\n                        created_by INT,\\n                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\\n                        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\\n                        INDEX idx_baptism_church_id (church_id),\\n                        INDEX idx_baptism_names (first_name, last_name),\\n                        INDEX idx_baptism_date (baptism_date)\\n                    )\\n                `,\\n                'marriage_records': `\\n                    CREATE TABLE IF NOT EXISTS \\\\`${database_name}\\\\`.marriage_records (\\n                        id INT PRIMARY KEY AUTO_INCREMENT,\\n                        church_id INT NOT NULL DEFAULT ${church_id},\\n                        groom_first_name VARCHAR(255) NOT NULL,\\n                        groom_middle_name VARCHAR(255),\\n                        groom_last_name VARCHAR(255) NOT NULL,\\n                        bride_first_name VARCHAR(255) NOT NULL,\\n                        bride_middle_name VARCHAR(255),\\n                        bride_last_name VARCHAR(255) NOT NULL,\\n                        marriage_date DATE NOT NULL,\\n                        marriage_place VARCHAR(255),\\n                        groom_father VARCHAR(255),\\n                        groom_mother VARCHAR(255),\\n                        bride_father VARCHAR(255),\\n                        bride_mother VARCHAR(255),\\n                        priest_name VARCHAR(255),\\n                        best_man VARCHAR(255),\\n                        maid_of_honor VARCHAR(255),\\n                        witness1 VARCHAR(255),\\n                        witness2 VARCHAR(255),\\n                        certificate_number VARCHAR(100),\\n                        book_number VARCHAR(100),\\n                        page_number VARCHAR(100),\\n                        entry_number VARCHAR(100),\\n                        notes TEXT,\\n                        created_by INT,\\n                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\\n                        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\\n                        INDEX idx_marriage_church_id (church_id),\\n                        INDEX idx_marriage_groom (groom_first_name, groom_last_name),\\n                        INDEX idx_marriage_bride (bride_first_name, bride_last_name),\\n                        INDEX idx_marriage_date (marriage_date)\\n                    )\\n                `,\\n                'funeral_records': `\\n                    CREATE TABLE IF NOT EXISTS \\\\`${database_name}\\\\`.funeral_records (\\n                        id INT PRIMARY KEY AUTO_INCREMENT,\\n                        church_id INT NOT NULL DEFAULT ${church_id},\\n                        first_name VARCHAR(255) NOT NULL,\\n                        middle_name VARCHAR(255),\\n                        last_name VARCHAR(255) NOT NULL,\\n                        birth_date DATE,\\n                        death_date DATE,\\n                        funeral_date DATE NOT NULL,\\n                        birth_place VARCHAR(255),\\n                        death_place VARCHAR(255),\\n                        funeral_place VARCHAR(255),\\n                        father_name VARCHAR(255),\\n                        mother_name VARCHAR(255),\\n                        spouse_name VARCHAR(255),\\n                        priest_name VARCHAR(255),\\n                        cause_of_death VARCHAR(255),\\n                        cemetery VARCHAR(255),\\n                        plot_number VARCHAR(100),\\n                        certificate_number VARCHAR(100),\\n                        book_number VARCHAR(100),\\n                        page_number VARCHAR(100),\\n                        entry_number VARCHAR(100),\\n                        notes TEXT,\\n                        created_by INT,\\n                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\\n                        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\\n                        INDEX idx_funeral_church_id (church_id),\\n                        INDEX idx_funeral_names (first_name, last_name),\\n                        INDEX idx_funeral_date (funeral_date)\\n                    )\\n                `,\\n                'clergy': `\\n                    CREATE TABLE IF NOT EXISTS \\\\`${database_name}\\\\`.clergy (\\n                        id INT PRIMARY KEY AUTO_INCREMENT,\\n                        church_id INT NOT NULL DEFAULT ${church_id},\\n                        first_name VARCHAR(255) NOT NULL,\\n                        last_name VARCHAR(255) NOT NULL,\\n                        title VARCHAR(100),\\n                        position VARCHAR(100),\\n                        ordination_date DATE,\\n                        start_date DATE,\\n                        end_date DATE,\\n                        email VARCHAR(255),\\n                        phone VARCHAR(50),\\n                        is_active BOOLEAN DEFAULT TRUE,\\n                        notes TEXT,\\n                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\\n                        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\\n                        INDEX idx_clergy_church_id (church_id),\\n                        INDEX idx_clergy_names (first_name, last_name)\\n                    )\\n                `,\\n                'members': `\\n                    CREATE TABLE IF NOT EXISTS \\\\`${database_name}\\\\`.members (\\n                        id INT PRIMARY KEY AUTO_INCREMENT,\\n                        church_id INT NOT NULL DEFAULT ${church_id},\\n                        first_name VARCHAR(255) NOT NULL,\\n                        last_name VARCHAR(255) NOT NULL,\\n                        email VARCHAR(255),\\n                        phone VARCHAR(50),\\n                        address TEXT,\\n                        city VARCHAR(100),\\n                        state_province VARCHAR(100),\\n                        postal_code VARCHAR(20),\\n                        country VARCHAR(100),\\n                        birth_date DATE,\\n                        baptism_date DATE,\\n                        membership_date DATE,\\n                        membership_status VARCHAR(50) DEFAULT 'active',\\n                        notes TEXT,\\n                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\\n                        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\\n                        INDEX idx_members_church_id (church_id),\\n                        INDEX idx_members_names (first_name, last_name),\\n                        INDEX idx_members_email (email)\\n                    )\\n                `,\\n                'donations': `\\n                    CREATE TABLE IF NOT EXISTS \\\\`${database_name}\\\\`.donations (\\n                        id INT PRIMARY KEY AUTO_INCREMENT,\\n                        church_id INT NOT NULL DEFAULT ${church_id},\\n                        donor_name VARCHAR(255),\\n                        amount DECIMAL(10,2) NOT NULL,\\n                        currency VARCHAR(10) DEFAULT '${currency}',\\n                        donation_date DATE NOT NULL,\\n                        category VARCHAR(100),\\n                        method VARCHAR(50),\\n                        reference_number VARCHAR(100),\\n                        notes TEXT,\\n                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\\n                        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\\n                        INDEX idx_donations_church_id (church_id),\\n                        INDEX idx_donations_date (donation_date),\\n                        INDEX idx_donations_amount (amount)\\n                    )\\n                `,\\n                'calendar_events': `\\n                    CREATE TABLE IF NOT EXISTS \\\\`${database_name}\\\\`.calendar_events (\\n                        id INT PRIMARY KEY AUTO_INCREMENT,\\n                        church_id INT NOT NULL DEFAULT ${church_id},\\n                        title VARCHAR(255) NOT NULL,\\n                        description TEXT,\\n                        event_date DATE NOT NULL,\\n                        start_time TIME,\\n                        end_time TIME,\\n                        event_type VARCHAR(100),\\n                        location VARCHAR(255),\\n                        is_recurring BOOLEAN DEFAULT FALSE,\\n                        recurrence_pattern VARCHAR(100),\\n                        created_by INT,\\n                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\\n                        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\\n                        INDEX idx_events_church_id (church_id),\\n                        INDEX idx_events_date (event_date),\\n                        INDEX idx_events_type (event_type)\\n                    )\\n                `,\\n                'confession_records': `\\n                    CREATE TABLE IF NOT EXISTS \\\\`${database_name}\\\\`.confession_records (\\n                        id INT PRIMARY KEY AUTO_INCREMENT,\\n                        church_id INT NOT NULL DEFAULT ${church_id},\\n                        person_name VARCHAR(255),\\n                        confession_date DATE NOT NULL,\\n                        priest_name VARCHAR(255),\\n                        notes TEXT,\\n                        is_confidential BOOLEAN DEFAULT TRUE,\\n                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\\n                        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\\n                        INDEX idx_confession_church_id (church_id),\\n                        INDEX idx_confession_date (confession_date)\\n                    )\\n                `,\\n                'communion_records': `\\n                    CREATE TABLE IF NOT EXISTS \\\\`${database_name}\\\\`.communion_records (\\n                        id INT PRIMARY KEY AUTO_INCREMENT,\\n                        church_id INT NOT NULL DEFAULT ${church_id},\\n                        person_name VARCHAR(255),\\n                        communion_date DATE NOT NULL,\\n                        service_type VARCHAR(100),\\n                        priest_name VARCHAR(255),\\n                        notes TEXT,\\n                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\\n                        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\\n                        INDEX idx_communion_church_id (church_id),\\n                        INDEX idx_communion_date (communion_date)\\n                    )\\n                `,\\n                'chrismation_records': `\\n                    CREATE TABLE IF NOT EXISTS \\\\`${database_name}\\\\`.chrismation_records (\\n                        id INT PRIMARY KEY AUTO_INCREMENT,\\n                        church_id INT NOT NULL DEFAULT ${church_id},\\n                        first_name VARCHAR(255) NOT NULL,\\n                        last_name VARCHAR(255) NOT NULL,\\n                        chrismation_date DATE NOT NULL,\\n                        baptism_date DATE,\\n                        sponsor_name VARCHAR(255),\\n                        priest_name VARCHAR(255),\\n                        confirmation_name VARCHAR(255),\\n                        certificate_number VARCHAR(100),\\n                        notes TEXT,\\n                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\\n                        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\\n                        INDEX idx_chrismation_church_id (church_id),\\n                        INDEX idx_chrismation_names (first_name, last_name),\\n                        INDEX idx_chrismation_date (chrismation_date)\\n                    )\\n                `\\n            };\\n\\n            // Create selected tables\\n            for (const tableName of selected_tables) {\\n                if (tableDefinitions[tableName]) {\\n                    await promisePool.query(tableDefinitions[tableName]);\\n                    console.log(`‚úÖ Created table: ${tableName}`);\\n                }\\n            }\\n\\n            // Add custom fields to selected tables\\n            if (custom_fields && custom_fields.length > 0) {\\n                console.log('üîß Adding custom fields:', custom_fields);\\n                \\n                for (const field of custom_fields) {\\n                    try {\\n                        let fieldDefinition = `${field.field_name} ${field.field_type}`;\\n                        \\n                        if (field.field_type === 'VARCHAR' && field.field_length) {\\n                            fieldDefinition += `(${field.field_length})`;\\n                        }\\n                        \\n                        if (field.is_required) {\\n                            fieldDefinition += ' NOT NULL';\\n                        }\\n                        \\n                        if (field.default_value) {\\n                            fieldDefinition += ` DEFAULT '${field.default_value}'`;\\n                        }\\n\\n                        await promisePool.query(`\\n                            ALTER TABLE \\\\`${database_name}\\\\`.\\\\`${field.table_name}\\\\` \\n                            ADD COLUMN ${fieldDefinition}\\n                        `);\\n                        \\n                        console.log(`‚úÖ Added custom field: ${field.field_name} to ${field.table_name}`);\\n                    } catch (fieldError) {\\n                        console.warn(`‚ö†Ô∏è Failed to add custom field ${field.field_name}:`, fieldError.message);\\n                    }\\n                }\\n            }\\n\\n            // NOTE: Users are stored in orthodoxmetrics_db, not in individual church databases\\n            // Church databases are for records only. User management is handled centrally.\\n            // Use the church_users junction table in orthodoxmetrics_db to assign users to churches.\\n\\n            // Add initial users to orthodoxmetrics_db (not church database)\\n            if (initial_users && initial_users.length > 0) {\\n                console.log('üë• Adding initial users to orthodoxmetrics_db:', initial_users.length);\\n                \\n                for (const user of initial_users) {\\n                    try {\\n                        // Check if user already exists in orthodoxmetrics_db\\n                        const [existingUsers] = await promisePool.query(\\n                            'SELECT id FROM users WHERE email = ?',\\n                            [user.email]\\n                        );\\n\\n                        let userId;\\n                        if (existingUsers.length > 0) {\\n                            userId = existingUsers[0].id;\\n                            console.log(`üë§ User ${user.email} already exists, using existing user`);\\n                        } else {\\n                            // Create new user in orthodoxmetrics_db\\n                            const tempPassword = Math.random().toString(36).slice(-12);\\n                            const bcrypt = require('bcrypt');\\n                            const hashedPassword = await bcrypt.hash(tempPassword, 10);\\n\\n                            const [result] = await promisePool.query(`\\n                                INSERT INTO users (\\n                                    email, first_name, last_name, role, church_id, \\n                                    password_hash, is_active, created_at, updated_at\\n                                ) VALUES (?, ?, ?, ?, ?, ?, ?, NOW(), NOW())\\n                            `, [\\n                                user.email, user.first_name, user.last_name, user.role, church_id,\\n                                hashedPassword, true\\n                            ]);\\n                            \\n                            userId = result.insertId;\\n                            console.log(`‚úÖ Created user: ${user.first_name} ${user.last_name} (${user.role}) with temp password: ${tempPassword}`);\\n                        }\\n\\n                        // Assign user to church via church_users junction table\\n                        await promisePool.query(\\n                            'INSERT INTO church_users (church_id, user_id, role) VALUES (?, ?, ?) ON DUPLICATE KEY UPDATE role = VALUES(role)',\\n                            [church_id, userId, user.role]\\n                        );\\n                        \\n                        // TODO: Send invitation email if user.send_invite is true\\n                        if (user.send_invite) {\\n                            console.log(`üìß TODO: Send invitation email to ${user.email}`);\\n                        }\\n                    } catch (userError) {\\n                        console.warn(`‚ö†Ô∏è Failed to add user ${user.email}:`, userError.message);\\n                    }\\n                }\\n            }\\n\\n            // Create church settings table for landing page and other configurations\\n            await promisePool.query(`\\n                CREATE TABLE IF NOT EXISTS \\\\`${database_name}\\\\`.church_settings (\\n                    id INT PRIMARY KEY AUTO_INCREMENT,\\n                    church_id INT NOT NULL DEFAULT ${church_id},\\n                    setting_key VARCHAR(255) NOT NULL,\\n                    setting_value JSON,\\n                    description TEXT,\\n                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\\n                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\\n                    UNIQUE KEY uk_church_setting (church_id, setting_key),\\n                    INDEX idx_settings_church_id (church_id)\\n                )\\n            `);\\n\\n            // Store landing page configuration in settings\\n            if (custom_landing_page && custom_landing_page.enabled) {\\n                await promisePool.query(`\\n                    INSERT INTO \\\\`${database_name}\\\\`.church_settings (\\n                        church_id, setting_key, setting_value, description\\n                    ) VALUES (?, 'custom_landing_page', ?, 'Custom landing page configuration with default app')\\n                `, [church_id, JSON.stringify(custom_landing_page)]);\\n                console.log('‚úÖ Stored custom landing page configuration with default app');\\n            }\\n\\n            // Switch back to main database and mark setup as complete\\n            await promisePool.query('USE orthodoxmetrics_db');\\n            await promisePool.query('UPDATE churches SET setup_complete = 1 WHERE id = ?', [newChurchDbId]);\\n\\n            console.log('üéâ Church Setup Wizard completed successfully!');\\n\\n        } catch (dbError) {\\n            console.error('‚ùå Database setup failed:', dbError);\\n            \\n            // Rollback: delete the church record if database setup failed\\n            try {\\n                await promisePool.query('DELETE FROM churches WHERE id = ?', [newChurchDbId]);\\n                console.log('üîÑ Rolled back church record due to database setup failure');\\n            } catch (rollbackError) {\\n                console.error('‚ùå Rollback failed:', rollbackError);\\n            }\\n            \\n            throw new Error(`Database setup failed: ${dbError.message}`);\\n        }\\n\\n        // Fetch the created church with all details\\n        const [newChurch] = await promisePool.query(`\\n            SELECT * FROM churches WHERE id = ?\\n        `, [newChurchDbId]);\\n\\n        res.json({\\n            success: true,\\n            message: `Church \\\"${name}\\\" created successfully via wizard`,\\n            church: newChurch[0],\\n            wizard_summary: {\\n                template_used: templateChurch ? templateChurch.name : null,\\n                tables_created: selected_tables.length,\\n                custom_fields_added: custom_fields.length,\\n                initial_users_added: initial_users.length,\\n                landing_page_configured: custom_landing_page.enabled,\\n                church_id: church_id,\\n                database_name: database_name\\n            }\\n        });\\n\\n    } catch (error) {\\n        console.error('‚ùå Church wizard creation failed:', error);\\n        res.status(500).json({\\n            success: false,\\n            message: 'Failed to create church via wizard',\\n            error: error.message\\n        });\\n    }\\n});\\n\\n// PUT /admin/churches/:id - Update church (super_admin only)\\n\\n// DELETE /admin/churches/:id - Delete church (super_admin only)\\nrouter.delete('/churches/:id', requireSuperAdmin, async (req, res) => {\\n    try {\\n        const churchId = parseInt(req.params.id);\\n\\n        // Check if there are users assigned to this church\\n        const [userRows] = await promisePool.query(\\n            'SELECT COUNT(*) as user_count FROM users WHERE church_id = ?',\\n            [churchId]\\n        );\\n\\n        if (userRows[0].user_count > 0) {\\n            return res.status(400).json({\\n                success: false,\\n                message: 'Cannot delete church with assigned users. Please reassign users first.'\\n            });\\n        }\\n\\n        // Get church info before deletion\\n        const [churchRows] = await promisePool.query(\\n            'SELECT name FROM churches WHERE id = ?',\\n            [churchId]\\n        );\\n\\n        if (churchRows.length === 0) {\\n            return res.status(404).json({\\n                success: false,\\n                message: 'Church not found'\\n            });\\n        }\\n\\n        // Delete church\\n        await promisePool.query('DELETE FROM churches WHERE id = ?', [churchId]);\\n\\n        console.log(`‚úÖ Church deleted successfully: ${churchRows[0].name} by admin ${req.session.user.email}`);\\n\\n        res.json({\\n            success: true,\\n            message: 'Church deleted successfully'\\n        });\\n\\n    } catch (err) {\\n        console.error('Error deleting church:', err);\\n        res.status(500).json({\\n            success: false,\\n            message: 'Server error while deleting church'\\n        });\\n    }\\n});\\n\\n// GET /admin/church/:id - Get individual church data for admin panel\\n\\n// POST /admin/users/:id/reset-password - Reset user password\\nrouter.post('/users/:id/reset-password', requireAdmin, async (req, res) => {\\n    try {\\n        const userId = parseInt(req.params.id);\\n\\n        // Don't allow reset of current user's password\\n        if (userId === req.session.user.id) {\\n            return res.status(400).json({\\n                success: false,\\n                message: 'You cannot reset your own password'\\n            });\\n        }\\n\\n        // Get user info and check permissions\\n        const [userRows] = await promisePool.query(\\n            'SELECT email, role FROM users WHERE id = ?',\\n            [userId]\\n        );\\n\\n        if (userRows.length === 0) {\\n            return res.status(404).json({\\n                success: false,\\n                message: 'User not found'\\n            });\\n        }\\n\\n        const targetUserRole = userRows[0].role;\\n        const currentUserRole = req.session.user.role;\\n\\n        // Super admin can reset any role except super_admin\\n        if (currentUserRole === 'super_admin') {\\n            if (targetUserRole === 'super_admin') {\\n                return res.status(403).json({\\n                    success: false,\\n                    message: 'Cannot reset super_admin passwords'\\n                });\\n            }\\n        }\\n\\n        // Regular admin cannot reset admin or super_admin passwords\\n        if (currentUserRole === 'admin') {\\n            if (targetUserRole === 'admin' || targetUserRole === 'super_admin') {\\n                return res.status(403).json({\\n                    success: false,\\n                    message: 'Cannot reset admin or super_admin passwords'\\n                });\\n            }\\n        }\\n\\n        // Generate new temporary password\\n        const tempPassword = Math.random().toString(36).slice(-12) + Math.random().toString(36).slice(-12);\\n\\n        // Hash the password\\n        const saltRounds = 12;\\n        const passwordHash = await bcrypt.hash(tempPassword, saltRounds);\\n\\n        // Update user password\\n        await promisePool.query(\\n            'UPDATE users SET password_hash = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?',\\n            [passwordHash, userId]\\n        );\\n\\n        console.log(`‚úÖ Password reset for user: ${userRows[0].email} by admin ${req.session.user.email}`);\\n        console.log(`üîê New temporary password for ${userRows[0].email}: ${tempPassword}`);\\n\\n        // TODO: Send password via secure email instead of returning in response\\n        res.json({\\n            success: true,\\n            message: 'Password reset successfully. New password has been logged securely for admin retrieval.'\\n        });\\n\\n    } catch (err) {\\n        console.error('Error resetting password:'[REDACTED]'Server error while resetting password'\\n        });\\n    }\\n});\\n\\n// PATCH /admin/users/:id/reset-password - Reset user password with custom password\\nrouter.patch('/users/:id/reset-password', requireAdmin, async (req, res) => {\\n    try {\\n        const userId = parseInt(req.params.id);\\n        const { new_password, auto_generate } = req.body;\\n        const currentUser = req.session.user;\\n\\n        // Don't allow reset of current user's password\\n        if (userId === currentUser.id) {\\n            return res.status(400).json({\\n                success: false,\\n                message: 'You cannot reset your own password'\\n            });\\n        }\\n\\n        // Get target user information\\n        const [userRows] = await promisePool.query(\\n            'SELECT id, email, role, first_name, last_name FROM users WHERE id = ?',\\n            [userId]\\n        );\\n\\n        if (userRows.length === 0) {\\n            return res.status(404).json({\\n                success: false,\\n                message: 'User not found'\\n            });\\n        }\\n\\n        const targetUser = userRows[0];\\n\\n        // Check if current user can manage the target user\\n        if (!canManageUser(currentUser, targetUser)) {\\n            logUnauthorizedAttempt(currentUser, targetUser, 'RESET_PASSWORD');\\n            return res.status(403).json({\\n                success: false,\\n                message: 'You do not have permission to reset this user\\\\'s password',\\n                code: 'PASSWORD_RESET_DENIED'\\n            });\\n        }\\n\\n        // Generate or use provided password\\n        let passwordToUse;\\n        if (auto_generate || !new_password) {\\n            // Auto-generate secure password\\n            const charset = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*';\\n            const length = 16;\\n            let password = '';\\n            \\n            // Ensure at least one character from each category\\n            const lowercase = 'abcdefghijklmnopqrstuvwxyz';\\n            const uppercase = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\\n            const numbers = '0123456789';\\n            const symbols = '!@#$%^&*';\\n            \\n            password += lowercase[Math.floor(Math.random() * lowercase.length)];\\n            password += uppercase[Math.floor(Math.random() * uppercase.length)];\\n            password += numbers[Math.floor(Math.random() * numbers.length)];\\n            password += symbols[Math.floor(Math.random() * symbols.length)];\\n            \\n            // Fill the rest randomly\\n            for (let i = 4; i < length; i++) {\\n                password += charset[Math.floor(Math.random() * charset.length)];\\n            }\\n            \\n            // Shuffle the password\\n            passwordToUse = password.split('').sort(() => Math.random() - 0.5).join('');\\n        } else {\\n            // Validate provided password\\n            if (new_password.length < 8) {\\n                return res.status(400).json({\\n                    success: false,\\n                    message: 'Password must be at least 8 characters long'\\n                });\\n            }\\n            passwordToUse = new_password;\\n        }\\n\\n        // Hash the password\\n        const saltRounds = 12;\\n        const passwordHash = await bcrypt.hash(passwordToUse, saltRounds);\\n\\n        // Update user password\\n        await promisePool.query(\\n            'UPDATE users SET password_hash = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?',\\n            [passwordHash, userId]\\n        );\\n\\n        console.log(`‚úÖ Password reset for user: ${targetUser.email} by ${currentUser.email} (role: ${currentUser.role})`);\\n\\n        res.json({\\n            success: true,\\n            message: 'Password reset successfully',\\n            newPassword: auto_generate ? passwordToUse : undefined\\n        });\\n\\n    } catch (err) {\\n        console.error('Error resetting password:'[REDACTED]'Server error while resetting password'\\n        });\\n    }\\n});\\n\\n// PATCH /admin/users/:id/status - Update user status\\nrouter.patch('/users/:id/status', requireAdmin, async (req, res) => {\\n    try {\\n        const userId = parseInt(req.params.id);\\n        const { is_active } = req.body;\\n        const currentUser = req.session.user;\\n\\n        // Don't allow deactivation of the current user\\n        if (userId === currentUser.id && !is_active) {\\n            return res.status(400).json({\\n                success: false,\\n                message: 'You cannot deactivate your own account'\\n            });\\n        }\\n\\n        // Get target user information\\n        const [userRows] = await promisePool.query(\\n            'SELECT id, email, role, first_name, last_name FROM users WHERE id = ?',\\n            [userId]\\n        );\\n\\n        if (userRows.length === 0) {\\n            return res.status(404).json({\\n                success: false,\\n                message: 'User not found'\\n            });\\n        }\\n\\n        const targetUser = userRows[0];\\n\\n        // Check if current user can perform destructive operations (deactivating is considered destructive)\\n        if (!is_active && !canPerformDestructiveOperation(currentUser, targetUser)) {\\n            logUnauthorizedAttempt(currentUser, targetUser, 'DEACTIVATE_USER');\\n            return res.status(403).json({\\n                success: false,\\n                message: 'You do not have permission to deactivate this user',\\n                code: 'DEACTIVATION_DENIED'\\n            });\\n        }\\n\\n        // Check if current user can manage the target user (for activation)\\n        if (is_active && !canManageUser(currentUser, targetUser)) {\\n            logUnauthorizedAttempt(currentUser, targetUser, 'ACTIVATE_USER');\\n            return res.status(403).json({\\n                success: false,\\n                message: 'You do not have permission to activate this user',\\n                code: 'ACTIVATION_DENIED'\\n            });\\n        }\\n\\n        // Update user status\\n        await promisePool.query(\\n            'UPDATE users SET is_active = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?',\\n            [is_active ? 1 : 0, userId]\\n        );\\n\\n        console.log(`‚úÖ User status updated: ${targetUser.email} -> ${is_active ? 'active' : 'inactive'} by ${currentUser.email} (role: ${currentUser.role})`);\\n\\n        res.json({\\n            success: true,\\n            message: `User ${is_active ? 'activated' : 'deactivated'} successfully`\\n        });\\n\\n    } catch (err) {\\n        console.error('Error updating user status:', err);\\n        res.status(500).json({\\n            success: false,\\n            message: 'Server error while updating user status'\\n        });\\n    }\\n});\\n\\n/*\\n// Test endpoint to verify query works (disabled for production)\\nrouter.get('/test-users', requireAdmin, async (req, res) => {\\n    try {\\n        console.log('üîç Testing admin users query...');\\n        \\n        // Test the exact query that was working\\n        const [rows] = await promisePool.query(`\\n            SELECT \\n                u.id,\\n                u.email,\\n                u.first_name,\\n                u.last_name,\\n                u.role,\\n                u.church_id,\\n                c.name as church_name,\\n                u.is_active,\\n                u.email_verified,\\n                u.preferred_language,\\n                u.timezone,\\n                u.landing_page,\\n                u.created_at,\\n                u.updated_at,\\n                u.last_login\\n            FROM users u\\n            LEFT JOIN churches c ON u.church_id = c.id\\n            ORDER BY u.created_at DESC\\n        `);\\n\\n        console.log('‚úÖ Test query successful, returned', rows.length, 'users');\\n        \\n        res.json({\\n            success: true,\\n            count: rows.length,\\n            users: rows\\n        });\\n    } catch (err) {\\n        console.error('‚ùå Test query error:', err.message);\\n        console.error('‚ùå Full error:', err);\\n        res.status(500).json({\\n            success: false,\\n            message: 'Test query failed',\\n            error: err.message\\n        });\\n    }\\n});\\n*/\\n\\n// GET /admin/churches/:id/tables - Get available tables for a church (for template selection)\\n\\n// GET /admin/churches/:id/users - Get church users\\n\\n// GET /admin/churches/:id/record-counts - Get record counts for church\\n\\n// GET /admin/churches/:id/database-info - Get database information\\n\\n// POST /admin/churches/:id/users/:userId/reset-password - Reset user password\\n\\n// POST /admin/churches/:id/users/:userId/lock - Lock user account\\n\\n// POST /admin/churches/:id/users/:userId/unlock - Unlock user account\\n\\n// POST /admin/churches/:id/users - Add new user to church\\n\\n// PUT /admin/churches/:id/users/:userId - Update church user\\n\\n// POST /admin/churches/:id/test-connection - Test database connection\\n\\nmodule.exports = router;\\n\"\n    },\n    \"complexity\": {\n      \"totalLines\": 1188,\n      \"codeLines\": 937,\n      \"commentLines\": 99,\n      \"commentRatio\": 0.09555984555984556,\n      \"averageLineLength\": 47.02413127413127\n    },\n    \"lastAnalyzed\": \"2025-07-26T04:17:11.059Z\"\n  },\n  \"contentHash\": \"acf5a9d7c64574a739b395725a9c063cfd470619bdd496206c2aac8c3a3b015a\",\n  \"discoveredAt\": \"2025-07-26T04:17:11.060Z\"\n}"
    },
    "complexity": {
      "totalLines": 72,
      "codeLines": 72,
      "commentLines": 0,
      "commentRatio": 0,
      "averageLineLength": 738.5555555555555
    },
    "lastAnalyzed": "2025-07-28T07:19:56.592Z"
  },
  "contentHash": "8bf5372c434a83985c1cad0786bc5989f361cbf561c42cf69246f87c52e37ccb",
  "discoveredAt": "2025-07-28T07:19:56.592Z"
}