{
  "id": "3c940122d411",
  "originalPath": "/var/www/orthodox-church-mgmt/orthodoxmetrics/prod/server/services/terminalManager.js",
  "relativePath": "server/services/terminalManager.js",
  "name": "terminalManager.js",
  "extension": ".js",
  "size": 11402,
  "modified": "2025-07-25T22:37:14.401Z",
  "created": "2025-07-25T22:33:55.106Z",
  "classification": {
    "type": "Server Scripts",
    "category": "Backend > Server",
    "confidence": 3
  },
  "metadata": {
    "fileStats": {
      "lines": 375,
      "characters": 11402,
      "words": 1077
    },
    "classification": {
      "type": "Server Scripts",
      "category": "Backend > Server",
      "confidence": 3
    },
    "dependencies": [
      {
        "type": "npm_package",
        "name": "node-pty",
        "line": 6
      },
      {
        "type": "npm_package",
        "name": "os",
        "line": 7
      },
      {
        "type": "npm_package",
        "name": "path",
        "line": 8
      },
      {
        "type": "npm_package",
        "name": "fs",
        "line": 9
      }
    ],
    "security": {
      "findings": [
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 18,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 21,
          "redacted": true
        }
      ],
      "hasSecurityIssues": true,
      "redactedContent": "/**\r\n * Terminal Manager\r\n * Manages actual terminal sessions using node-pty for real shell interaction\r\n */\r\n\r\nconst pty = require('node-pty');\r\nconst os = require('os');\r\nconst path = require('path');\r\nconst fs = require('fs').promises;\r\n\r\nclass TerminalManager {\r\n  constructor() {\r\n    this.terminals = new Map(); // sessionId -> terminal instance\r\n    this.terminalSessions = new Map(); // sessionId -> session data\r\n    \r\n    // Terminal configuration\r\n    this.config = {\r\n      shell: process.env.[REDACTED] || (os.platform() === 'win32' ? 'powershell.exe' : '/bin/bash'),\r\n      cols: 80,\r\n      rows: 24,\r\n      cwd: process.env.[REDACTED] || os.homedir(),\r\n      env: { ...process.env },\r\n      encoding: 'utf8'\r\n    };\r\n    \r\n    console.log(`[Terminal Manager] Initialized with shell: ${this.config.shell}`);\r\n  }\r\n\r\n  /**\r\n   * Create a new terminal session\r\n   * @param {string} sessionId - Unique session identifier\r\n   * @param {object} options - Terminal options (cols, rows, cwd)\r\n   * @returns {object} Terminal session info\r\n   */\r\n  async createTerminal(sessionId, options = {}) {\r\n    try {\r\n      // If terminal already exists for this session, close it first\r\n      if (this.terminals.has(sessionId)) {\r\n        await this.closeTerminal(sessionId);\r\n      }\r\n\r\n      // Merge options with defaults\r\n      const terminalOptions = {\r\n        name: 'xterm-color',\r\n        cols: options.cols || this.config.cols,\r\n        rows: options.rows || this.config.rows,\r\n        cwd: options.cwd || this.config.cwd,\r\n        env: { ...this.config.env, ...options.env },\r\n      };\r\n\r\n      console.log(`[Terminal Manager] Creating terminal for session ${sessionId}`);\r\n      console.log(`[Terminal Manager] Shell: ${this.config.shell}`);\r\n      console.log(`[Terminal Manager] CWD: ${terminalOptions.cwd}`);\r\n      console.log(`[Terminal Manager] Size: ${terminalOptions.cols}x${terminalOptions.rows}`);\r\n\r\n      // Spawn the terminal process\r\n      const ptyProcess = pty.spawn(this.config.shell, [], terminalOptions);\r\n\r\n      console.log(`[Terminal Manager] Spawned shell PID: ${ptyProcess.pid}`);\r\n\r\n      // Store terminal instance\r\n      this.terminals.set(sessionId, ptyProcess);\r\n      \r\n      // Store session data\r\n      const sessionData = {\r\n        sessionId,\r\n        pid: ptyProcess.pid,\r\n        shell: this.config.shell,\r\n        createdAt: new Date(),\r\n        lastActivity: new Date(),\r\n        isActive: true,\r\n        cols: terminalOptions.cols,\r\n        rows: terminalOptions.rows,\r\n        cwd: terminalOptions.cwd\r\n      };\r\n      \r\n      this.terminalSessions.set(sessionId, sessionData);\r\n\r\n      // Set up terminal event handlers\r\n      this.setupTerminalHandlers(sessionId, ptyProcess);\r\n\r\n      // Send initial test command to verify shell is working\r\n      setTimeout(() => {\r\n        console.log(`[Terminal Manager] Sending test command to session ${sessionId}`);\r\n        ptyProcess.write('echo \"JIT Terminal session active - PID: $$\"\\n');\r\n      }, 1000);\r\n\r\n      return {\r\n        success: true,\r\n        sessionId,\r\n        pid: ptyProcess.pid,\r\n        shell: this.config.shell,\r\n        message: 'Terminal session created successfully'\r\n      };\r\n\r\n    } catch (error) {\r\n      console.error(`[Terminal Manager] Failed to create terminal for session ${sessionId}:`, error);\r\n      throw new Error(`Failed to create terminal: ${error.message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set up event handlers for a terminal process\r\n   * @param {string} sessionId - Session identifier\r\n   * @param {object} ptyProcess - The spawned pty process\r\n   */\r\n  setupTerminalHandlers(sessionId, ptyProcess) {\r\n    // Handle terminal output\r\n    ptyProcess.on('data', (data) => {\r\n      console.log(`[Terminal ${sessionId}] OUTPUT:`, data.toString().trim());\r\n      \r\n      // Update last activity\r\n      const session = this.terminalSessions.get(sessionId);\r\n      if (session) {\r\n        session.lastActivity = new Date();\r\n        this.terminalSessions.set(sessionId, session);\r\n      }\r\n      \r\n      // Emit data event that WebSocket can listen to\r\n      ptyProcess.emit('session_data', sessionId, data);\r\n    });\r\n\r\n    // Handle terminal exit\r\n    ptyProcess.on('exit', (code, signal) => {\r\n      console.log(`[Terminal ${sessionId}] CLOSED - code: ${code}, signal: ${signal}`);\r\n      \r\n      // Update session status\r\n      const session = this.terminalSessions.get(sessionId);\r\n      if (session) {\r\n        session.isActive = false;\r\n        session.exitCode = code;\r\n        session.exitSignal = signal;\r\n        session.closedAt = new Date();\r\n        this.terminalSessions.set(sessionId, session);\r\n      }\r\n      \r\n      // Emit exit event\r\n      ptyProcess.emit('session_exit', sessionId, code, signal);\r\n    });\r\n\r\n    // Handle errors\r\n    ptyProcess.on('error', (error) => {\r\n      console.error(`[Terminal ${sessionId}] ERROR:`, error);\r\n      \r\n      // Emit error event\r\n      ptyProcess.emit('session_error', sessionId, error);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Write data to a terminal session\r\n   * @param {string} sessionId - Session identifier\r\n   * @param {string} data - Data to write to terminal\r\n   * @returns {boolean} Success status\r\n   */\r\n  async writeToTerminal(sessionId, data) {\r\n    try {\r\n      const ptyProcess = this.terminals.get(sessionId);\r\n      \r\n      if (!ptyProcess) {\r\n        throw new Error(`Terminal session ${sessionId} not found`);\r\n      }\r\n\r\n      console.log(`[Terminal ${sessionId}] INPUT:`, data.toString().trim());\r\n      \r\n      // Write data to terminal\r\n      ptyProcess.write(data);\r\n      \r\n      // Update last activity\r\n      const session = this.terminalSessions.get(sessionId);\r\n      if (session) {\r\n        session.lastActivity = new Date();\r\n        this.terminalSessions.set(sessionId, session);\r\n      }\r\n      \r\n      return true;\r\n    } catch (error) {\r\n      console.error(`[Terminal Manager] Failed to write to terminal ${sessionId}:`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Resize a terminal session\r\n   * @param {string} sessionId - Session identifier\r\n   * @param {number} cols - Number of columns\r\n   * @param {number} rows - Number of rows\r\n   * @returns {boolean} Success status\r\n   */\r\n  async resizeTerminal(sessionId, cols, rows) {\r\n    try {\r\n      const ptyProcess = this.terminals.get(sessionId);\r\n      \r\n      if (!ptyProcess) {\r\n        throw new Error(`Terminal session ${sessionId} not found`);\r\n      }\r\n\r\n      console.log(`[Terminal ${sessionId}] RESIZE: ${cols}x${rows}`);\r\n      \r\n      // Resize terminal\r\n      ptyProcess.resize(cols, rows);\r\n      \r\n      // Update session data\r\n      const session = this.terminalSessions.get(sessionId);\r\n      if (session) {\r\n        session.cols = cols;\r\n        session.rows = rows;\r\n        session.lastActivity = new Date();\r\n        this.terminalSessions.set(sessionId, session);\r\n      }\r\n      \r\n      return true;\r\n    } catch (error) {\r\n      console.error(`[Terminal Manager] Failed to resize terminal ${sessionId}:`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get terminal session info\r\n   * @param {string} sessionId - Session identifier\r\n   * @returns {object|null} Session data\r\n   */\r\n  getTerminalSession(sessionId) {\r\n    return this.terminalSessions.get(sessionId) || null;\r\n  }\r\n\r\n  /**\r\n   * Get terminal process for event handling\r\n   * @param {string} sessionId - Session identifier\r\n   * @returns {object|null} Terminal process\r\n   */\r\n  getTerminalProcess(sessionId) {\r\n    return this.terminals.get(sessionId) || null;\r\n  }\r\n\r\n  /**\r\n   * Close a terminal session\r\n   * @param {string} sessionId - Session identifier\r\n   * @returns {boolean} Success status\r\n   */\r\n  async closeTerminal(sessionId) {\r\n    try {\r\n      const ptyProcess = this.terminals.get(sessionId);\r\n      \r\n      if (ptyProcess) {\r\n        console.log(`[Terminal Manager] Closing terminal session ${sessionId} (PID: ${ptyProcess.pid})`);\r\n        \r\n        // Kill the process\r\n        ptyProcess.kill();\r\n        \r\n        // Remove from maps\r\n        this.terminals.delete(sessionId);\r\n      }\r\n      \r\n      // Update session status\r\n      const session = this.terminalSessions.get(sessionId);\r\n      if (session) {\r\n        session.isActive = false;\r\n        session.closedAt = new Date();\r\n        this.terminalSessions.set(sessionId, session);\r\n      }\r\n      \r\n      return true;\r\n    } catch (error) {\r\n      console.error(`[Terminal Manager] Failed to close terminal ${sessionId}:`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get all active terminal sessions\r\n   * @returns {Array} List of active sessions\r\n   */\r\n  getActiveSessions() {\r\n    const activeSessions = [];\r\n    \r\n    for (const [sessionId, session] of this.terminalSessions) {\r\n      if (session.isActive) {\r\n        activeSessions.push({\r\n          sessionId: session.sessionId,\r\n          pid: session.pid,\r\n          shell: session.shell,\r\n          createdAt: session.createdAt,\r\n          lastActivity: session.lastActivity,\r\n          cols: session.cols,\r\n          rows: session.rows,\r\n          cwd: session.cwd\r\n        });\r\n      }\r\n    }\r\n    \r\n    return activeSessions;\r\n  }\r\n\r\n  /**\r\n   * Clean up inactive sessions\r\n   */\r\n  cleanup() {\r\n    const now = new Date();\r\n    const inactiveThreshold = 30 * 60 * 1000; // 30 minutes\r\n    \r\n    for (const [sessionId, session] of this.terminalSessions) {\r\n      if (session.isActive && (now - session.lastActivity) > inactiveThreshold) {\r\n        console.log(`[Terminal Manager] Cleaning up inactive session ${sessionId}`);\r\n        this.closeTerminal(sessionId);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Test terminal functionality\r\n   * @returns {object} Test results\r\n   */\r\n  async testTerminal() {\r\n    const testSessionId = `test-${Date.now()}`;\r\n    \r\n    try {\r\n      console.log('[Terminal Manager] Running terminal test...');\r\n      \r\n      // Create test terminal\r\n      const result = await this.createTerminal(testSessionId, {\r\n        cols: 80,\r\n        rows: 24\r\n      });\r\n      \r\n      // Get the process\r\n      const ptyProcess = this.getTerminalProcess(testSessionId);\r\n      \r\n      if (!ptyProcess) {\r\n        throw new Error('Failed to get terminal process');\r\n      }\r\n      \r\n      // Test command execution\r\n      return new Promise((resolve, reject) => {\r\n        let output = '';\r\n        const timeout = setTimeout(() => {\r\n          this.closeTerminal(testSessionId);\r\n          reject(new Error('Terminal test timeout'));\r\n        }, 5000);\r\n        \r\n        ptyProcess.on('data', (data) => {\r\n          output += data.toString();\r\n          \r\n          // Look for test command completion\r\n          if (output.includes('JIT Terminal session active')) {\r\n            clearTimeout(timeout);\r\n            this.closeTerminal(testSessionId);\r\n            \r\n            resolve({\r\n              success: true,\r\n              pid: ptyProcess.pid,\r\n              shell: this.config.shell,\r\n              output: output,\r\n              message: 'Terminal test completed successfully'\r\n            });\r\n          }\r\n        });\r\n        \r\n        ptyProcess.on('error', (error) => {\r\n          clearTimeout(timeout);\r\n          this.closeTerminal(testSessionId);\r\n          reject(error);\r\n        });\r\n      });\r\n      \r\n    } catch (error) {\r\n      await this.closeTerminal(testSessionId);\r\n      throw error;\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = TerminalManager;\r\n"
    },
    "complexity": {
      "totalLines": 375,
      "codeLines": 232,
      "commentLines": 81,
      "commentRatio": 0.25878594249201275,
      "averageLineLength": 34.3482428115016
    },
    "lastAnalyzed": "2025-07-28T07:20:01.128Z"
  },
  "contentHash": "44e5c802f676acaf5c4f951c0e48a13f77042ddd7fa3067b421ca22634e7e6f0",
  "discoveredAt": "2025-07-28T07:20:01.128Z"
}