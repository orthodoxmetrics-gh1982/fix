{
  "id": "cab24a9836fc",
  "originalPath": "/var/www/orthodox-church-mgmt/orthodoxmetrics/prod/server/routes/ocrVision.js",
  "relativePath": "server/routes/ocrVision.js",
  "name": "ocrVision.js",
  "extension": ".js",
  "size": 17830,
  "modified": "2025-07-08T00:12:37.000Z",
  "created": "2025-07-09T00:48:38.482Z",
  "classification": {
    "type": "Server Scripts",
    "category": "Backend > Server",
    "confidence": 7
  },
  "metadata": {
    "fileStats": {
      "lines": 524,
      "characters": 17830,
      "words": 1574
    },
    "classification": {
      "type": "Server Scripts",
      "category": "Backend > Server",
      "confidence": 7
    },
    "dependencies": [
      {
        "type": "npm_package",
        "name": "express",
        "line": 2
      },
      {
        "type": "npm_package",
        "name": "multer",
        "line": 3
      },
      {
        "type": "npm_package",
        "name": "path",
        "line": 4
      },
      {
        "type": "npm_package",
        "name": "fs",
        "line": 5
      },
      {
        "type": "npm_package",
        "name": "uuid",
        "line": 6
      },
      {
        "type": "npm_package",
        "name": "sharp",
        "line": 7
      },
      {
        "type": "npm_package",
        "name": "jsonwebtoken",
        "line": 10
      },
      {
        "type": "npm_package",
        "name": "@google-cloud/vision",
        "line": 16
      }
    ],
    "security": {
      "findings": [
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 27,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 28,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 52,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 86,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 351,
          "redacted": true
        }
      ],
      "hasSecurityIssues": true,
      "redactedContent": "// server/routes/ocrVision.js\r\nconst express = require('express');\r\nconst multer = require('multer');\r\nconst path = require('path');\r\nconst fs = require('fs');\r\nconst { v4: uuidv4 } = require('uuid');\r\nconst sharp = require('sharp');\r\nconst { promisePool } = require('../../config/db');\r\nconst { requireAuth } = require('../middleware/auth');\r\nconst jwt = require('jsonwebtoken');\r\nconst { preprocessImage } = require('../utils/preprocessImage');\r\n\r\n// Initialize Google Vision API client with error handling\r\nlet visionClient = null;\r\ntry {\r\n    const vision = require('@google-cloud/vision');\r\n    visionClient = new vision.ImageAnnotatorClient();\r\n    console.log('Google Vision API client initialized successfully');\r\n} catch (error) {\r\n    console.warn('Google Vision API not available:', error.message);\r\n    console.log('OCR routes will use mock responses instead');\r\n}\r\n\r\nconst router = express.Router();\r\n\r\n// Ensure required directories exist\r\nconst uploadsDir = process.env.[REDACTED] || './uploads';\r\nconst resultsDir = process.env.[REDACTED] || './ocr-results';\r\n\r\nif (!fs.existsSync(uploadsDir)) {\r\n    fs.mkdirSync(uploadsDir, { recursive: true });\r\n}\r\n\r\nif (!fs.existsSync(resultsDir)) {\r\n    fs.mkdirSync(resultsDir, { recursive: true });\r\n}\r\n\r\n// Configure multer for file uploads\r\nconst storage = multer.diskStorage({\r\n    destination: (req, file, cb) => {\r\n        cb(null, uploadsDir);\r\n    },\r\n    filename: (req, file, cb) => {\r\n        const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);\r\n        cb(null, file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname));\r\n    }\r\n});\r\n\r\nconst upload = multer({\r\n    storage,\r\n    limits: {\r\n        fileSize: parseInt(process.env.[REDACTED]) || 20 * 1024 * 1024, // 20MB\r\n        files: 1\r\n    },\r\n    fileFilter: (req, file, cb) => {\r\n        const allowedTypes = [\r\n            'image/jpeg',\r\n            'image/png',\r\n            'image/tiff',\r\n            'image/gif',\r\n            'image/webp',\r\n            'application/pdf'\r\n        ];\r\n\r\n        if (allowedTypes.includes(file.mimetype)) {\r\n            cb(null, true);\r\n        } else {\r\n            cb(new Error(`Unsupported file type: ${file.mimetype}`), false);\r\n        }\r\n    }\r\n});\r\n\r\n// Middleware to verify upload token\r\nconst verifyUploadToken = (req, res, next) => {\r\n    try {\r\n        const authHeader = req.headers.authorization;\r\n        const token = authHeader?.startsWith('Bearer ') ? authHeader.substring(7) : req.body.upload_token;\r\n\r\n        if (!token) {\r\n            return res.status(401).json({\r\n                success: false,\r\n                message: 'Upload token is required'\r\n            });\r\n        }\r\n\r\n        const payload = jwt.verify(token, process.env.[REDACTED] || 'default-secret-change-in-production');\r\n\r\n        // Add token data to request\r\n        req.uploadToken = payload;\r\n        req.tokenAuth = true;\r\n\r\n        console.log('Upload token verified:', payload);\r\n        next();\r\n\r\n    } catch (error) {\r\n        console.error('Upload token verification failed:', error);\r\n\r\n        if (error.name === 'TokenExpiredError') {\r\n            return res.status(401).json({\r\n                success: false,\r\n                message: 'Upload token has expired'\r\n            });\r\n        }\r\n\r\n        return res.status(401).json({\r\n            success: false,\r\n            message: 'Invalid upload token'\r\n        });\r\n    }\r\n};\r\n\r\n// Extract text using Google Vision API\r\nconst extractTextWithVision = async (imagePath, language = 'en') => {\r\n    if (!visionClient) {\r\n        // Return mock response when Google Vision API is not available\r\n        console.log('Google Vision API not available, returning mock OCR response');\r\n        return {\r\n            text: `Mock OCR text extracted from image: ${path.basename(imagePath)}\r\nThis is a simulated OCR response for testing purposes.\r\nLanguage: ${language}\r\nTimestamp: ${new Date().toISOString()}\r\n\r\n[Original image would be processed here with Google Vision API]`,\r\n            confidence: 0.85,\r\n            language: language\r\n        };\r\n    }\r\n\r\n    try {\r\n        const [result] = await visionClient.documentTextDetection({\r\n            image: { source: { filename: imagePath } },\r\n            imageContext: {\r\n                languageHints: [language]\r\n            }\r\n        });\r\n\r\n        const fullTextAnnotation = result.fullTextAnnotation;\r\n        const extractedText = fullTextAnnotation?.text || '';\r\n\r\n        // Calculate confidence score\r\n        let totalConfidence = 0;\r\n        let wordCount = 0;\r\n\r\n        if (fullTextAnnotation?.pages) {\r\n            fullTextAnnotation.pages.forEach(page => {\r\n                page.blocks?.forEach(block => {\r\n                    block.paragraphs?.forEach(paragraph => {\r\n                        paragraph.words?.forEach(word => {\r\n                            if (word.confidence) {\r\n                                totalConfidence += word.confidence;\r\n                                wordCount++;\r\n                            }\r\n                        });\r\n                    });\r\n                });\r\n            });\r\n        }\r\n\r\n        const confidence = wordCount > 0 ? totalConfidence / wordCount : 0;\r\n\r\n        return {\r\n            text: extractedText,\r\n            confidence: confidence,\r\n            wordCount: wordCount,\r\n            fullAnnotation: fullTextAnnotation\r\n        };\r\n    } catch (error) {\r\n        console.error('Google Vision API error:', error);\r\n        throw error;\r\n    }\r\n};\r\n\r\n// Mock OCR for testing when Vision API is not available\r\nconst mockOCR = async (imagePath, language = 'en') => {\r\n    console.log(`Mock OCR processing for ${imagePath} (language: ${language})`);\r\n\r\n    return {\r\n        text: `Mock OCR result for ${path.basename(imagePath)}. Language: ${language}. This is a test extraction that would normally contain the actual text from the image.`,\r\n        confidence: 0.85,\r\n        wordCount: 20,\r\n        fullAnnotation: null\r\n    };\r\n};\r\n\r\n// Generic OCR processing function\r\nconst processOCR = async (req, res, language) => {\r\n    try {\r\n        console.log(`=== OCR Processing Start (${language}) ===`);\r\n        console.log('Request body:', req.body);\r\n        console.log('File info:', req.file ? {\r\n            filename: req.file.filename,\r\n            originalname: req.file.originalname,\r\n            size: req.file.size,\r\n            mimetype: req.file.mimetype\r\n        } : 'No file');\r\n        console.log('Token auth:', req.tokenAuth ? 'Yes' : 'No');\r\n        console.log('Upload token data:', req.uploadToken);\r\n\r\n        const {\r\n            church_id,\r\n            record_type = 'baptism',\r\n            submitted_by,\r\n            auth_token,\r\n            upload_token\r\n        } = req.body;\r\n\r\n        if (!req.file) {\r\n            return res.status(400).json({\r\n                success: false,\r\n                message: 'No file uploaded'\r\n            });\r\n        }\r\n\r\n        // Determine user and church info based on auth method\r\n        let userId, churchId, recordType, submittedBy;\r\n\r\n        if (req.tokenAuth && req.uploadToken) {\r\n            // Token-based upload\r\n            userId = req.uploadToken.created_by || 1;\r\n            churchId = req.uploadToken.church_id;\r\n            recordType = req.uploadToken.record_type || record_type;\r\n            submittedBy = `Token Upload (Church ${churchId})`;\r\n\r\n            console.log('Using token-based authentication');\r\n        } else {\r\n            // Regular authenticated upload\r\n            userId = req.session?.user?.id || req.user?.id || 1;\r\n            churchId = church_id || req.session?.user?.churchId || 1;\r\n            recordType = record_type;\r\n            submittedBy = submitted_by || `User ${userId}`;\r\n\r\n            console.log('Using session-based authentication');\r\n        }\r\n\r\n        const jobId = uuidv4();\r\n        const filePath = req.file.path;\r\n        const preprocessedPath = `${filePath}-processed.png`;\r\n\r\n        // Preprocess image\r\n        const processedImagePath = await preprocessImage(filePath, preprocessedPath);\r\n\r\n        // Extract text using Google Vision API or mock\r\n        let ocrResult;\r\n        try {\r\n            ocrResult = visionClient\r\n                ? await extractTextWithVision(processedImagePath, language)\r\n                : await mockOCR(processedImagePath, language);\r\n        } catch (visionError) {\r\n            console.error('Vision API failed, falling back to mock:', visionError);\r\n            ocrResult = await mockOCR(processedImagePath, language);\r\n        }\r\n\r\n        // Prepare structured result\r\n        const result = {\r\n            id: jobId,\r\n            file_name: req.file.originalname,\r\n            language: language,\r\n            church_id: churchId,\r\n            record_type: recordType,\r\n            submitted_by: submittedBy,\r\n            extracted_text: ocrResult.text,\r\n            confidence: ocrResult.confidence,\r\n            word_count: ocrResult.wordCount,\r\n            file_size: req.file.size,\r\n            mime_type: req.file.mimetype,\r\n            processing_time: new Date(),\r\n            created_at: new Date(),\r\n            status: 'completed',\r\n            auth_method: req.tokenAuth ? 'token' : 'session'\r\n        };\r\n\r\n        // Save result to JSON file\r\n        const resultPath = path.join(resultsDir, `${jobId}.json`);\r\n        fs.writeFileSync(resultPath, JSON.stringify(result, null, 2));\r\n\r\n        // Store in database\r\n        try {\r\n            await promisePool.query(`\r\n        INSERT INTO ocr_sessions (\r\n          session_id,\r\n          user_id,\r\n          original_filename,\r\n          file_path,\r\n          file_size,\r\n          mime_type,\r\n          status,\r\n          extracted_text,\r\n          confidence_score,\r\n          language_code,\r\n          church_id,\r\n          record_type,\r\n          result_json_path\r\n        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\r\n      `, [\r\n                jobId,\r\n                userId,\r\n                req.file.originalname,\r\n                req.file.path,\r\n                req.file.size,\r\n                req.file.mimetype,\r\n                'completed',\r\n                ocrResult.text,\r\n                ocrResult.confidence,\r\n                language,\r\n                churchId,\r\n                recordType,\r\n                resultPath\r\n            ]);\r\n\r\n            console.log(`OCR result saved to database with job ID: ${jobId}`);\r\n        } catch (dbError) {\r\n            console.error('Database save failed:', dbError);\r\n            // Continue anyway, we have the file result\r\n        }\r\n\r\n        // Clean up temporary files\r\n        try {\r\n            if (fs.existsSync(preprocessedPath)) {\r\n                fs.unlinkSync(preprocessedPath);\r\n            }\r\n        } catch (cleanupError) {\r\n            console.error('Cleanup error:', cleanupError);\r\n        }\r\n\r\n        console.log(`=== OCR Processing Complete (${language}) ===`);\r\n\r\n        res.status(200).json({\r\n            success: true,\r\n            jobId: jobId,\r\n            data: result,\r\n            message: 'OCR processing completed successfully'\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(`OCR processing error (${language}):`, error);\r\n\r\n        // Clean up uploaded files on error\r\n        if (req.file && fs.existsSync(req.file.path)) {\r\n            fs.unlinkSync(req.file.path);\r\n        }\r\n\r\n        res.status(500).json({\r\n            success: false,\r\n            message: 'OCR processing failed',\r\n            error: error.message\r\n        });\r\n    }\r\n};\r\n\r\n// Language-specific OCR routes\r\nconst supportedLanguages = (process.env.[REDACTED] || 'en,gr,ru,ro').split(',');\r\n\r\n// Authenticated routes (require login)\r\nsupportedLanguages.forEach(lang => {\r\n    router.post(`/ocr-${lang}`, requireAuth, upload.single('file'), async (req, res) => {\r\n        await processOCR(req, res, lang);\r\n    });\r\n\r\n    console.log(`OCR route registered: /api/ocr-${lang}`);\r\n});\r\n\r\n// Public tokenized upload routes (no login required)\r\nsupportedLanguages.forEach(lang => {\r\n    router.post(`/public-ocr-${lang}`, verifyUploadToken, upload.single('file'), async (req, res) => {\r\n        await processOCR(req, res, lang);\r\n    });\r\n\r\n    console.log(`Public OCR route registered: /api/public-ocr-${lang}`);\r\n});\r\n\r\n// Generic OCR route\r\nrouter.post('/ocr', requireAuth, upload.single('file'), async (req, res) => {\r\n    const language = req.body.language || 'en';\r\n    await processOCR(req, res, language);\r\n});\r\n\r\n// Test OCR route without authentication (for testing purposes)\r\nrouter.post('/test-ocr', upload.single('file'), async (req, res) => {\r\n    console.log('=== Test OCR Route (No Auth) ===');\r\n    await processOCR(req, res, 'en');\r\n});\r\n\r\n// Get OCR result by job ID\r\nrouter.get('/ocr/result/:jobId', requireAuth, async (req, res) => {\r\n    try {\r\n        const { jobId } = req.params;\r\n\r\n        // Try to get from database first\r\n        const [rows] = await promisePool.query(\r\n            'SELECT * FROM ocr_sessions WHERE session_id = ?',\r\n            [jobId]\r\n        );\r\n\r\n        if (rows.length > 0) {\r\n            const dbResult = rows[0];\r\n            res.json({\r\n                success: true,\r\n                completed: true,\r\n                result: {\r\n                    id: dbResult.session_id,\r\n                    text: dbResult.extracted_text,\r\n                    confidence: dbResult.confidence_score,\r\n                    language: dbResult.language_code,\r\n                    filename: dbResult.original_filename,\r\n                    created_at: dbResult.created_at\r\n                }\r\n            });\r\n        } else {\r\n            // Try to get from JSON file\r\n            const resultPath = path.join(resultsDir, `${jobId}.json`);\r\n            if (fs.existsSync(resultPath)) {\r\n                const result = JSON.parse(fs.readFileSync(resultPath, 'utf8'));\r\n                res.json({\r\n                    success: true,\r\n                    completed: true,\r\n                    result: result\r\n                });\r\n            } else {\r\n                res.status(404).json({\r\n                    success: false,\r\n                    message: 'OCR result not found'\r\n                });\r\n            }\r\n        }\r\n    } catch (error) {\r\n        console.error('Error retrieving OCR result:', error);\r\n        res.status(500).json({\r\n            success: false,\r\n            message: 'Failed to retrieve OCR result'\r\n        });\r\n    }\r\n});\r\n\r\n// List OCR results for user\r\nrouter.get('/ocr/results', requireAuth, async (req, res) => {\r\n    try {\r\n        const userId = req.session?.user?.id || req.user?.id;\r\n\r\n        const [rows] = await promisePool.query(\r\n            'SELECT session_id, original_filename, status, confidence_score, language_code, created_at FROM ocr_sessions WHERE user_id = ? ORDER BY created_at DESC LIMIT 50',\r\n            [userId]\r\n        );\r\n\r\n        res.json({\r\n            success: true,\r\n            results: rows\r\n        });\r\n    } catch (error) {\r\n        console.error('Error listing OCR results:', error);\r\n        res.status(500).json({\r\n            success: false,\r\n            message: 'Failed to list OCR results'\r\n        });\r\n    }\r\n});\r\n\r\n// Simple status endpoint for testing OCR service availability\r\nrouter.get('/ocr-status', (req, res) => {\r\n    res.json({\r\n        success: true,\r\n        message: 'OCR Vision API service is running',\r\n        endpoints: {\r\n            authenticated: '/api/ocr-{lang}, /api/ocr',\r\n            public: '/api/public-ocr-{lang}',\r\n            test: '/api/test-ocr'\r\n        },\r\n        supportedLanguages: ['en', 'ru', 'ro', 'gr'],\r\n        maxFileSize: '20MB',\r\n        supportedFormats: ['image/jpeg', 'image/png', 'image/tiff', 'image/gif', 'application/pdf']\r\n    });\r\n});\r\n\r\n// Mock OCR endpoint for testing without Google Vision API\r\nrouter.post('/mock-ocr', upload.single('file'), async (req, res) => {\r\n    try {\r\n        console.log('Mock OCR endpoint called');\r\n\r\n        if (!req.file) {\r\n            return res.status(400).json({\r\n                success: false,\r\n                message: 'No file uploaded'\r\n            });\r\n        }\r\n\r\n        console.log('File received:', req.file.originalname, req.file.size);\r\n\r\n        // Mock OCR results\r\n        const mockResult = {\r\n            success: true,\r\n            message: 'Mock OCR processing completed successfully',\r\n            data: {\r\n                filename: req.file.originalname,\r\n                fileSize: req.file.size,\r\n                language: req.body.language || 'en',\r\n                confidence: 0.95,\r\n                extractedText: `Mock OCR Result for ${req.file.originalname}\\n\\nThis is a sample text extraction that would normally come from Google Vision API.\\n\\nThe file was successfully uploaded and processed.\\n\\nFilename: ${req.file.originalname}\\nFile size: ${req.file.size} bytes\\nLanguage: ${req.body.language || 'en'}\\n\\nOnce you set up Google Vision API, this will be replaced with actual OCR text extraction.`,\r\n                pages: 1,\r\n                processedAt: new Date().toISOString(),\r\n                jobId: 'mock-' + Date.now(),\r\n                extractedFields: {\r\n                    'Document Type': 'Church Record',\r\n                    'Date': '2024-01-01',\r\n                    'Names': 'Sample Name',\r\n                    'Status': 'Mock Processing Complete'\r\n                }\r\n            }\r\n        };\r\n\r\n        console.log('Returning mock result:', mockResult);\r\n\r\n        res.json(mockResult);\r\n\r\n    } catch (error) {\r\n        console.error('Mock OCR error:', error);\r\n        res.status(500).json({\r\n            success: false,\r\n            message: 'Mock OCR processing failed',\r\n            error: error.message\r\n        });\r\n    }\r\n});\r\n\r\nmodule.exports = router;\r\n"
    },
    "complexity": {
      "totalLines": 524,
      "codeLines": 421,
      "commentLines": 34,
      "commentRatio": 0.07472527472527472,
      "averageLineLength": 37.887912087912085
    },
    "lastAnalyzed": "2025-07-28T07:20:00.529Z"
  },
  "contentHash": "b80590ad6fe4c82207e9621429f983e7adc191818638a6a678f1029a23130c14",
  "discoveredAt": "2025-07-28T07:20:00.529Z"
}