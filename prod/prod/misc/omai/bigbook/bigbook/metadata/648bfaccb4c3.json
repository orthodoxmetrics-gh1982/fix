{
  "id": "648bfaccb4c3",
  "originalPath": "/var/www/orthodox-church-mgmt/orthodoxmetrics/prod/server/controllers/OcrAdminTestController.js",
  "relativePath": "server/controllers/OcrAdminTestController.js",
  "name": "OcrAdminTestController.js",
  "extension": ".js",
  "size": 15301,
  "modified": "2025-07-24T14:51:40.496Z",
  "created": "2025-07-24T14:51:40.496Z",
  "classification": {
    "type": "Server Scripts",
    "category": "Backend > Server",
    "confidence": 3
  },
  "metadata": {
    "fileStats": {
      "lines": 485,
      "characters": 15301,
      "words": 1337
    },
    "classification": {
      "type": "Server Scripts",
      "category": "Backend > Server",
      "confidence": 3
    },
    "dependencies": [
      {
        "type": "npm_package",
        "name": "mysql2/promise",
        "line": 7
      },
      {
        "type": "npm_package",
        "name": "@google-cloud/vision",
        "line": 8
      }
    ],
    "security": {
      "findings": [
        {
          "type": "sensitive_data",
          "pattern": "(?:password|pwd|pass)\\s*[:=]\\s*['\"]([^'\"]+)['\"]",
          "line": 17,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "(?:password|pwd|pass)\\s*[:=]\\s*['\"]([^'\"]+)['\"]",
          "line": 23,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "(?:password|pwd|pass)\\s*[:=]\\s*['\"]([^'\"]+)['\"]",
          "line": 29,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 24,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 147,
          "redacted": true
        }
      ],
      "hasSecurityIssues": true,
      "redactedContent": "/**\r\n * OCR Admin Test Controller\r\n * Backend API endpoints for OCR system testing\r\n * Mirrors the command line testing scripts with REST API\r\n */\r\n\r\nconst mysql = require('mysql2/promise');\r\nconst vision = require('@google-cloud/vision');\r\n\r\nclass OcrAdminTestController {\r\n  constructor() {\r\n    // Database configurations\r\n    this.dbConfigs = {\r\n      orthodoxmetrics: {\r\n        host: 'localhost',\r\n        user: 'orthodoxapps',\r\n        password: '[REDACTED]',\r\n        database: 'orthodoxmetrics_db'\r\n      },\r\n      ocr: {\r\n        host: 'localhost',\r\n        user: 'orthodoxapps',\r\n        password: '[REDACTED]',\r\n        database: process.env.[REDACTED] || 'orthodoxmetrics_ocr_db'\r\n      },\r\n      records: {\r\n        host: 'localhost',\r\n        user: 'orthodoxapps',\r\n        password: '[REDACTED]',\r\n        database: 'ssppoc_records_db'\r\n      }\r\n    };\r\n  }\r\n\r\n  // Utility method to check if user is superadmin\r\n  async validateSuperAdmin(req, res, next) {\r\n    try {\r\n      // Check if user exists in session or JWT\r\n      const userEmail = req.user?.email || req.body?.userEmail || req.headers['x-user-email'];\r\n      \r\n      if (userEmail !== 'superadmin@orthodoxmetrics.com') {\r\n        return res.status(403).json({\r\n          success: false,\r\n          message: 'Access denied. SuperAdmin privileges required.'\r\n        });\r\n      }\r\n\r\n      next();\r\n    } catch (error) {\r\n      res.status(500).json({\r\n        success: false,\r\n        message: 'Authentication error',\r\n        error: error.message\r\n      });\r\n    }\r\n  }\r\n\r\n  // Test database connections\r\n  async testDatabaseConnection(req, res) {\r\n    const startTime = Date.now();\r\n    const results = {};\r\n\r\n    try {\r\n      // Test orthodoxmetrics_db\r\n      try {\r\n        const orthodoxConnection = await mysql.createConnection(this.dbConfigs.orthodoxmetrics);\r\n        const [rows] = await orthodoxConnection.execute('SELECT COUNT(*) as count FROM churches');\r\n        await orthodoxConnection.end();\r\n        results.orthodoxmetrics = {\r\n          status: 'connected',\r\n          churches: rows[0].count,\r\n          message: `Connected successfully - ${rows[0].count} churches found`\r\n        };\r\n      } catch (error) {\r\n        results.orthodoxmetrics = {\r\n          status: 'failed',\r\n          error: error.message\r\n        };\r\n      }\r\n\r\n      // Test OCR database\r\n      try {\r\n        const ocrConnection = await mysql.createConnection(this.dbConfigs.ocr);\r\n        const [rows] = await ocrConnection.execute('SELECT COUNT(*) as count FROM ocr_jobs');\r\n        await ocrConnection.end();\r\n        results.ocr = {\r\n          status: 'connected',\r\n          jobs: rows[0].count,\r\n          message: `Connected successfully - ${rows[0].count} OCR jobs found`\r\n        };\r\n      } catch (error) {\r\n        results.ocr = {\r\n          status: 'failed',\r\n          error: error.message\r\n        };\r\n      }\r\n\r\n      // Test Records database\r\n      try {\r\n        const recordsConnection = await mysql.createConnection(this.dbConfigs.records);\r\n        const [tables] = await recordsConnection.execute('SHOW TABLES');\r\n        await recordsConnection.end();\r\n        results.records = {\r\n          status: 'connected',\r\n          tables: tables.length,\r\n          message: `Connected successfully - ${tables.length} tables found`\r\n        };\r\n      } catch (error) {\r\n        results.records = {\r\n          status: 'failed',\r\n          error: error.message\r\n        };\r\n      }\r\n\r\n      const allConnected = Object.values(results).every(r => r.status === 'connected');\r\n      const duration = Date.now() - startTime;\r\n\r\n      res.json({\r\n        success: allConnected,\r\n        message: allConnected ? 'All database connections successful' : 'Some database connections failed',\r\n        details: results,\r\n        duration\r\n      });\r\n    } catch (error) {\r\n      res.status(500).json({\r\n        success: false,\r\n        message: 'Database connection test failed',\r\n        error: error.message,\r\n        duration: Date.now() - startTime\r\n      });\r\n    }\r\n  }\r\n\r\n  // Test OCR schema validation\r\n  async testOcrSchema(req, res) {\r\n    const startTime = Date.now();\r\n\r\n    try {\r\n      const connection = await mysql.createConnection(this.dbConfigs.ocr);\r\n      \r\n      // Check if all required columns exist\r\n      const [columns] = await connection.execute(`\r\n        SELECT COLUMN_NAME \r\n        FROM INFORMATION_SCHEMA.COLUMNS \r\n        WHERE TABLE_SCHEMA = ? \r\n        AND TABLE_NAME = 'ocr_jobs'\r\n      `, [process.env.[REDACTED] || 'orthodoxmetrics_ocr_db']);\r\n\r\n      const requiredColumns = [\r\n        'id', 'church_id', 'file_path', 'original_filename', 'status', 'ocr_result',\r\n        'confidence_score', 'processing_time', 'error_message', 'created_at',\r\n        'updated_at', 'user_id', 'record_type', 'auto_process', 'ocr_result_translation',\r\n        'translation_confidence', 'extracted_entities', 'entity_confidence',\r\n        'needs_review', 'detected_language', 'google_vision_response',\r\n        'processing_started_at', 'processing_completed_at', 'retry_count',\r\n        'priority', 'queue_position', 'file_size'\r\n      ];\r\n\r\n      const existingColumns = columns.map(col => col.COLUMN_NAME);\r\n      const missingColumns = requiredColumns.filter(col => !existingColumns.includes(col));\r\n      \r\n      await connection.end();\r\n\r\n      const duration = Date.now() - startTime;\r\n      const isValid = missingColumns.length === 0;\r\n\r\n      res.json({\r\n        success: isValid,\r\n        message: isValid ? \r\n          `OCR schema validation passed - all ${requiredColumns.length} columns present` :\r\n          `OCR schema validation failed - ${missingColumns.length} missing columns`,\r\n        details: {\r\n          total_required: requiredColumns.length,\r\n          total_existing: existingColumns.length,\r\n          missing_columns: missingColumns,\r\n          existing_columns: existingColumns\r\n        },\r\n        duration\r\n      });\r\n    } catch (error) {\r\n      res.status(500).json({\r\n        success: false,\r\n        message: 'OCR schema validation failed',\r\n        error: error.message,\r\n        duration: Date.now() - startTime\r\n      });\r\n    }\r\n  }\r\n\r\n  // Test Google Vision API\r\n  async testGoogleVision(req, res) {\r\n    const startTime = Date.now();\r\n\r\n    try {\r\n      // Create a simple test image (1x1 pixel base64 image)\r\n      const testImageBase64 = 'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8/5+hHgAHggJ/PchI7wAAAABJRU5ErkJggg==';\r\n      \r\n      const visionClient = new vision.ImageAnnotatorClient();\r\n      const [result] = await visionClient.textDetection({\r\n        image: { content: Buffer.from(testImageBase64, 'base64') }\r\n      });\r\n      \r\n      const duration = Date.now() - startTime;\r\n\r\n      res.json({\r\n        success: true,\r\n        message: 'Google Vision API connection successful',\r\n        details: {\r\n          response_received: !!result,\r\n          api_accessible: true,\r\n          test_completed: true,\r\n          detections: result.textAnnotations ? result.textAnnotations.length : 0\r\n        },\r\n        duration\r\n      });\r\n    } catch (error) {\r\n      res.status(500).json({\r\n        success: false,\r\n        message: 'Google Vision API test failed',\r\n        error: error.message,\r\n        duration: Date.now() - startTime\r\n      });\r\n    }\r\n  }\r\n\r\n  // Test OCR processing queue\r\n  async testOcrQueue(req, res) {\r\n    const startTime = Date.now();\r\n\r\n    try {\r\n      const connection = await mysql.createConnection(this.dbConfigs.ocr);\r\n      \r\n      const [queueStats] = await connection.execute(`\r\n        SELECT \r\n          status,\r\n          COUNT(*) as count\r\n        FROM ocr_jobs \r\n        GROUP BY status\r\n        ORDER BY status\r\n      `);\r\n\r\n      const [recentJobs] = await connection.execute(`\r\n        SELECT id, status, created_at, processing_time\r\n        FROM ocr_jobs \r\n        ORDER BY created_at DESC \r\n        LIMIT 10\r\n      `);\r\n\r\n      await connection.end();\r\n\r\n      const stats = {};\r\n      queueStats.forEach(stat => {\r\n        stats[stat.status] = stat.count;\r\n      });\r\n\r\n      const duration = Date.now() - startTime;\r\n      const hasJobs = queueStats.length > 0;\r\n\r\n      res.json({\r\n        success: hasJobs,\r\n        message: hasJobs ? \r\n          `OCR queue test passed - ${queueStats.reduce((sum, s) => sum + s.count, 0)} total jobs found` :\r\n          'OCR queue test passed - no jobs found',\r\n        details: {\r\n          queue_stats: stats,\r\n          recent_jobs: recentJobs,\r\n          total_jobs: queueStats.reduce((sum, s) => sum + s.count, 0)\r\n        },\r\n        duration\r\n      });\r\n    } catch (error) {\r\n      res.status(500).json({\r\n        success: false,\r\n        message: 'OCR queue test failed',\r\n        error: error.message,\r\n        duration: Date.now() - startTime\r\n      });\r\n    }\r\n  }\r\n\r\n  // Test entity extraction\r\n  async testEntityExtraction(req, res) {\r\n    const startTime = Date.now();\r\n\r\n    try {\r\n      const connection = await mysql.createConnection(this.dbConfigs.ocr);\r\n      \r\n      const [entitiesJobs] = await connection.execute(`\r\n        SELECT \r\n          id, \r\n          extracted_entities, \r\n          entity_confidence,\r\n          status,\r\n          created_at\r\n        FROM ocr_jobs \r\n        WHERE extracted_entities IS NOT NULL \r\n        AND extracted_entities != ''\r\n        ORDER BY created_at DESC\r\n        LIMIT 5\r\n      `);\r\n\r\n      await connection.end();\r\n\r\n      const duration = Date.now() - startTime;\r\n      const hasEntities = entitiesJobs.length > 0;\r\n\r\n      res.json({\r\n        success: hasEntities,\r\n        message: hasEntities ? \r\n          `Entity extraction test passed - ${entitiesJobs.length} jobs with extracted entities found` :\r\n          'Entity extraction test failed - no jobs with extracted entities found',\r\n        details: {\r\n          jobs_with_entities: entitiesJobs.length,\r\n          sample_jobs: entitiesJobs.map(job => ({\r\n            id: job.id,\r\n            entity_confidence: job.entity_confidence,\r\n            status: job.status,\r\n            created_at: job.created_at,\r\n            has_entities: !!job.extracted_entities\r\n          }))\r\n        },\r\n        duration\r\n      });\r\n    } catch (error) {\r\n      res.status(500).json({\r\n        success: false,\r\n        message: 'Entity extraction test failed',\r\n        error: error.message,\r\n        duration: Date.now() - startTime\r\n      });\r\n    }\r\n  }\r\n\r\n  // Test cross-database connectivity\r\n  async testCrossDatabase(req, res) {\r\n    const startTime = Date.now();\r\n\r\n    try {\r\n      // Test connection between all three databases\r\n      const orthodoxConnection = await mysql.createConnection(this.dbConfigs.orthodoxmetrics);\r\n      const ocrConnection = await mysql.createConnection(this.dbConfigs.ocr);\r\n      const recordsConnection = await mysql.createConnection(this.dbConfigs.records);\r\n\r\n      // Test a cross-database query scenario\r\n      const [churches] = await orthodoxConnection.execute('SELECT id, name FROM churches LIMIT 1');\r\n      \r\n      if (churches.length > 0) {\r\n        const churchId = churches[0].id;\r\n        const [ocrJobs] = await ocrConnection.execute('SELECT COUNT(*) as count FROM ocr_jobs WHERE church_id = ?', [churchId]);\r\n        \r\n        // Check if records database has corresponding structure\r\n        const [recordTables] = await recordsConnection.execute(\"SHOW TABLES LIKE '%_records'\");\r\n        \r\n        await orthodoxConnection.end();\r\n        await ocrConnection.end();\r\n        await recordsConnection.end();\r\n\r\n        const duration = Date.now() - startTime;\r\n\r\n        res.json({\r\n          success: true,\r\n          message: 'Cross-database connectivity test passed',\r\n          details: {\r\n            test_church: churches[0],\r\n            ocr_jobs_for_church: ocrJobs[0].count,\r\n            record_tables_available: recordTables.length,\r\n            cross_query_successful: true\r\n          },\r\n          duration\r\n        });\r\n      } else {\r\n        throw new Error('No churches found to test cross-database connectivity');\r\n      }\r\n    } catch (error) {\r\n      res.status(500).json({\r\n        success: false,\r\n        message: 'Cross-database connectivity test failed',\r\n        error: error.message,\r\n        duration: Date.now() - startTime\r\n      });\r\n    }\r\n  }\r\n\r\n  // Test translation service\r\n  async testTranslation(req, res) {\r\n    const startTime = Date.now();\r\n\r\n    try {\r\n      const connection = await mysql.createConnection(this.dbConfigs.ocr);\r\n      \r\n      const [translationJobs] = await connection.execute(`\r\n        SELECT \r\n          id,\r\n          ocr_result_translation,\r\n          translation_confidence,\r\n          detected_language,\r\n          status\r\n        FROM ocr_jobs \r\n        WHERE ocr_result_translation IS NOT NULL \r\n        AND ocr_result_translation != ''\r\n        ORDER BY created_at DESC\r\n        LIMIT 5\r\n      `);\r\n\r\n      await connection.end();\r\n\r\n      const duration = Date.now() - startTime;\r\n      const hasTranslations = translationJobs.length > 0;\r\n\r\n      res.json({\r\n        success: hasTranslations,\r\n        message: hasTranslations ? \r\n          `Translation service test passed - ${translationJobs.length} jobs with translations found` :\r\n          'Translation service test failed - no jobs with translations found',\r\n        details: {\r\n          jobs_with_translations: translationJobs.length,\r\n          sample_jobs: translationJobs.map(job => ({\r\n            id: job.id,\r\n            translation_confidence: job.translation_confidence,\r\n            detected_language: job.detected_language,\r\n            status: job.status,\r\n            has_translation: !!job.ocr_result_translation\r\n          }))\r\n        },\r\n        duration\r\n      });\r\n    } catch (error) {\r\n      res.status(500).json({\r\n        success: false,\r\n        message: 'Translation service test failed',\r\n        error: error.message,\r\n        duration: Date.now() - startTime\r\n      });\r\n    }\r\n  }\r\n\r\n  // Retry failed jobs\r\n  async retryFailedJobs(req, res) {\r\n    const startTime = Date.now();\r\n\r\n    try {\r\n      const connection = await mysql.createConnection(this.dbConfigs.ocr);\r\n      \r\n      // First, get count of failed jobs\r\n      const [failedCount] = await connection.execute(`\r\n        SELECT COUNT(*) as count FROM ocr_jobs WHERE status = 'failed'\r\n      `);\r\n\r\n      // Reset failed jobs to pending\r\n      const [result] = await connection.execute(`\r\n        UPDATE ocr_jobs \r\n        SET status = 'pending', \r\n            retry_count = retry_count + 1,\r\n            error_message = NULL,\r\n            updated_at = NOW()\r\n        WHERE status = 'failed'\r\n      `);\r\n\r\n      await connection.end();\r\n\r\n      const duration = Date.now() - startTime;\r\n\r\n      res.json({\r\n        success: true,\r\n        message: `Successfully retried ${result.affectedRows} failed jobs`,\r\n        details: {\r\n          failed_jobs_found: failedCount[0].count,\r\n          jobs_retried: result.affectedRows,\r\n          reset_to_pending: true\r\n        },\r\n        duration\r\n      });\r\n    } catch (error) {\r\n      res.status(500).json({\r\n        success: false,\r\n        message: 'Failed to retry jobs',\r\n        error: error.message,\r\n        duration: Date.now() - startTime\r\n      });\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = OcrAdminTestController;\r\n"
    },
    "complexity": {
      "totalLines": 485,
      "codeLines": 398,
      "commentLines": 26,
      "commentRatio": 0.06132075471698113,
      "averageLineLength": 34.625
    },
    "lastAnalyzed": "2025-07-28T07:19:59.544Z"
  },
  "contentHash": "c4cc69b487c5af5bb29b1607ee51869dffde59ffab6c4e5f4fa88628e537f49f",
  "discoveredAt": "2025-07-28T07:19:59.544Z"
}