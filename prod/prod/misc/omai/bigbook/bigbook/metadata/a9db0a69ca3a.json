{
  "id": "a9db0a69ca3a",
  "originalPath": "/var/www/orthodox-church-mgmt/orthodoxmetrics/prod/server/routes/admin/churches.js",
  "relativePath": "server/routes/admin/churches.js",
  "name": "churches.js",
  "extension": ".js",
  "size": 33815,
  "modified": "2025-07-22T22:03:12.998Z",
  "created": "2025-07-11T02:55:45.471Z",
  "classification": {
    "type": "Server Scripts",
    "category": "Backend > Server",
    "confidence": 7
  },
  "metadata": {
    "fileStats": {
      "lines": 1000,
      "characters": 33783,
      "words": 3243
    },
    "classification": {
      "type": "Server Scripts",
      "category": "Backend > Server",
      "confidence": 7
    },
    "dependencies": [
      {
        "type": "npm_package",
        "name": "express",
        "line": 2
      },
      {
        "type": "npm_package",
        "name": "multer",
        "line": 4
      },
      {
        "type": "npm_package",
        "name": "path",
        "line": 5
      },
      {
        "type": "npm_package",
        "name": "fs",
        "line": 6
      }
    ],
    "security": {
      "findings": [
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 153,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 192,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 220,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 282,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 473,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 507,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 543,
          "redacted": true
        }
      ],
      "hasSecurityIssues": true,
      "redactedContent": "// routes/admin/churches.js\r\nconst express = require('express');\r\nconst router = express.Router();\r\nconst multer = require('multer');\r\nconst path = require('path');\r\nconst fs = require('fs').promises;\r\nconst { promisePool } = require('../../config/db');\r\nconst { getChurchDbConnection } = require('../../utils/dbSwitcher');\r\nconst churchSetupService = require('../../services/churchSetupService'); // Add template integration\r\n\r\n// Configure multer for logo uploads\r\nconst storage = multer.diskStorage({\r\n  destination: async (req, file, cb) => {\r\n    const uploadDir = path.join(__dirname, '../../uploads/church-logos');\r\n    try {\r\n      await fs.mkdir(uploadDir, { recursive: true });\r\n      cb(null, uploadDir);\r\n    } catch (error) {\r\n      cb(error);\r\n    }\r\n  },\r\n  filename: (req, file, cb) => {\r\n    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);\r\n    cb(null, `church-logo-${uniqueSuffix}${path.extname(file.originalname)}`);\r\n  }\r\n});\r\n\r\nconst upload = multer({\r\n  storage: storage,\r\n  limits: {\r\n    fileSize: 5 * 1024 * 1024, // 5MB limit\r\n  },\r\n  fileFilter: (req, file, cb) => {\r\n    if (file.mimetype.startsWith('image/')) {\r\n      cb(null, true);\r\n    } else {\r\n      cb(new Error('Only image files are allowed'));\r\n    }\r\n  }\r\n});\r\n\r\n/**\r\n * Create a new church instance with optional template setup\r\n * POST /api/admin/churches\r\n */\r\nrouter.post('/', upload.single('logo'), async (req, res) => {\r\n  try {\r\n    const {\r\n      name,\r\n      address,\r\n      city,\r\n      region,\r\n      country,\r\n      phone,\r\n      website,\r\n      preferred_language,\r\n      timezone,\r\n      calendar_type,\r\n      admin_full_name,\r\n      admin_email,\r\n      admin_password,\r\n      admin_title,\r\n      description,\r\n      established_year,\r\n      // New template setup options\r\n      setup_templates = true,\r\n      auto_setup_standard = false,\r\n      generate_components = false,\r\n      record_types = ['baptism', 'marriage', 'funeral'],\r\n      template_style = 'orthodox_traditional'\r\n    } = req.body;\r\n\r\n    // Validate required fields\r\n    if (!name || !address || !city || !country || !admin_full_name || !admin_email || !admin_password) {\r\n      return res.status(400).json({\r\n        error: 'Missing required fields',\r\n        required: ['name', 'address', 'city', 'country', 'admin_full_name', 'admin_email', 'admin_password']\r\n      });\r\n    }\r\n\r\n    // Duplicate name check (only among active churches)\r\n    const [existingChurches] = await promisePool.query(\r\n      'SELECT id FROM orthodoxmetrics_db.churches WHERE name = ? AND is_active = 1',\r\n      [name]\r\n    );\r\n    if (existingChurches.length > 0) {\r\n      return res.status(400).json({\r\n        error: 'Church name already exists (active church)'\r\n      });\r\n    }\r\n    // Duplicate email check (only among active churches)\r\n    const [existingEmails] = await promisePool.query(\r\n      'SELECT id FROM orthodoxmetrics_db.churches WHERE admin_email = ? AND is_active = 1',\r\n      [admin_email]\r\n    );\r\n    if (existingEmails.length > 0) {\r\n      return res.status(400).json({\r\n        error: 'Church admin email already exists (active church)'\r\n      });\r\n    }\r\n\r\n    // Handle logo file\r\n    let logoPath = null;\r\n    if (req.file) {\r\n      logoPath = `/uploads/church-logos/${req.file.filename}`;\r\n    }\r\n\r\n    // Prepare church data\r\n    const churchData = {\r\n      name, address, city, region, country, phone, website,\r\n      preferred_language, timezone, calendar_type,\r\n      admin_full_name, admin_email, admin_password, admin_title,\r\n      description, established_year, logoPath\r\n    };\r\n\r\n    // Prepare template options\r\n    const templateOptions = {\r\n      setupTemplates: setup_templates,\r\n      autoSetupStandard: auto_setup_standard,\r\n      generateComponents: generate_components,\r\n      recordTypes: record_types,\r\n      templateStyle: template_style,\r\n      includeGlobalTemplates: true,\r\n      createCustomTemplates: false\r\n    };\r\n\r\n    // Use enhanced church setup service\r\n    const setupResult = await churchSetupService.setupNewChurch(churchData, templateOptions);\r\n\r\n    res.status(201).json({\r\n      success: true,\r\n      message: 'Church created successfully',\r\n      church: setupResult.church,\r\n      templates: setupResult.templates,\r\n      next_steps: setupResult.next_steps,\r\n      setup_complete: setupResult.church.setup_status.setup_step === 'complete'\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error creating church:', error);\r\n    \r\n    // Clean up uploaded file if error occurs\r\n    if (req.file) {\r\n      try {\r\n        await fs.unlink(req.file.path);\r\n      } catch (unlinkError) {\r\n        console.error('Error deleting uploaded file:', unlinkError);\r\n      }\r\n    }\r\n    \r\n    res.status(500).json({\r\n      error: 'Failed to create church',\r\n      details: process.env.[REDACTED] === 'development' ? error.message : undefined\r\n    });\r\n  }\r\n});\r\n\r\n/**\r\n * Complete template setup for a church (for churches that skipped initial setup)\r\n * POST /api/admin/churches/:id/complete-template-setup\r\n */\r\nrouter.post('/:id/complete-template-setup', async (req, res) => {\r\n  try {\r\n    const churchId = parseInt(req.params.id);\r\n    const {\r\n      auto_setup_standard = true,\r\n      generate_components = true,\r\n      record_types = ['baptism', 'marriage', 'funeral'],\r\n      template_style = 'orthodox_traditional'\r\n    } = req.body;\r\n\r\n    const templateOptions = {\r\n      autoSetupStandard: auto_setup_standard,\r\n      generateComponents: generate_components,\r\n      recordTypes: record_types,\r\n      templateStyle: template_style,\r\n      includeGlobalTemplates: true\r\n    };\r\n\r\n    const result = await churchSetupService.completeTemplateSetup(churchId, templateOptions);\r\n\r\n    res.json({\r\n      success: true,\r\n      message: result.message,\r\n      templates: result.templates\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error completing template setup:', error);\r\n    res.status(500).json({\r\n      error: 'Failed to complete template setup',\r\n      details: process.env.[REDACTED] === 'development' ? error.message : undefined\r\n    });\r\n  }\r\n});\r\n\r\n/**\r\n * Get church setup status\r\n * GET /api/admin/churches/:id/setup-status\r\n */\r\nrouter.get('/:id/setup-status', async (req, res) => {\r\n  try {\r\n    const churchId = parseInt(req.params.id);\r\n    const setupStatus = await churchSetupService.getChurchSetupStatus(churchId);\r\n    \r\n    if (!setupStatus) {\r\n      return res.status(404).json({ error: 'Church not found' });\r\n    }\r\n\r\n    res.json({\r\n      success: true,\r\n      church: setupStatus,\r\n      next_steps: churchSetupService.getNextSteps(setupStatus.setup_status || {})\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error getting church setup status:', error);\r\n    res.status(500).json({\r\n      error: 'Failed to get setup status',\r\n      details: process.env.[REDACTED] === 'development' ? error.message : undefined\r\n    });\r\n  }\r\n});\r\n\r\n/**\r\n * Get all churches (for admin panel)\r\n * GET /api/churches\r\n */\r\nrouter.get('/', async (req, res) => {\r\n  try {\r\n    const [churches] = await promisePool.execute(`\r\n      SELECT \r\n        id, name, email, phone, address, city, state_province, postal_code, country, \r\n        website, preferred_language, timezone, currency, tax_id, \r\n        description_multilang, settings, is_active, database_name, created_at, updated_at\r\n      FROM orthodoxmetrics_db.churches \r\n      ORDER BY created_at DESC\r\n    `);\r\n\r\n    // Get user count for each church\r\n    for (let church of churches) {\r\n      try {\r\n        // Skip if church doesn't have a database_name configured\r\n        if (!church.database_name) {\r\n          console.warn(`Church ${church.id} (${church.name}) has no database_name configured`);\r\n          church.user_count = 0;\r\n          church.record_counts = { baptisms: 0, marriages: 0, funerals: 0 };\r\n          continue;\r\n        }\r\n\r\n        const churchDb = await getChurchDbConnection(church.database_name);\r\n        \r\n        // Test if connection is valid and database exists\r\n        await churchDb.execute('SELECT 1');\r\n        \r\n        const [userCount] = await churchDb.execute('SELECT COUNT(*) as count FROM users');\r\n        church.user_count = userCount[0].count;\r\n        \r\n        const [recordCounts] = await churchDb.execute(`\r\n          SELECT \r\n            (SELECT COUNT(*) FROM baptism_records) as baptisms,\r\n            (SELECT COUNT(*) FROM marriage_records) as marriages,\r\n            (SELECT COUNT(*) FROM funeral_records) as funerals\r\n        `);\r\n        church.record_counts = recordCounts[0];\r\n      } catch (dbError) {\r\n        console.error(`Error getting stats for church ${church.id} (${church.name}):`, dbError.message);\r\n        church.user_count = 0;\r\n        church.record_counts = { baptisms: 0, marriages: 0, funerals: 0 };\r\n      }\r\n    }\r\n\r\n    res.json({\r\n      success: true,\r\n      churches\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error fetching churches:', error);\r\n    res.status(500).json({\r\n      error: 'Failed to fetch churches',\r\n      details: process.env.[REDACTED] === 'development' ? error.message : undefined\r\n    });\r\n  }\r\n});\r\n\r\n/**\r\n * Get church details by ID (for admin panel)\r\n * GET /api/admin/churches/:id\r\n */\r\nrouter.get('/:id', async (req, res) => {\r\n  try {\r\n    const churchId = parseInt(req.params.id);\r\n    const [rows] = await promisePool.query(\r\n      `SELECT * FROM orthodoxmetrics_db.churches WHERE id = ?`, [churchId]\r\n    );\r\n    if (rows.length === 0) {\r\n      return res.status(404).json({ success: false, message: 'Church not found' });\r\n    }\r\n    res.json({ success: true, church: rows[0] });\r\n  } catch (error) {\r\n    console.error('Error fetching church:', error);\r\n    res.status(500).json({ success: false, message: 'Failed to fetch church', error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * Update a church\r\n * PUT /api/admin/churches/:id\r\n */\r\nrouter.put('/:id', upload.single('logo'), async (req, res) => {\r\n  try {\r\n    const currentChurchId = parseInt(req.params.id);\r\n    const updateData = { ...req.body };\r\n    \r\n    // Handle logo upload if provided\r\n    if (req.file) {\r\n      updateData.logo_path = `/uploads/orthodox-banners/${req.file.filename}`;\r\n    }\r\n\r\n    // Remove undefined fields\r\n    Object.keys(updateData).forEach(key => {\r\n      if (updateData[key] === undefined || updateData[key] === '') {\r\n        delete updateData[key];\r\n      }\r\n    });\r\n\r\n    // Special handling for church_id updates (changing primary key)\r\n    let newChurchId = currentChurchId;\r\n    let isChurchIdUpdate = false;\r\n    \r\n    if (updateData.church_id && updateData.church_id !== currentChurchId) {\r\n      newChurchId = parseInt(updateData.church_id);\r\n      isChurchIdUpdate = true;\r\n      \r\n      console.log(`🔄 Church ID update requested: ${currentChurchId} → ${newChurchId}`);\r\n      \r\n      // Check if the new church_id is already taken\r\n      const [existingChurch] = await promisePool.execute(\r\n        'SELECT id FROM orthodoxmetrics_db.churches WHERE id = ?',\r\n        [newChurchId]\r\n      );\r\n      \r\n      if (existingChurch.length > 0) {\r\n        return res.status(409).json({\r\n          error: 'Church ID already exists',\r\n          details: `Church ID ${newChurchId} is already in use by another church.`\r\n        });\r\n      }\r\n      \r\n      // Remove church_id from regular update data - we'll handle this separately\r\n      delete updateData.church_id;\r\n    }\r\n\r\n    if (isChurchIdUpdate) {\r\n      // Handle church ID change using a safe method\r\n      // First get all the current church data\r\n      const [currentChurch] = await promisePool.execute(\r\n        'SELECT * FROM orthodoxmetrics_db.churches WHERE id = ?',\r\n        [currentChurchId]\r\n      );\r\n      \r\n      if (currentChurch.length === 0) {\r\n        return res.status(404).json({\r\n          error: 'Church not found'\r\n        });\r\n      }\r\n      \r\n      const churchData = currentChurch[0];\r\n      \r\n      // Merge update data with existing data\r\n      const mergedData = { ...churchData, ...updateData };\r\n      \r\n      // Create insert query for new church with new ID\r\n      const insertFields = Object.keys(mergedData).filter(key => key !== 'id');\r\n      const insertValues = insertFields.map(key => mergedData[key]);\r\n      insertValues.unshift(newChurchId); // Add new church ID at beginning\r\n      \r\n      const insertQuery = `\r\n        INSERT INTO orthodoxmetrics_db.churches \r\n        (id, ${insertFields.join(', ')}, updated_at) \r\n        VALUES (?, ${insertFields.map(() => '?').join(', ')}, CURRENT_TIMESTAMP)\r\n      `;\r\n      \r\n      console.log('Creating new church record with ID:', newChurchId);\r\n      \r\n      // Insert new church record\r\n      await promisePool.execute(insertQuery, insertValues);\r\n      \r\n      // Delete old church record\r\n      await promisePool.execute(\r\n        'DELETE FROM orthodoxmetrics_db.churches WHERE id = ?',\r\n        [currentChurchId]\r\n      );\r\n      \r\n      console.log(`🎉 Church ID successfully changed from ${currentChurchId} to ${newChurchId}`);\r\n      \r\n      // Fetch the newly created church\r\n      const [updated] = await promisePool.execute(\r\n        'SELECT * FROM orthodoxmetrics_db.churches WHERE id = ?',\r\n        [newChurchId]\r\n      );\r\n      \r\n      return res.json({\r\n        success: true,\r\n        church: updated[0],\r\n        message: `Church ID successfully changed from ${currentChurchId} to ${newChurchId}`\r\n      });\r\n      \r\n    } else {\r\n      // Regular update (no church ID change)\r\n      const fieldKeys = Object.keys(updateData);\r\n      \r\n      if (fieldKeys.length === 0) {\r\n        return res.status(400).json({\r\n          error: 'No valid fields to update'\r\n        });\r\n      }\r\n      \r\n      const setClause = fieldKeys.map(key => `${key} = ?`).join(', ');\r\n      const values = fieldKeys.map(key => updateData[key]);\r\n      values.push(currentChurchId);\r\n\r\n      // Debug logging\r\n      console.log('--- Church Update Debug ---');\r\n      console.log('Current Church ID:', currentChurchId);\r\n      console.log('Request body:', JSON.stringify(req.body, null, 2));\r\n      console.log('Update data:', JSON.stringify(updateData, null, 2));\r\n      console.log('Set clause:', setClause);\r\n      console.log('Values:', values);\r\n      // End debug logging\r\n\r\n      const [result] = await promisePool.execute(\r\n        `UPDATE orthodoxmetrics_db.churches SET ${setClause}, updated_at = CURRENT_TIMESTAMP WHERE id = ?`,\r\n        values\r\n      );\r\n      console.log('Update result:', result);\r\n\r\n      if (result.affectedRows === 0) {\r\n        return res.status(404).json({\r\n          error: 'Church not found'\r\n        });\r\n      }\r\n\r\n      // Fetch updated church\r\n      const [updated] = await promisePool.execute(\r\n        'SELECT * FROM orthodoxmetrics_db.churches WHERE id = ?',\r\n        [currentChurchId]\r\n      );\r\n\r\n      console.log('✅ Church updated successfully');\r\n      \r\n      res.json({\r\n        success: true,\r\n        church: updated[0],\r\n        message: 'Church updated successfully'\r\n      });\r\n    }\r\n\r\n  } catch (error) {\r\n    console.error('Error updating church:', error);\r\n    \r\n    // Provide more specific error messages for common issues\r\n    let errorMessage = 'Failed to update church';\r\n    if (error.code === 'ER_DUP_ENTRY') {\r\n      errorMessage = 'Church ID already exists or duplicate data detected';\r\n    } else if (error.code === 'ER_NO_REFERENCED_ROW_2') {\r\n      errorMessage = 'Invalid reference in update data';\r\n    }\r\n    \r\n    res.status(500).json({\r\n      error: errorMessage,\r\n      details: process.env.[REDACTED] === 'development' ? error.message : undefined\r\n    });\r\n  }\r\n});\r\n\r\n/**\r\n * Delete a church\r\n * DELETE /api/admin/churches/:id\r\n */\r\nrouter.delete('/:id', async (req, res) => {\r\n  try {\r\n    const churchId = parseInt(req.params.id);\r\n    \r\n    // Soft delete - update is_active instead of actually deleting\r\n    const [result] = await promisePool.execute(\r\n      'UPDATE orthodoxmetrics_db.churches SET is_active = 0, updated_at = CURRENT_TIMESTAMP WHERE id = ?',\r\n      [churchId]\r\n    );\r\n\r\n    if (result.affectedRows === 0) {\r\n      return res.status(404).json({\r\n        error: 'Church not found'\r\n      });\r\n    }\r\n\r\n    res.json({\r\n      success: true,\r\n      message: 'Church deleted successfully'\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error deleting church:', error);\r\n    res.status(500).json({\r\n      error: 'Failed to delete church',\r\n      details: process.env.[REDACTED] === 'development' ? error.message : undefined\r\n    });\r\n  }\r\n});\r\n\r\n/**\r\n * Update church status\r\n * PATCH /api/admin/churches/:id/status\r\n */\r\nrouter.patch('/:id/status', async (req, res) => {\r\n  try {\r\n    const churchId = parseInt(req.params.id);\r\n    const { active } = req.body;\r\n    \r\n    const status = active ? 'active' : 'inactive';\r\n    \r\n    const [result] = await promisePool.execute(\r\n      'UPDATE orthodoxmetrics_db.churches SET is_active = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?',\r\n      [active ? 1 : 0, churchId]\r\n    );\r\n\r\n    if (result.affectedRows === 0) {\r\n      return res.status(404).json({\r\n        error: 'Church not found'\r\n      });\r\n    }\r\n\r\n    res.json({\r\n      success: true,\r\n      message: `Church ${active ? 'activated' : 'deactivated'} successfully`\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error updating church status:', error);\r\n    res.status(500).json({\r\n      error: 'Failed to update church status',\r\n      details: process.env.[REDACTED] === 'development' ? error.message : undefined\r\n    });\r\n  }\r\n});\r\n\r\n/**\r\n * Remove all users from a church before deletion\r\n */\r\nrouter.post('/:id/remove-all-users', async (req, res) => {\r\n  try {\r\n    const churchId = parseInt(req.params.id);\r\n    // Set church_id to NULL for all users assigned to this church\r\n    await promisePool.query('UPDATE users SET church_id = NULL WHERE church_id = ?', [churchId]);\r\n    res.json({ success: true, message: 'All users removed from church.' });\r\n  } catch (error) {\r\n    res.status(500).json({ success: false, message: 'Failed to remove users from church.', error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * Create database schema for new church\r\n */\r\nasync function createChurchDatabaseSchema(churchDb) {\r\n  const tables = [\r\n    // NOTE: Users are stored in orthodoxmetrics_db, not in individual church databases\r\n    // Church databases are for records only. User management is handled centrally.\r\n    // Use the church_users junction table in orthodoxmetrics_db to assign users to churches.\r\n\r\n    // Church configuration\r\n    `CREATE TABLE IF NOT EXISTS church_config (\r\n      id INT PRIMARY KEY AUTO_INCREMENT,\r\n      church_id INT NOT NULL,\r\n      preferred_language VARCHAR(5) DEFAULT 'en',\r\n      timezone VARCHAR(100) DEFAULT 'America/New_York',\r\n      calendar_type ENUM('gregorian', 'julian', 'both') DEFAULT 'gregorian',\r\n      logo_path VARCHAR(500),\r\n      description TEXT,\r\n      established_year INT,\r\n      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\r\n      updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP\r\n    )`,\r\n\r\n    // Baptism records\r\n    `CREATE TABLE IF NOT EXISTS baptism_records (\r\n      id INT PRIMARY KEY AUTO_INCREMENT,\r\n      first_name VARCHAR(255) NOT NULL,\r\n      middle_name VARCHAR(255),\r\n      last_name VARCHAR(255) NOT NULL,\r\n      birth_date DATE,\r\n      baptism_date DATE NOT NULL,\r\n      father_name VARCHAR(255),\r\n      mother_name VARCHAR(255),\r\n      godfather_name VARCHAR(255),\r\n      godmother_name VARCHAR(255),\r\n      priest_name VARCHAR(255),\r\n      church_name VARCHAR(255),\r\n      notes TEXT,\r\n      created_by INT,\r\n      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\r\n      updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP\r\n    )`,\r\n\r\n    // Marriage records\r\n    `CREATE TABLE IF NOT EXISTS marriage_records (\r\n      id INT PRIMARY KEY AUTO_INCREMENT,\r\n      groom_first_name VARCHAR(255) NOT NULL,\r\n      groom_last_name VARCHAR(255) NOT NULL,\r\n      groom_birth_date DATE,\r\n      bride_first_name VARCHAR(255) NOT NULL,\r\n      bride_last_name VARCHAR(255) NOT NULL,\r\n      bride_birth_date DATE,\r\n      marriage_date DATE NOT NULL,\r\n      priest_name VARCHAR(255),\r\n      church_name VARCHAR(255),\r\n      best_man_name VARCHAR(255),\r\n      maid_of_honor_name VARCHAR(255),\r\n      witness1_name VARCHAR(255),\r\n      witness2_name VARCHAR(255),\r\n      notes TEXT,\r\n      created_by INT,\r\n      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\r\n      updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP\r\n    )`,\r\n\r\n    // Funeral records\r\n    `CREATE TABLE IF NOT EXISTS funeral_records (\r\n      id INT PRIMARY KEY AUTO_INCREMENT,\r\n      first_name VARCHAR(255) NOT NULL,\r\n      last_name VARCHAR(255) NOT NULL,\r\n      birth_date DATE,\r\n      death_date DATE NOT NULL,\r\n      funeral_date DATE,\r\n      burial_date DATE,\r\n      cemetery_name VARCHAR(255),\r\n      priest_name VARCHAR(255),\r\n      church_name VARCHAR(255),\r\n      cause_of_death VARCHAR(500),\r\n      notes TEXT,\r\n      created_by INT,\r\n      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\r\n      updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP\r\n    )`,\r\n\r\n    // OCR jobs table\r\n    `CREATE TABLE IF NOT EXISTS ocr_jobs (\r\n      id INT PRIMARY KEY AUTO_INCREMENT,\r\n      church_id INT NOT NULL,\r\n      filename VARCHAR(255) NOT NULL,\r\n      original_filename VARCHAR(255) NOT NULL,\r\n      file_path VARCHAR(500) NOT NULL,\r\n      file_size BIGINT,\r\n      status ENUM('pending', 'processing', 'completed', 'failed') DEFAULT 'pending',\r\n      language VARCHAR(10) DEFAULT 'en',\r\n      record_type ENUM('baptism', 'marriage', 'funeral', 'unknown') DEFAULT 'unknown',\r\n      confidence_score DECIMAL(3,2) DEFAULT 0.00,\r\n      entity_confidence JSON,\r\n      extracted_entities JSON,\r\n      needs_review BOOLEAN DEFAULT FALSE,\r\n      ocr_result LONGTEXT,\r\n      ocr_result_translation LONGTEXT,\r\n      error_message TEXT,\r\n      processing_time INT,\r\n      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\r\n      updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP\r\n    )`,\r\n\r\n    // Entity extraction corrections\r\n    `CREATE TABLE IF NOT EXISTS entity_extraction_corrections (\r\n      id INT PRIMARY KEY AUTO_INCREMENT,\r\n      job_id INT NOT NULL,\r\n      field_name VARCHAR(100) NOT NULL,\r\n      original_value TEXT,\r\n      corrected_value TEXT,\r\n      confidence_before DECIMAL(3,2),\r\n      confidence_after DECIMAL(3,2),\r\n      correction_type ENUM('manual', 'suggested', 'auto') DEFAULT 'manual',\r\n      created_by INT,\r\n      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\r\n      INDEX idx_job_id (job_id)\r\n    )`,\r\n\r\n    // Activity logs\r\n    `CREATE TABLE IF NOT EXISTS activity_logs (\r\n      id INT PRIMARY KEY AUTO_INCREMENT,\r\n      user_id INT,\r\n      action VARCHAR(100) NOT NULL,\r\n      description TEXT,\r\n      ip_address VARCHAR(45),\r\n      user_agent TEXT,\r\n      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\r\n      INDEX idx_user_id (user_id),\r\n      INDEX idx_created_at (created_at)\r\n    )`\r\n  ];\r\n\r\n  // Execute each table creation\r\n  for (const tableSQL of tables) {\r\n    await churchDb.execute(tableSQL);\r\n  }\r\n}\r\n\r\n/**\r\n * Standardized API response helper\r\n */\r\nfunction apiResponse(success, data = null, error = null, meta = null) {\r\n    const response = { success };\r\n    if (data) response.data = data;\r\n    if (error) response.error = error;\r\n    if (meta) response.meta = meta;\r\n    return response;\r\n}\r\n\r\n/**\r\n * Validates church access and returns church info\r\n */\r\nasync function validateChurchAccess(churchId) {\r\n    const [churches] = await promisePool.query(\r\n        'SELECT id, name, database_name FROM churches WHERE id = ? AND is_active = 1',\r\n        [churchId]\r\n    );\r\n    \r\n    if (churches.length === 0) {\r\n        throw new Error('Church not found or inactive');\r\n    }\r\n    \r\n    return churches[0];\r\n}\r\n\r\n// GET /api/admin/churches/:id/debug - Debug church database connection\r\nrouter.get('/:id/debug', async (req, res) => {\r\n    try {\r\n        const churchId = parseInt(req.params.id);\r\n        console.log('🐛 Debug: Getting church info for ID:', churchId);\r\n\r\n        // Check what's actually in the church record\r\n        const [churches] = await promisePool.query(\r\n            'SELECT * FROM orthodoxmetrics_db.churches WHERE id = ?',\r\n            [churchId]\r\n        );\r\n\r\n        if (churches.length === 0) {\r\n            return res.json({\r\n                success: false,\r\n                error: 'Church not found',\r\n                churchId\r\n            });\r\n        }\r\n\r\n        const church = churches[0];\r\n        console.log('🐛 Debug: Church record:', church);\r\n\r\n        res.json({\r\n            success: true,\r\n            debug: {\r\n                churchId,\r\n                church,\r\n                database_name: church.database_name,\r\n                database_name_type: typeof church.database_name,\r\n                database_name_is_null: church.database_name === null,\r\n                database_name_is_undefined: church.database_name === undefined,\r\n                database_name_length: church.database_name?.length || 0\r\n            }\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error('❌ Debug error:', error);\r\n        res.status(500).json({\r\n            success: false,\r\n            error: error.message\r\n        });\r\n    }\r\n});\r\n\r\n// GET /api/admin/churches/:id/database-info - Get comprehensive database information\r\nrouter.get('/:id/database-info', async (req, res) => {\r\n    try {\r\n        const churchId = parseInt(req.params.id);\r\n        console.log('🗄️ Getting database info for church ID:', churchId);\r\n\r\n        // Validate church exists and get database name\r\n        const church = await validateChurchAccess(churchId);\r\n        const { database_name, name: church_name } = church;\r\n\r\n        // Get database size and table count\r\n        const [dbInfo] = await promisePool.execute(`\r\n            SELECT \r\n                TABLE_SCHEMA as name,\r\n                ROUND(SUM(data_length + index_length) / 1024 / 1024, 2) AS size_mb,\r\n                COUNT(TABLE_NAME) as table_count\r\n            FROM information_schema.TABLES \r\n            WHERE TABLE_SCHEMA = ?\r\n            GROUP BY TABLE_SCHEMA\r\n        `, [database_name]);\r\n\r\n        // Get detailed table information\r\n        const [tables] = await promisePool.execute(`\r\n            SELECT \r\n                TABLE_NAME as name, \r\n                TABLE_ROWS as row_count, \r\n                ROUND((data_length + index_length) / 1024 / 1024, 2) AS size_mb,\r\n                CREATE_TIME as created_at,\r\n                UPDATE_TIME as updated_at\r\n            FROM information_schema.TABLES \r\n            WHERE TABLE_SCHEMA = ?\r\n            ORDER BY size_mb DESC, TABLE_NAME\r\n        `, [database_name]);\r\n\r\n        // Calculate totals if main query didn't work\r\n        let totalSize = 0;\r\n        let tableCount = tables.length;\r\n        \r\n        if (tables.length > 0) {\r\n            totalSize = tables.reduce((sum, table) => sum + (parseFloat(table.size_mb) || 0), 0);\r\n        }\r\n\r\n        // Use main query results if available, otherwise use calculated values\r\n        const databaseInfo = {\r\n            name: database_name,\r\n            church_name,\r\n            size_mb: dbInfo[0]?.size_mb || totalSize,\r\n            table_count: dbInfo[0]?.table_count || tableCount,\r\n            tables: tables.map(table => ({\r\n                name: table.name,\r\n                rows: table.row_count || 0,\r\n                size_mb: table.size_mb || 0,\r\n                created_at: table.created_at,\r\n                updated_at: table.updated_at\r\n            }))\r\n        };\r\n\r\n        // Add mock backup info (in production, this would come from backup system)\r\n        const backupInfo = {\r\n            last_backup: new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString(), // Yesterday\r\n            backup_size_mb: Math.round(totalSize * 0.8), // Compressed backup estimate\r\n            status: 'success',\r\n            retention_days: 30\r\n        };\r\n\r\n        res.json({\r\n            success: true,\r\n            database: databaseInfo,\r\n            backup: backupInfo,\r\n            church_id: churchId,\r\n            generated_at: new Date().toISOString()\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error('❌ Error getting database info:', error);\r\n        res.status(error.message.includes('not found') ? 404 : 500).json({\r\n            success: false,\r\n            error: error.message\r\n        });\r\n    }\r\n});\r\n\r\n// POST /api/admin/churches/:id/test-connection - Test database connection and health\r\nrouter.post('/:id/test-connection', async (req, res) => {\r\n    try {\r\n        const churchId = parseInt(req.params.id);\r\n        console.log('🔌 Testing database connection for church ID:', churchId);\r\n\r\n        // Validate church exists and get database info\r\n        const church = await validateChurchAccess(churchId);\r\n        const { database_name, name: church_name } = church;\r\n\r\n        // Test basic connection\r\n        const startTime = Date.now();\r\n        const [connectionTest] = await promisePool.query('SELECT 1 as test');\r\n        const connectionTime = Date.now() - startTime;\r\n\r\n        // Test database existence\r\n        const [dbExists] = await promisePool.query(`\r\n            SELECT SCHEMA_NAME \r\n            FROM information_schema.SCHEMATA \r\n            WHERE SCHEMA_NAME = ?\r\n        `, [database_name]);\r\n\r\n        // Get database stats\r\n        const [dbStats] = await promisePool.query(`\r\n            SELECT \r\n                COUNT(TABLE_NAME) as table_count,\r\n                ROUND(SUM(data_length + index_length) / 1024 / 1024, 2) AS size_mb\r\n            FROM information_schema.TABLES \r\n            WHERE TABLE_SCHEMA = ?\r\n        `, [database_name]);\r\n\r\n        // Test sample queries on common tables\r\n        const sampleQueries = {};\r\n        const commonTables = ['baptism_records', 'marriage_records', 'funeral_records', 'members'];\r\n        \r\n        for (const tableName of commonTables) {\r\n            try {\r\n                const [sampleQuery] = await promisePool.query(`\r\n                    SELECT COUNT(*) as record_count \r\n                    FROM \\`${database_name}\\`.\\`${tableName}\\` \r\n                    LIMIT 1\r\n                `);\r\n                sampleQueries[tableName] = {\r\n                    success: true,\r\n                    record_count: sampleQuery[0].record_count\r\n                };\r\n            } catch (tableError) {\r\n                sampleQueries[tableName] = {\r\n                    success: false,\r\n                    error: `Table '${tableName}' not accessible`\r\n                };\r\n            }\r\n        }\r\n\r\n        const connectionResult = {\r\n            database_name,\r\n            church_name,\r\n            database_exists: dbExists.length > 0,\r\n            connection_time_ms: connectionTime,\r\n            table_count: dbStats[0]?.table_count || 0,\r\n            size_mb: dbStats[0]?.size_mb || 0,\r\n            sample_queries: sampleQueries,\r\n            status: dbExists.length > 0 ? 'healthy' : 'database_missing',\r\n            tested_at: new Date().toISOString()\r\n        };\r\n\r\n        res.json({\r\n            success: true,\r\n            data: {\r\n                connection: connectionResult,\r\n                church_id: churchId\r\n            }\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error('❌ Error testing database connection:', error);\r\n        res.status(error.message.includes('not found') ? 404 : 500).json({\r\n            success: false,\r\n            error: error.message\r\n        });\r\n    }\r\n});\r\n\r\n// GET /api/admin/churches/:id/record-counts - Get record counts for church database\r\nrouter.get('/:id/record-counts', async (req, res) => {\r\n    try {\r\n        const churchId = parseInt(req.params.id);\r\n        console.log('📊 Getting record counts for church ID:', churchId);\r\n\r\n        // Validate church exists and get database name\r\n        const church = await validateChurchAccess(churchId);\r\n        const { database_name } = church;\r\n\r\n        // Get table names for record tables\r\n        const [tables] = await promisePool.query(`\r\n            SELECT TABLE_NAME \r\n            FROM information_schema.TABLES \r\n            WHERE TABLE_SCHEMA = ? \r\n            AND (TABLE_NAME LIKE '%_records'\r\n                 OR TABLE_NAME IN ('clergy', 'members', 'donations', 'calendar_events'))\r\n            ORDER BY TABLE_NAME\r\n        `, [database_name]);\r\n\r\n        const counts = {};\r\n        const errors = {};\r\n        \r\n        // Get count for each table\r\n        for (const table of tables) {\r\n            try {\r\n                const [countResult] = await promisePool.query(`\r\n                    SELECT COUNT(*) as count FROM \\`${database_name}\\`.\\`${table.TABLE_NAME}\\`\r\n                `);\r\n                counts[table.TABLE_NAME] = countResult[0].count;\r\n            } catch (tableError) {\r\n                console.warn(`⚠️ Error counting ${table.TABLE_NAME}:`, tableError.message);\r\n                counts[table.TABLE_NAME] = 0;\r\n                errors[table.TABLE_NAME] = tableError.message;\r\n            }\r\n        }\r\n\r\n        // Calculate total records\r\n        const totalRecords = Object.values(counts).reduce((sum, count) => sum + count, 0);\r\n\r\n        res.json({\r\n            success: true,\r\n            counts: counts,\r\n            total_records: totalRecords,\r\n            church_id: churchId,\r\n            database_name,\r\n            errors: Object.keys(errors).length > 0 ? errors : undefined\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error('❌ Error getting record counts:', error);\r\n        res.status(error.message.includes('not found') ? 404 : 500).json({\r\n            success: false,\r\n            error: error.message\r\n        });\r\n    }\r\n});\r\n\r\nmodule.exports = router;\r\n"
    },
    "complexity": {
      "totalLines": 1000,
      "codeLines": 767,
      "commentLines": 108,
      "commentRatio": 0.12342857142857143,
      "averageLineLength": 37.08571428571429
    },
    "lastAnalyzed": "2025-07-28T07:20:00.363Z"
  },
  "contentHash": "963840805327d49fd596baf52644a6943bcf9d3e1b353694b42e4d954b832427",
  "discoveredAt": "2025-07-28T07:20:00.363Z"
}