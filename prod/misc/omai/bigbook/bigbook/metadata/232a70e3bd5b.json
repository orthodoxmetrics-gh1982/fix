{
  "id": "232a70e3bd5b",
  "originalPath": "/var/www/orthodox-church-mgmt/orthodoxmetrics/prod/front-end/src/ai/vrt/vrtSecurity.ts",
  "relativePath": "front-end/src/ai/vrt/vrtSecurity.ts",
  "name": "vrtSecurity.ts",
  "extension": ".ts",
  "size": 11085,
  "modified": "2025-07-25T05:31:24.975Z",
  "created": "2025-07-25T05:31:20.222Z",
  "classification": {
    "type": "Testing Scripts",
    "category": "DevOps > Test",
    "confidence": 1
  },
  "metadata": {
    "fileStats": {
      "lines": 381,
      "characters": 11085,
      "words": 1139
    },
    "classification": {
      "type": "Testing Scripts",
      "category": "DevOps > Test",
      "confidence": 1
    },
    "dependencies": [],
    "security": {
      "findings": [
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 297,
          "redacted": true
        }
      ],
      "hasSecurityIssues": true,
      "redactedContent": "// VRT Security & Access Control Module\r\n// Centralizes authentication, authorization, and audit logging for all VRT operations\r\n\r\nexport interface VRTUser {\r\n  id: string;\r\n  name: string;\r\n  email: string;\r\n  role: string;\r\n}\r\n\r\nexport interface VRTAuditLog {\r\n  id: string;\r\n  timestamp: string;\r\n  userId: string;\r\n  userName: string;\r\n  action: VRTAction;\r\n  componentId?: string;\r\n  componentName?: string;\r\n  details: Record<string, any>;\r\n  ipAddress?: string;\r\n  userAgent: string;\r\n  success: boolean;\r\n  errorMessage?: string;\r\n}\r\n\r\nexport type VRTAction = \r\n  | 'SNAPSHOT_CAPTURE'\r\n  | 'DIFF_ANALYSIS'\r\n  | 'CONFIDENCE_ADJUSTMENT'\r\n  | 'PLAYWRIGHT_TEST'\r\n  | 'SETTINGS_UPDATE'\r\n  | 'DASHBOARD_ACCESS'\r\n  | 'EXPORT_PNG'\r\n  | 'EXPORT_JSON'\r\n  | 'LEARNING_FEEDBACK'\r\n  | 'VRT_ENABLE'\r\n  | 'VRT_DISABLE';\r\n\r\nexport interface VRTSecurityConfig {\r\n  enabledInProduction: boolean;\r\n  requireSuperAdmin: boolean;\r\n  auditLogging: boolean;\r\n  maxSnapshotRetention: number; // days\r\n  maxAuditLogRetention: number; // days\r\n  allowedOrigins: string[];\r\n  rateLimitPerHour: number;\r\n}\r\n\r\nexport class VRTSecurity {\r\n  private static instance: VRTSecurity;\r\n  private config: VRTSecurityConfig;\r\n  private auditLogs: VRTAuditLog[] = [];\r\n  private actionCounts: Map<string, number> = new Map();\r\n  private lastHourReset: number = Date.now();\r\n\r\n  private constructor() {\r\n    this.config = this.loadConfig();\r\n    this.loadAuditLogs();\r\n    this.cleanupOldLogs();\r\n  }\r\n\r\n  public static getInstance(): VRTSecurity {\r\n    if (!VRTSecurity.instance) {\r\n      VRTSecurity.instance = new VRTSecurity();\r\n    }\r\n    return VRTSecurity.instance;\r\n  }\r\n\r\n  /**\r\n   * Check if VRT operations are allowed for the current user and environment\r\n   */\r\n  public isVRTAllowed(user: VRTUser | null): { allowed: boolean; reason?: string } {\r\n    // Check if user exists\r\n    if (!user) {\r\n      return { allowed: false, reason: 'No authenticated user' };\r\n    }\r\n\r\n    // Check super admin requirement\r\n    if (this.config.requireSuperAdmin && user.role !== 'super_admin') {\r\n      return { allowed: false, reason: 'Super admin access required' };\r\n    }\r\n\r\n    // Check production environment\r\n    if (this.isProduction() && !this.config.enabledInProduction) {\r\n      return { allowed: false, reason: 'VRT disabled in production environment' };\r\n    }\r\n\r\n    // Check rate limiting\r\n    if (!this.checkRateLimit(user.id)) {\r\n      return { allowed: false, reason: 'Rate limit exceeded (max actions per hour)' };\r\n    }\r\n\r\n    // Check origin allowlist\r\n    if (!this.isOriginAllowed()) {\r\n      return { allowed: false, reason: 'Origin not in allowlist' };\r\n    }\r\n\r\n    return { allowed: true };\r\n  }\r\n\r\n  /**\r\n   * Log a VRT action for audit purposes\r\n   */\r\n  public async logAction(\r\n    user: VRTUser,\r\n    action: VRTAction,\r\n    details: Record<string, any> = {},\r\n    componentId?: string,\r\n    componentName?: string,\r\n    success: boolean = true,\r\n    errorMessage?: string\r\n  ): Promise<void> {\r\n    if (!this.config.auditLogging) return;\r\n\r\n    const auditLog: VRTAuditLog = {\r\n      id: this.generateLogId(),\r\n      timestamp: new Date().toISOString(),\r\n      userId: user.id,\r\n      userName: user.name,\r\n      action,\r\n      componentId,\r\n      componentName,\r\n      details: {\r\n        ...details,\r\n        environment: this.isProduction() ? 'production' : 'development',\r\n        sessionId: this.getSessionId()\r\n      },\r\n      ipAddress: await this.getClientIP(),\r\n      userAgent: navigator.userAgent,\r\n      success,\r\n      errorMessage\r\n    };\r\n\r\n    this.auditLogs.push(auditLog);\r\n    this.saveAuditLogs();\r\n\r\n    // Update rate limiting counter\r\n    this.updateActionCount(user.id);\r\n\r\n    // Log to console for immediate feedback\r\n    console.log(`[VRT Audit] ${action} by ${user.name} ${success ? 'SUCCESS' : 'FAILED'}`, auditLog);\r\n\r\n    // Also log to existing admin log system if available\r\n    this.logToAdminSystem(auditLog);\r\n  }\r\n\r\n  /**\r\n   * Get audit logs with optional filtering\r\n   */\r\n  public getAuditLogs(\r\n    userId?: string,\r\n    action?: VRTAction,\r\n    componentId?: string,\r\n    startDate?: Date,\r\n    endDate?: Date\r\n  ): VRTAuditLog[] {\r\n    let logs = [...this.auditLogs];\r\n\r\n    if (userId) {\r\n      logs = logs.filter(log => log.userId === userId);\r\n    }\r\n\r\n    if (action) {\r\n      logs = logs.filter(log => log.action === action);\r\n    }\r\n\r\n    if (componentId) {\r\n      logs = logs.filter(log => log.componentId === componentId);\r\n    }\r\n\r\n    if (startDate) {\r\n      logs = logs.filter(log => new Date(log.timestamp) >= startDate);\r\n    }\r\n\r\n    if (endDate) {\r\n      logs = logs.filter(log => new Date(log.timestamp) <= endDate);\r\n    }\r\n\r\n    return logs.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());\r\n  }\r\n\r\n  /**\r\n   * Clear old audit logs based on retention policy\r\n   */\r\n  public cleanupOldLogs(): void {\r\n    const cutoffDate = new Date();\r\n    cutoffDate.setDate(cutoffDate.getDate() - this.config.maxAuditLogRetention);\r\n\r\n    const originalCount = this.auditLogs.length;\r\n    this.auditLogs = this.auditLogs.filter(log => new Date(log.timestamp) > cutoffDate);\r\n    \r\n    if (this.auditLogs.length < originalCount) {\r\n      console.log(`[VRT Security] Cleaned up ${originalCount - this.auditLogs.length} old audit logs`);\r\n      this.saveAuditLogs();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update VRT security configuration\r\n   */\r\n  public updateConfig(newConfig: Partial<VRTSecurityConfig>, user: VRTUser): void {\r\n    const oldConfig = { ...this.config };\r\n    this.config = { ...this.config, ...newConfig };\r\n    this.saveConfig();\r\n\r\n    // Log the configuration change\r\n    this.logAction(user, 'SETTINGS_UPDATE', {\r\n      oldConfig,\r\n      newConfig,\r\n      configChanged: Object.keys(newConfig)\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get current security configuration (sanitized for client)\r\n   */\r\n  public getConfig(): Omit<VRTSecurityConfig, 'allowedOrigins'> {\r\n    const { allowedOrigins, ...publicConfig } = this.config;\r\n    return publicConfig;\r\n  }\r\n\r\n  // Private helper methods\r\n\r\n  private loadConfig(): VRTSecurityConfig {\r\n    const defaultConfig: VRTSecurityConfig = {\r\n      enabledInProduction: false,\r\n      requireSuperAdmin: true,\r\n      auditLogging: true,\r\n      maxSnapshotRetention: 30,\r\n      maxAuditLogRetention: 90,\r\n      allowedOrigins: ['localhost', '127.0.0.1', '::1'],\r\n      rateLimitPerHour: 100\r\n    };\r\n\r\n    try {\r\n      const stored = localStorage.getItem('vrt_security_config');\r\n      if (stored) {\r\n        return { ...defaultConfig, ...JSON.parse(stored) };\r\n      }\r\n    } catch (error) {\r\n      console.warn('[VRT Security] Failed to load config, using defaults');\r\n    }\r\n\r\n    return defaultConfig;\r\n  }\r\n\r\n  private saveConfig(): void {\r\n    try {\r\n      localStorage.setItem('vrt_security_config', JSON.stringify(this.config));\r\n    } catch (error) {\r\n      console.error('[VRT Security] Failed to save config:', error);\r\n    }\r\n  }\r\n\r\n  private loadAuditLogs(): void {\r\n    try {\r\n      const stored = localStorage.getItem('vrt_audit_logs');\r\n      if (stored) {\r\n        this.auditLogs = JSON.parse(stored);\r\n      }\r\n    } catch (error) {\r\n      console.warn('[VRT Security] Failed to load audit logs');\r\n      this.auditLogs = [];\r\n    }\r\n  }\r\n\r\n  private saveAuditLogs(): void {\r\n    try {\r\n      // Keep only the most recent logs to avoid localStorage bloat\r\n      const recentLogs = this.auditLogs.slice(-1000);\r\n      localStorage.setItem('vrt_audit_logs', JSON.stringify(recentLogs));\r\n    } catch (error) {\r\n      console.error('[VRT Security] Failed to save audit logs:', error);\r\n    }\r\n  }\r\n\r\n  private checkRateLimit(userId: string): boolean {\r\n    const now = Date.now();\r\n    const hourInMs = 60 * 60 * 1000;\r\n\r\n    // Reset counters if an hour has passed\r\n    if (now - this.lastHourReset > hourInMs) {\r\n      this.actionCounts.clear();\r\n      this.lastHourReset = now;\r\n    }\r\n\r\n    const currentCount = this.actionCounts.get(userId) || 0;\r\n    return currentCount < this.config.rateLimitPerHour;\r\n  }\r\n\r\n  private updateActionCount(userId: string): void {\r\n    const currentCount = this.actionCounts.get(userId) || 0;\r\n    this.actionCounts.set(userId, currentCount + 1);\r\n  }\r\n\r\n  private isProduction(): boolean {\r\n    return process.env.[REDACTED] === 'production' || \r\n           window.location.hostname !== 'localhost' && \r\n           !window.location.hostname.includes('127.0.0.1');\r\n  }\r\n\r\n  private isOriginAllowed(): boolean {\r\n    const hostname = window.location.hostname;\r\n    return this.config.allowedOrigins.some(origin => \r\n      hostname === origin || hostname.includes(origin)\r\n    );\r\n  }\r\n\r\n  private async getClientIP(): Promise<string> {\r\n    // In a real application, this would come from the server\r\n    // For demo purposes, we'll use a placeholder\r\n    return 'client.ip.not.available';\r\n  }\r\n\r\n  private getSessionId(): string {\r\n    // Try to get session ID from various sources\r\n    return sessionStorage.getItem('sessionId') || \r\n           localStorage.getItem('sessionId') || \r\n           'session-' + Date.now();\r\n  }\r\n\r\n  private generateLogId(): string {\r\n    return 'vrt-audit-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);\r\n  }\r\n\r\n  private logToAdminSystem(auditLog: VRTAuditLog): void {\r\n    // Integration point for existing admin logging system\r\n    // This would typically send to a backend audit service\r\n    try {\r\n      const adminLogs = JSON.parse(localStorage.getItem('admin_audit_logs') || '[]');\r\n      adminLogs.push({\r\n        ...auditLog,\r\n        system: 'VRT',\r\n        category: 'VISUAL_REGRESSION_TESTING'\r\n      });\r\n      \r\n      // Keep only recent admin logs\r\n      const recentAdminLogs = adminLogs.slice(-500);\r\n      localStorage.setItem('admin_audit_logs', JSON.stringify(recentAdminLogs));\r\n    } catch (error) {\r\n      console.warn('[VRT Security] Failed to log to admin system:', error);\r\n    }\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const vrtSecurity = VRTSecurity.getInstance();\r\n\r\n// Helper function for components to check VRT access\r\nexport function checkVRTAccess(user: any): { allowed: boolean; reason?: string } {\r\n  const vrtUser: VRTUser | null = user ? {\r\n    id: user.id || user.user_id || 'unknown',\r\n    name: user.name || user.username || 'Unknown User',\r\n    email: user.email || 'unknown@email.com',\r\n    role: user.role || 'user'\r\n  } : null;\r\n\r\n  return vrtSecurity.isVRTAllowed(vrtUser);\r\n}\r\n\r\n// Helper function for logging VRT actions\r\nexport async function logVRTAction(\r\n  user: any,\r\n  action: VRTAction,\r\n  details: Record<string, any> = {},\r\n  componentId?: string,\r\n  componentName?: string,\r\n  success: boolean = true,\r\n  errorMessage?: string\r\n): Promise<void> {\r\n  if (!user) return;\r\n\r\n  const vrtUser: VRTUser = {\r\n    id: user.id || user.user_id || 'unknown',\r\n    name: user.name || user.username || 'Unknown User',\r\n    email: user.email || 'unknown@email.com',\r\n    role: user.role || 'user'\r\n  };\r\n\r\n  await vrtSecurity.logAction(user, action, details, componentId, componentName, success, errorMessage);\r\n} "
    },
    "complexity": {
      "totalLines": 381,
      "codeLines": 284,
      "commentLines": 41,
      "commentRatio": 0.12615384615384614,
      "averageLineLength": 32.73538461538462
    },
    "lastAnalyzed": "2025-07-28T07:19:58.669Z"
  },
  "contentHash": "19a66341419c81e62b25f312422ff8c4bc71767180d2f4ff32c72a1496c43a58",
  "discoveredAt": "2025-07-28T07:19:58.669Z"
}