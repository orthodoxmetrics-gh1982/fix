{
  "id": "6f7353f122ed",
  "originalPath": "/var/www/orthodox-church-mgmt/orthodoxmetrics/prod/backend/routes/jit-terminal.js",
  "relativePath": "backend/routes/jit-terminal.js",
  "name": "jit-terminal.js",
  "extension": ".js",
  "size": 10907,
  "modified": "2025-07-25T06:04:11.172Z",
  "created": "2025-07-25T06:04:09.805Z",
  "classification": {
    "type": "Server Scripts",
    "category": "Backend > Server",
    "confidence": 5
  },
  "metadata": {
    "fileStats": {
      "lines": 348,
      "characters": 10907,
      "words": 1123
    },
    "classification": {
      "type": "Server Scripts",
      "category": "Backend > Server",
      "confidence": 5
    },
    "dependencies": [
      {
        "type": "npm_package",
        "name": "express",
        "line": 4
      },
      {
        "type": "npm_package",
        "name": "ws",
        "line": 8
      },
      {
        "type": "npm_package",
        "name": "path",
        "line": 9
      },
      {
        "type": "npm_package",
        "name": "fs",
        "line": 10
      }
    ],
    "security": {
      "findings": [
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 330,
          "redacted": true
        }
      ],
      "hasSecurityIssues": true,
      "redactedContent": "// JIT Terminal API Routes\r\n// Express routes for managing JIT (Just-In-Time) terminal sessions\r\n\r\nconst express = require('express');\r\nconst router = express.Router();\r\nconst { authenticateToken, requireSuperAdmin } = require('../middleware/auth');\r\nconst JITSessionManager = require('../services/jitSessionManager');\r\nconst WebSocket = require('ws');\r\nconst path = require('path');\r\nconst fs = require('fs').promises;\r\n\r\n// Initialize JIT Session Manager\r\nconst jitManager = new JITSessionManager();\r\n\r\n/**\r\n * GET /api/jit/config\r\n * Get JIT Terminal configuration\r\n */\r\nrouter.get('/config', authenticateToken, requireSuperAdmin, async (req, res) => {\r\n  try {\r\n    const config = await jitManager.getConfig();\r\n    res.json(config);\r\n  } catch (error) {\r\n    console.error('[JIT API] Failed to get config:', error);\r\n    res.status(500).json({ message: 'Failed to retrieve configuration' });\r\n  }\r\n});\r\n\r\n/**\r\n * PUT /api/jit/config\r\n * Update JIT Terminal configuration\r\n */\r\nrouter.put('/config', authenticateToken, requireSuperAdmin, async (req, res) => {\r\n  try {\r\n    const config = req.body;\r\n    \r\n    // Validate configuration\r\n    const validation = validateJITConfig(config);\r\n    if (!validation.valid) {\r\n      return res.status(400).json({ \r\n        message: 'Invalid configuration',\r\n        errors: validation.errors \r\n      });\r\n    }\r\n\r\n    await jitManager.updateConfig(config, req.user);\r\n    \r\n    // Log configuration change\r\n    console.log(`[JIT API] Configuration updated by ${req.user.name} (${req.user.id})`);\r\n    \r\n    res.json({ message: 'Configuration updated successfully' });\r\n  } catch (error) {\r\n    console.error('[JIT API] Failed to update config:', error);\r\n    res.status(500).json({ message: 'Failed to update configuration' });\r\n  }\r\n});\r\n\r\n/**\r\n * GET /api/jit/sessions\r\n * Get all JIT Terminal sessions for current user or all (super_admin)\r\n */\r\nrouter.get('/sessions', authenticateToken, requireSuperAdmin, async (req, res) => {\r\n  try {\r\n    const sessions = await jitManager.getSessions(req.user.id, true); // Get all sessions for super_admin\r\n    res.json(sessions);\r\n  } catch (error) {\r\n    console.error('[JIT API] Failed to get sessions:', error);\r\n    res.status(500).json({ message: 'Failed to retrieve sessions' });\r\n  }\r\n});\r\n\r\n/**\r\n * POST /api/jit/start-session\r\n * Create a new JIT Terminal session\r\n */\r\nrouter.post('/start-session', authenticateToken, requireSuperAdmin, async (req, res) => {\r\n  try {\r\n    const { timeoutMinutes, password } = req.body;\r\n    \r\n    // Check if JIT is enabled\r\n    const config = await jitManager.getConfig();\r\n    if (!config.enabled) {\r\n      return res.status(403).json({ \r\n        message: 'JIT Terminal is currently disabled' \r\n      });\r\n    }\r\n\r\n    // Check production environment restrictions\r\n    if (isProduction() && !config.allowInProduction) {\r\n      return res.status(403).json({ \r\n        message: 'JIT Terminal is disabled in production environment' \r\n      });\r\n    }\r\n\r\n    // Check concurrent session limit\r\n    const activeSessions = await jitManager.getActiveSessions(req.user.id);\r\n    if (activeSessions.length >= config.maxConcurrentSessions) {\r\n      return res.status(429).json({ \r\n        message: `Maximum concurrent sessions limit reached (${config.maxConcurrentSessions})` \r\n      });\r\n    }\r\n\r\n    // Re-authentication if required\r\n    if (config.requireReauth) {\r\n      if (!password) {\r\n        return res.status(400).json({ \r\n          message: 'Password required for re-authentication' \r\n        });\r\n      }\r\n      \r\n      // Verify password (implement your authentication logic)\r\n      const isValidPassword = await verifyUserPassword(req.user.id, password);\r\n      if (!isValidPassword) {\r\n        return res.status(401).json({ \r\n          message: 'Invalid password for re-authentication' \r\n        });\r\n      }\r\n    }\r\n\r\n    // Create new session\r\n    const session = await jitManager.createSession(req.user, {\r\n      timeoutMinutes: timeoutMinutes || config.sessionTimeoutMinutes\r\n    });\r\n\r\n    console.log(`[JIT API] Session created: ${session.id} for user ${req.user.name}`);\r\n\r\n    res.status(201).json({\r\n      sessionId: session.id,\r\n      expiryTime: session.expiryTime,\r\n      message: 'JIT Terminal session created successfully'\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('[JIT API] Failed to create session:', error);\r\n    res.status(500).json({ message: 'Failed to create terminal session' });\r\n  }\r\n});\r\n\r\n/**\r\n * POST /api/jit/end-session\r\n * Terminate a JIT Terminal session\r\n */\r\nrouter.post('/end-session', authenticateToken, requireSuperAdmin, async (req, res) => {\r\n  try {\r\n    const { sessionId } = req.body;\r\n    \r\n    if (!sessionId) {\r\n      return res.status(400).json({ message: 'Session ID required' });\r\n    }\r\n\r\n    // Get session to verify ownership or admin access\r\n    const session = await jitManager.getSession(sessionId);\r\n    if (!session) {\r\n      return res.status(404).json({ message: 'Session not found' });\r\n    }\r\n\r\n    // Only allow session owner or super_admin to terminate\r\n    if (session.userId !== req.user.id && req.user.role !== 'super_admin') {\r\n      return res.status(403).json({ message: 'Insufficient permissions to terminate session' });\r\n    }\r\n\r\n    await jitManager.terminateSession(sessionId, req.user);\r\n    \r\n    console.log(`[JIT API] Session terminated: ${sessionId} by ${req.user.name}`);\r\n    \r\n    res.json({ message: 'Session terminated successfully' });\r\n\r\n  } catch (error) {\r\n    console.error('[JIT API] Failed to terminate session:', error);\r\n    res.status(500).json({ message: 'Failed to terminate session' });\r\n  }\r\n});\r\n\r\n/**\r\n * GET /api/jit/session-log/:sessionId\r\n * Download session log file\r\n */\r\nrouter.get('/session-log/:sessionId', authenticateToken, requireSuperAdmin, async (req, res) => {\r\n  try {\r\n    const { sessionId } = req.params;\r\n    \r\n    // Get session to verify access\r\n    const session = await jitManager.getSession(sessionId);\r\n    if (!session) {\r\n      return res.status(404).json({ message: 'Session not found' });\r\n    }\r\n\r\n    // Only allow session owner or super_admin to download logs\r\n    if (session.userId !== req.user.id && req.user.role !== 'super_admin') {\r\n      return res.status(403).json({ message: 'Insufficient permissions to access session log' });\r\n    }\r\n\r\n    const logPath = await jitManager.getSessionLogPath(sessionId);\r\n    \r\n    try {\r\n      await fs.access(logPath);\r\n      \r\n      res.setHeader('Content-Type', 'text/plain');\r\n      res.setHeader('Content-Disposition', `attachment; filename=\"jit-session-${sessionId}.log\"`);\r\n      \r\n      const logContent = await fs.readFile(logPath, 'utf8');\r\n      res.send(logContent);\r\n      \r\n      console.log(`[JIT API] Session log downloaded: ${sessionId} by ${req.user.name}`);\r\n      \r\n    } catch (fileError) {\r\n      res.status(404).json({ message: 'Session log file not found' });\r\n    }\r\n\r\n  } catch (error) {\r\n    console.error('[JIT API] Failed to get session log:', error);\r\n    res.status(500).json({ message: 'Failed to retrieve session log' });\r\n  }\r\n});\r\n\r\n/**\r\n * GET /api/jit/audit-logs\r\n * Get JIT audit logs (super_admin only)\r\n */\r\nrouter.get('/audit-logs', authenticateToken, requireSuperAdmin, async (req, res) => {\r\n  try {\r\n    const { startDate, endDate, userId, action } = req.query;\r\n    \r\n    const filters = {};\r\n    if (startDate) filters.startDate = new Date(startDate);\r\n    if (endDate) filters.endDate = new Date(endDate);\r\n    if (userId) filters.userId = userId;\r\n    if (action) filters.action = action;\r\n\r\n    const auditLogs = await jitManager.getAuditLogs(filters);\r\n    res.json(auditLogs);\r\n\r\n  } catch (error) {\r\n    console.error('[JIT API] Failed to get audit logs:', error);\r\n    res.status(500).json({ message: 'Failed to retrieve audit logs' });\r\n  }\r\n});\r\n\r\n/**\r\n * WebSocket connection handler for JIT Terminal\r\n * This should be called from the main server file to set up WebSocket handling\r\n */\r\nfunction setupJITWebSocket(server) {\r\n  const wss = new WebSocket.Server({ \r\n    server,\r\n    path: '/api/jit/socket'\r\n  });\r\n\r\n  wss.on('connection', async (ws, req) => {\r\n    const url = new URL(req.url, `http://${req.headers.host}`);\r\n    const sessionId = url.searchParams.get('sessionId');\r\n    \r\n    if (!sessionId) {\r\n      ws.close(1008, 'Session ID required');\r\n      return;\r\n    }\r\n\r\n    try {\r\n      // Verify session exists and is active\r\n      const session = await jitManager.getSession(sessionId);\r\n      if (!session || !session.isActive) {\r\n        ws.close(1008, 'Invalid or expired session');\r\n        return;\r\n      }\r\n\r\n      // Attach WebSocket to session\r\n      await jitManager.attachWebSocket(sessionId, ws);\r\n      \r\n      console.log(`[JIT WebSocket] Connected to session: ${sessionId}`);\r\n      \r\n      // Send welcome message\r\n      ws.send(JSON.stringify({\r\n        type: 'session_update',\r\n        session: session\r\n      }));\r\n\r\n    } catch (error) {\r\n      console.error('[JIT WebSocket] Connection error:', error);\r\n      ws.close(1011, 'Internal server error');\r\n    }\r\n  });\r\n\r\n  return wss;\r\n}\r\n\r\n// Helper functions\r\n\r\nfunction validateJITConfig(config) {\r\n  const errors = [];\r\n  \r\n  if (typeof config.enabled !== 'boolean') {\r\n    errors.push('enabled must be a boolean');\r\n  }\r\n  \r\n  if (typeof config.allowInProduction !== 'boolean') {\r\n    errors.push('allowInProduction must be a boolean');\r\n  }\r\n  \r\n  if (!Number.isInteger(config.sessionTimeoutMinutes) || \r\n      config.sessionTimeoutMinutes < 1 || \r\n      config.sessionTimeoutMinutes > 60) {\r\n    errors.push('sessionTimeoutMinutes must be an integer between 1 and 60');\r\n  }\r\n  \r\n  if (!Number.isInteger(config.maxConcurrentSessions) || \r\n      config.maxConcurrentSessions < 1 || \r\n      config.maxConcurrentSessions > 10) {\r\n    errors.push('maxConcurrentSessions must be an integer between 1 and 10');\r\n  }\r\n  \r\n  if (typeof config.requireReauth !== 'boolean') {\r\n    errors.push('requireReauth must be a boolean');\r\n  }\r\n  \r\n  if (typeof config.logCommands !== 'boolean') {\r\n    errors.push('logCommands must be a boolean');\r\n  }\r\n  \r\n  if (typeof config.logDirectory !== 'string' || !config.logDirectory.trim()) {\r\n    errors.push('logDirectory must be a non-empty string');\r\n  }\r\n\r\n  return {\r\n    valid: errors.length === 0,\r\n    errors\r\n  };\r\n}\r\n\r\nfunction isProduction() {\r\n  return process.env.[REDACTED] === 'production';\r\n}\r\n\r\nasync function verifyUserPassword(userId, password) {\r\n  // Implement your password verification logic here\r\n  // This is a placeholder - you should integrate with your existing auth system\r\n  try {\r\n    // Example: bcrypt.compare(password, userHashedPassword)\r\n    return true; // Placeholder - always returns true for demo\r\n  } catch (error) {\r\n    console.error('[JIT API] Password verification error:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\nmodule.exports = { \r\n  router,\r\n  setupJITWebSocket\r\n}; "
    },
    "complexity": {
      "totalLines": 348,
      "codeLines": 231,
      "commentLines": 54,
      "commentRatio": 0.18947368421052632,
      "averageLineLength": 36.48070175438596
    },
    "lastAnalyzed": "2025-07-28T07:19:56.498Z"
  },
  "contentHash": "0d03dfdaa878f860feb75ab4cdc7be1ab701f1a2113e4830999b623d0a429bd1",
  "discoveredAt": "2025-07-28T07:19:56.498Z"
}