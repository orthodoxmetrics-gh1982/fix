{
  "id": "0aafa58ce28d",
  "originalPath": "/var/www/orthodox-church-mgmt/orthodoxmetrics/prod/scripts/api-audit-complete.js",
  "relativePath": "scripts/api-audit-complete.js",
  "name": "api-audit-complete.js",
  "extension": ".js",
  "size": 20249,
  "modified": "2025-07-27T04:25:39.793Z",
  "created": "2025-07-27T04:23:42.429Z",
  "classification": {
    "type": "Server Scripts",
    "category": "Backend > Server",
    "confidence": 6
  },
  "metadata": {
    "fileStats": {
      "lines": 668,
      "characters": 20187,
      "words": 1839
    },
    "classification": {
      "type": "Server Scripts",
      "category": "Backend > Server",
      "confidence": 6
    },
    "dependencies": [
      {
        "type": "npm_package",
        "name": "fs",
        "line": 10
      },
      {
        "type": "npm_package",
        "name": "path",
        "line": 11
      },
      {
        "type": "npm_package",
        "name": "http",
        "line": 12
      },
      {
        "type": "npm_package",
        "name": "https",
        "line": 13
      },
      {
        "type": "npm_package",
        "name": "child_process",
        "line": 14
      },
      {
        "type": "npm_package",
        "name": "util",
        "line": 15
      }
    ],
    "security": {
      "findings": [
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 22,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 23,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 24,
          "redacted": true
        }
      ],
      "hasSecurityIssues": true,
      "redactedContent": "#!/usr/bin/env node\r\n\r\n/**\r\n * Complete API Audit Script for OrthodoxMetrics Backend\r\n * Discovers, tests, and analyzes all API endpoints\r\n * \r\n * Usage: node scripts/api-audit-complete.js [--test-endpoints] [--detailed]\r\n */\r\n\r\nconst fs = require('fs').promises;\r\nconst path = require('path');\r\nconst http = require('http');\r\nconst https = require('https');\r\nconst { exec } = require('child_process');\r\nconst { promisify } = require('util');\r\n\r\nconst execAsync = promisify(exec);\r\n\r\n// Configuration\r\nconst CONFIG = {\r\n  projectRoot: process.cwd(),\r\n  serverPort: process.env.[REDACTED] || 3000,\r\n  serverHost: process.env.[REDACTED] || 'localhost',\r\n  serverProtocol: process.env.[REDACTED] ? 'https' : 'http',\r\n  timeout: 5000,\r\n  routePatterns: [\r\n    'server/routes/**/*.js',\r\n    'server/api/**/*.js',\r\n    'routes/**/*.js',\r\n    'api/**/*.js',\r\n    'server/**/*routes*.js',\r\n    'server/**/*api*.js'\r\n  ],\r\n  frontendPaths: [\r\n    'front-end/src',\r\n    'frontend/src',\r\n    'client/src',\r\n    'src'\r\n  ],\r\n  excludePatterns: [\r\n    'node_modules',\r\n    '.git',\r\n    'dist',\r\n    'build',\r\n    'coverage',\r\n    '*.log'\r\n  ]\r\n};\r\n\r\n// Colors for console output\r\nconst colors = {\r\n  reset: '\\x1b[0m',\r\n  bright: '\\x1b[1m',\r\n  red: '\\x1b[31m',\r\n  green: '\\x1b[32m',\r\n  yellow: '\\x1b[33m',\r\n  blue: '\\x1b[34m',\r\n  magenta: '\\x1b[35m',\r\n  cyan: '\\x1b[36m',\r\n  white: '\\x1b[37m'\r\n};\r\n\r\nclass APIAuditor {\r\n  constructor() {\r\n    this.routes = new Map();\r\n    this.testResults = new Map();\r\n    this.usageAnalysis = new Map();\r\n    this.stats = {\r\n      totalRoutes: 0,\r\n      workingRoutes: 0,\r\n      errorRoutes: 0,\r\n      unusedRoutes: 0,\r\n      testedRoutes: 0\r\n    };\r\n  }\r\n\r\n  log(message, color = 'white') {\r\n    console.log(`${colors[color]}${message}${colors.reset}`);\r\n  }\r\n\r\n  async discoverRouteFiles() {\r\n    this.log('\\nüîç Discovering Route Files...', 'cyan');\r\n    const routeFiles = [];\r\n\r\n    for (const pattern of CONFIG.routePatterns) {\r\n      try {\r\n        const files = await this.globPattern(pattern);\r\n        routeFiles.push(...files);\r\n      } catch (error) {\r\n        // Pattern might not match anything\r\n      }\r\n    }\r\n\r\n    // Also scan server directory recursively for route-like files\r\n    const serverDir = path.join(CONFIG.projectRoot, 'server');\r\n    if (await this.fileExists(serverDir)) {\r\n      const additionalFiles = await this.scanForRouteFiles(serverDir);\r\n      routeFiles.push(...additionalFiles);\r\n    }\r\n\r\n    const uniqueFiles = [...new Set(routeFiles)];\r\n    this.log(`Found ${uniqueFiles.length} potential route files`, 'green');\r\n    \r\n    return uniqueFiles;\r\n  }\r\n\r\n  async scanForRouteFiles(dir) {\r\n    const files = [];\r\n    try {\r\n      const entries = await fs.readdir(dir, { withFileTypes: true });\r\n      \r\n      for (const entry of entries) {\r\n        if (CONFIG.excludePatterns.some(pattern => entry.name.includes(pattern))) {\r\n          continue;\r\n        }\r\n\r\n        const fullPath = path.join(dir, entry.name);\r\n        \r\n        if (entry.isDirectory()) {\r\n          const subFiles = await this.scanForRouteFiles(fullPath);\r\n          files.push(...subFiles);\r\n        } else if (entry.isFile() && entry.name.endsWith('.js')) {\r\n          // Check if file likely contains routes\r\n          const content = await fs.readFile(fullPath, 'utf8');\r\n          if (this.looksLikeRouteFile(content)) {\r\n            files.push(fullPath);\r\n          }\r\n        }\r\n      }\r\n    } catch (error) {\r\n      // Directory might not be accessible\r\n    }\r\n\r\n    return files;\r\n  }\r\n\r\n  looksLikeRouteFile(content) {\r\n    const routeIndicators = [\r\n      'router.',\r\n      'app.get(',\r\n      'app.post(',\r\n      'app.put(',\r\n      'app.delete(',\r\n      'app.patch(',\r\n      'express.Router',\r\n      'route.get',\r\n      'route.post',\r\n      '/api/',\r\n      'router.get',\r\n      'router.post'\r\n    ];\r\n\r\n    return routeIndicators.some(indicator => content.includes(indicator));\r\n  }\r\n\r\n  async parseRouteFile(filePath) {\r\n    this.log(`üìÑ Parsing: ${path.relative(CONFIG.projectRoot, filePath)}`, 'yellow');\r\n    \r\n    try {\r\n      const content = await fs.readFile(filePath, 'utf8');\r\n      const routes = this.extractRoutes(content, filePath);\r\n      \r\n      for (const route of routes) {\r\n        const key = `${route.method}:${route.path}`;\r\n        if (!this.routes.has(key)) {\r\n          this.routes.set(key, {\r\n            ...route,\r\n            file: filePath,\r\n            relativePath: path.relative(CONFIG.projectRoot, filePath)\r\n          });\r\n        }\r\n      }\r\n\r\n      this.log(`  Found ${routes.length} routes`, 'green');\r\n      return routes;\r\n    } catch (error) {\r\n      this.log(`  Error parsing file: ${error.message}`, 'red');\r\n      return [];\r\n    }\r\n  }\r\n\r\n  extractRoutes(content, filePath) {\r\n    const routes = [];\r\n    \r\n    // Patterns to match Express.js route definitions\r\n    const routePatterns = [\r\n      // router.get('/path', handler)\r\n      /(?:router|app|route)\\.(?:get|post|put|delete|patch|all)\\s*\\(\\s*['\"`]([^'\"`]+)['\"`]/g,\r\n      // app.use('/path', handler)\r\n      /(?:router|app)\\.use\\s*\\(\\s*['\"`]([^'\"`]+)['\"`]/g,\r\n      // Explicit route objects or comments\r\n      /\\/\\*\\*[\\s\\S]*?@route\\s+(\\w+)\\s+([^\\s]+)/g\r\n    ];\r\n\r\n    const methodPatterns = [\r\n      { pattern: /(?:router|app|route)\\.get\\s*\\(\\s*['\"`]([^'\"`]+)['\"`]/g, method: 'GET' },\r\n      { pattern: /(?:router|app|route)\\.post\\s*\\(\\s*['\"`]([^'\"`]+)['\"`]/g, method: 'POST' },\r\n      { pattern: /(?:router|app|route)\\.put\\s*\\(\\s*['\"`]([^'\"`]+)['\"`]/g, method: 'PUT' },\r\n      { pattern: /(?:router|app|route)\\.delete\\s*\\(\\s*['\"`]([^'\"`]+)['\"`]/g, method: 'DELETE' },\r\n      { pattern: /(?:router|app|route)\\.patch\\s*\\(\\s*['\"`]([^'\"`]+)['\"`]/g, method: 'PATCH' },\r\n      { pattern: /(?:router|app|route)\\.all\\s*\\(\\s*['\"`]([^'\"`]+)['\"`]/g, method: 'ALL' },\r\n      { pattern: /(?:router|app)\\.use\\s*\\(\\s*['\"`]([^'\"`]+)['\"`]/g, method: 'USE' }\r\n    ];\r\n\r\n    for (const { pattern, method } of methodPatterns) {\r\n      let match;\r\n      pattern.lastIndex = 0; // Reset regex state\r\n      \r\n      while ((match = pattern.exec(content)) !== null) {\r\n        const routePath = match[1];\r\n        \r\n        // Skip middleware-only routes (usually don't have specific paths)\r\n        if (routePath === '/' && method === 'USE') continue;\r\n        \r\n        // Extract middleware and handler info\r\n        const lineNumber = this.getLineNumber(content, match.index);\r\n        const context = this.extractContext(content, match.index);\r\n        \r\n        routes.push({\r\n          method: method,\r\n          path: routePath,\r\n          lineNumber,\r\n          context,\r\n          middleware: this.extractMiddleware(context),\r\n          description: this.extractDescription(content, match.index)\r\n        });\r\n      }\r\n    }\r\n\r\n    return routes;\r\n  }\r\n\r\n  getLineNumber(content, index) {\r\n    return content.substring(0, index).split('\\n').length;\r\n  }\r\n\r\n  extractContext(content, index) {\r\n    const lines = content.split('\\n');\r\n    const lineNumber = this.getLineNumber(content, index);\r\n    const start = Math.max(0, lineNumber - 3);\r\n    const end = Math.min(lines.length, lineNumber + 2);\r\n    \r\n    return lines.slice(start, end).join('\\n');\r\n  }\r\n\r\n  extractMiddleware(context) {\r\n    const middlewarePattern = /(?:authenticate|authorize|validate|check|verify|cors|helmet|rateLimit)/gi;\r\n    const matches = context.match(middlewarePattern) || [];\r\n    return [...new Set(matches)];\r\n  }\r\n\r\n  extractDescription(content, index) {\r\n    // Look for comments above the route\r\n    const beforeRoute = content.substring(0, index);\r\n    const lines = beforeRoute.split('\\n');\r\n    \r\n    for (let i = lines.length - 1; i >= Math.max(0, lines.length - 5); i--) {\r\n      const line = lines[i].trim();\r\n      if (line.startsWith('//') || line.startsWith('*')) {\r\n        return line.replace(/^\\/\\/\\s*|\\*\\s*/g, '');\r\n      }\r\n    }\r\n    \r\n    return '';\r\n  }\r\n\r\n  async analyzeUsage() {\r\n    this.log('\\nüîó Analyzing Route Usage...', 'cyan');\r\n    \r\n    for (const [routeKey, route] of this.routes) {\r\n      const usage = await this.findRouteUsage(route);\r\n      this.usageAnalysis.set(routeKey, usage);\r\n      \r\n      if (usage.frontendReferences.length === 0 && usage.backendReferences.length === 0) {\r\n        this.stats.unusedRoutes++;\r\n      }\r\n    }\r\n  }\r\n\r\n  async findRouteUsage(route) {\r\n    const usage = {\r\n      frontendReferences: [],\r\n      backendReferences: [],\r\n      totalReferences: 0\r\n    };\r\n\r\n    // Search patterns for this route\r\n    const searchPatterns = [\r\n      route.path,\r\n      route.path.replace(/:\\w+/g, '\\\\w+'), // Replace params with regex\r\n      `\"${route.path}\"`,\r\n      `'${route.path}'`,\r\n      `\\`${route.path}\\``,\r\n      route.path.replace(/^\\/api/, '') // Sometimes API prefix is omitted\r\n    ];\r\n\r\n    // Search frontend\r\n    for (const frontendPath of CONFIG.frontendPaths) {\r\n      const fullPath = path.join(CONFIG.projectRoot, frontendPath);\r\n      if (await this.fileExists(fullPath)) {\r\n        for (const pattern of searchPatterns) {\r\n          const references = await this.searchInDirectory(fullPath, pattern);\r\n          usage.frontendReferences.push(...references);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Search backend (excluding the definition file)\r\n    const serverPath = path.join(CONFIG.projectRoot, 'server');\r\n    if (await this.fileExists(serverPath)) {\r\n      for (const pattern of searchPatterns) {\r\n        const references = await this.searchInDirectory(serverPath, pattern);\r\n        // Filter out the file where the route is defined\r\n        const filteredRefs = references.filter(ref => ref.file !== route.file);\r\n        usage.backendReferences.push(...filteredRefs);\r\n      }\r\n    }\r\n\r\n    usage.totalReferences = usage.frontendReferences.length + usage.backendReferences.length;\r\n    return usage;\r\n  }\r\n\r\n  async searchInDirectory(dir, pattern) {\r\n    const references = [];\r\n    \r\n    try {\r\n      // Use grep for faster searching\r\n      const { stdout } = await execAsync(\r\n        `grep -r -n -i \"${pattern}\" \"${dir}\" --include=\"*.js\" --include=\"*.ts\" --include=\"*.jsx\" --include=\"*.tsx\" --include=\"*.vue\" 2>/dev/null || true`\r\n      );\r\n      \r\n      const lines = stdout.trim().split('\\n').filter(line => line);\r\n      \r\n      for (const line of lines) {\r\n        const match = line.match(/^([^:]+):(\\d+):(.+)$/);\r\n        if (match) {\r\n          references.push({\r\n            file: match[1],\r\n            lineNumber: parseInt(match[2]),\r\n            content: match[3].trim(),\r\n            relativePath: path.relative(CONFIG.projectRoot, match[1])\r\n          });\r\n        }\r\n      }\r\n    } catch (error) {\r\n      // Grep might fail, that's okay\r\n    }\r\n\r\n    return references;\r\n  }\r\n\r\n  async testEndpoints() {\r\n    this.log('\\nüß™ Testing API Endpoints...', 'cyan');\r\n    \r\n    // Check if server is running\r\n    const serverRunning = await this.checkServerHealth();\r\n    if (!serverRunning) {\r\n      this.log('‚ö†Ô∏è  Server not responding - skipping endpoint tests', 'yellow');\r\n      return;\r\n    }\r\n\r\n    for (const [routeKey, route] of this.routes) {\r\n      if (route.method === 'USE') continue; // Skip middleware routes\r\n      \r\n      this.log(`Testing ${route.method} ${route.path}...`, 'yellow');\r\n      \r\n      const testResult = await this.testEndpoint(route);\r\n      this.testResults.set(routeKey, testResult);\r\n      this.stats.testedRoutes++;\r\n      \r\n      if (testResult.success) {\r\n        this.stats.workingRoutes++;\r\n        this.log(`  ‚úÖ ${testResult.status}`, 'green');\r\n      } else {\r\n        this.stats.errorRoutes++;\r\n        this.log(`  ‚ùå ${testResult.error}`, 'red');\r\n      }\r\n    }\r\n  }\r\n\r\n  async checkServerHealth() {\r\n    try {\r\n      const response = await this.makeRequest('GET', '/api/health', {});\r\n      return response.success;\r\n    } catch (error) {\r\n      try {\r\n        // Try root path\r\n        const response = await this.makeRequest('GET', '/', {});\r\n        return response.success;\r\n      } catch (error) {\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n\r\n  async testEndpoint(route) {\r\n    try {\r\n      // Prepare test data based on method\r\n      const testData = this.generateTestData(route);\r\n      const response = await this.makeRequest(route.method, route.path, testData);\r\n      \r\n      return {\r\n        success: true,\r\n        status: response.statusCode,\r\n        responseTime: response.responseTime,\r\n        contentType: response.contentType,\r\n        bodySize: response.bodySize\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        success: false,\r\n        error: error.message,\r\n        status: error.status || 'Unknown'\r\n      };\r\n    }\r\n  }\r\n\r\n  generateTestData(route) {\r\n    // Replace route parameters with test values\r\n    let testPath = route.path;\r\n    testPath = testPath.replace(/:id/g, '1');\r\n    testPath = testPath.replace(/:userId/g, '1');\r\n    testPath = testPath.replace(/:(\\w+)/g, 'test');\r\n    \r\n    const data = { path: testPath };\r\n    \r\n    // Add common test data for POST/PUT requests\r\n    if (['POST', 'PUT', 'PATCH'].includes(route.method)) {\r\n      data.body = { test: true, timestamp: Date.now() };\r\n      data.headers = { 'Content-Type': 'application/json' };\r\n    }\r\n    \r\n    return data;\r\n  }\r\n\r\n  async makeRequest(method, path, data) {\r\n    return new Promise((resolve, reject) => {\r\n      const startTime = Date.now();\r\n      const url = `${CONFIG.serverProtocol}://${CONFIG.serverHost}:${CONFIG.serverPort}${data.path || path}`;\r\n      \r\n      const options = {\r\n        method,\r\n        timeout: CONFIG.timeout,\r\n        headers: data.headers || {}\r\n      };\r\n\r\n      const client = CONFIG.serverProtocol === 'https' ? https : http;\r\n      \r\n      const req = client.request(url, options, (res) => {\r\n        let body = '';\r\n        res.on('data', chunk => body += chunk);\r\n        res.on('end', () => {\r\n          resolve({\r\n            success: true,\r\n            statusCode: res.statusCode,\r\n            responseTime: Date.now() - startTime,\r\n            contentType: res.headers['content-type'],\r\n            bodySize: body.length,\r\n            body: body.substring(0, 200) // First 200 chars\r\n          });\r\n        });\r\n      });\r\n\r\n      req.on('error', (error) => {\r\n        reject({\r\n          success: false,\r\n          error: error.message,\r\n          status: error.code\r\n        });\r\n      });\r\n\r\n      req.on('timeout', () => {\r\n        req.destroy();\r\n        reject({\r\n          success: false,\r\n          error: 'Request timeout',\r\n          status: 'TIMEOUT'\r\n        });\r\n      });\r\n\r\n      if (data.body) {\r\n        req.write(JSON.stringify(data.body));\r\n      }\r\n\r\n      req.end();\r\n    });\r\n  }\r\n\r\n  generateReport() {\r\n    this.log('\\nüìä API Audit Report', 'bright');\r\n    this.log('='.repeat(50), 'cyan');\r\n\r\n    // Statistics\r\n    this.stats.totalRoutes = this.routes.size;\r\n    this.log(`\\nüìà Statistics:`, 'bright');\r\n    this.log(`  Total Routes: ${this.stats.totalRoutes}`, 'white');\r\n    this.log(`  Working Routes: ${this.stats.workingRoutes}`, 'green');\r\n    this.log(`  Error Routes: ${this.stats.errorRoutes}`, 'red');\r\n    this.log(`  Unused Routes: ${this.stats.unusedRoutes}`, 'yellow');\r\n    this.log(`  Tested Routes: ${this.stats.testedRoutes}`, 'blue');\r\n\r\n    // Route listing\r\n    this.log(`\\nüìã All Discovered Routes:`, 'bright');\r\n    this.log('-'.repeat(80), 'cyan');\r\n\r\n    const sortedRoutes = Array.from(this.routes.entries()).sort((a, b) => {\r\n      const [, routeA] = a;\r\n      const [, routeB] = b;\r\n      return routeA.path.localeCompare(routeB.path);\r\n    });\r\n\r\n    for (const [routeKey, route] of sortedRoutes) {\r\n      const usage = this.usageAnalysis.get(routeKey) || { totalReferences: 0 };\r\n      const testResult = this.testResults.get(routeKey);\r\n      \r\n      let status = '‚ùì';\r\n      if (testResult) {\r\n        status = testResult.success ? '‚úÖ' : '‚ùå';\r\n      }\r\n      \r\n      let usageIndicator = usage.totalReferences > 0 ? 'üîó' : '‚ö™';\r\n      \r\n      this.log(`${status} ${usageIndicator} ${route.method.padEnd(6)} ${route.path}`, 'white');\r\n      this.log(`    üìÅ ${route.relativePath}:${route.lineNumber}`, 'cyan');\r\n      \r\n      if (route.description) {\r\n        this.log(`    üí¨ ${route.description}`, 'yellow');\r\n      }\r\n      \r\n      if (route.middleware.length > 0) {\r\n        this.log(`    üõ°Ô∏è  Middleware: ${route.middleware.join(', ')}`, 'magenta');\r\n      }\r\n      \r\n      if (testResult && !testResult.success) {\r\n        this.log(`    ‚ö†Ô∏è  Error: ${testResult.error}`, 'red');\r\n      }\r\n      \r\n      if (usage.totalReferences > 0) {\r\n        this.log(`    üîó ${usage.totalReferences} references (${usage.frontendReferences.length} frontend, ${usage.backendReferences.length} backend)`, 'green');\r\n      } else {\r\n        this.log(`    ‚ö™ No usage found - may be unused`, 'yellow');\r\n      }\r\n      \r\n      this.log('', 'white');\r\n    }\r\n\r\n    // Unused routes\r\n    if (this.stats.unusedRoutes > 0) {\r\n      this.log(`\\n‚ö†Ô∏è  Potentially Unused Routes:`, 'yellow');\r\n      this.log('-'.repeat(40), 'yellow');\r\n      \r\n      for (const [routeKey, route] of this.routes) {\r\n        const usage = this.usageAnalysis.get(routeKey);\r\n        if (usage && usage.totalReferences === 0) {\r\n          this.log(`  ${route.method} ${route.path} (${route.relativePath})`, 'yellow');\r\n        }\r\n      }\r\n    }\r\n\r\n    // Error routes\r\n    if (this.stats.errorRoutes > 0) {\r\n      this.log(`\\n‚ùå Routes with Errors:`, 'red');\r\n      this.log('-'.repeat(40), 'red');\r\n      \r\n      for (const [routeKey, route] of this.routes) {\r\n        const testResult = this.testResults.get(routeKey);\r\n        if (testResult && !testResult.success) {\r\n          this.log(`  ${route.method} ${route.path}: ${testResult.error}`, 'red');\r\n        }\r\n      }\r\n    }\r\n\r\n    this.log('\\n‚úÖ API Audit Complete!', 'green');\r\n  }\r\n\r\n  // Utility methods\r\n  async fileExists(filePath) {\r\n    try {\r\n      await fs.access(filePath);\r\n      return true;\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  async globPattern(pattern) {\r\n    // Simple glob implementation for basic patterns\r\n    const basePath = pattern.split('*')[0];\r\n    const extension = pattern.includes('*.js') ? '.js' : '';\r\n    \r\n    try {\r\n      return await this.findFiles(basePath, extension);\r\n    } catch {\r\n      return [];\r\n    }\r\n  }\r\n\r\n  async findFiles(dir, extension, files = []) {\r\n    try {\r\n      const entries = await fs.readdir(dir, { withFileTypes: true });\r\n      \r\n      for (const entry of entries) {\r\n        const fullPath = path.join(dir, entry.name);\r\n        \r\n        if (entry.isDirectory() && !CONFIG.excludePatterns.some(p => entry.name.includes(p))) {\r\n          await this.findFiles(fullPath, extension, files);\r\n        } else if (entry.isFile() && (!extension || entry.name.endsWith(extension))) {\r\n          files.push(fullPath);\r\n        }\r\n      }\r\n    } catch {\r\n      // Directory might not exist\r\n    }\r\n    \r\n    return files;\r\n  }\r\n}\r\n\r\n// Main execution\r\nasync function main() {\r\n  const args = process.argv.slice(2);\r\n  const testEndpoints = args.includes('--test-endpoints');\r\n  const detailed = args.includes('--detailed');\r\n\r\n  console.log(`${colors.bright}${colors.blue}üîç API Audit Tool for OrthodoxMetrics${colors.reset}`);\r\n  console.log(`${colors.cyan}Starting comprehensive API discovery and analysis...${colors.reset}\\n`);\r\n\r\n  const auditor = new APIAuditor();\r\n\r\n  try {\r\n    // Step 1: Discover route files\r\n    const routeFiles = await auditor.discoverRouteFiles();\r\n    \r\n    if (routeFiles.length === 0) {\r\n      auditor.log('‚ùå No route files found!', 'red');\r\n      return;\r\n    }\r\n\r\n    // Step 2: Parse routes\r\n    for (const file of routeFiles) {\r\n      await auditor.parseRouteFile(file);\r\n    }\r\n\r\n    // Step 3: Analyze usage\r\n    await auditor.analyzeUsage();\r\n\r\n    // Step 4: Test endpoints (if requested)\r\n    if (testEndpoints) {\r\n      await auditor.testEndpoints();\r\n    }\r\n\r\n    // Step 5: Generate report\r\n    auditor.generateReport();\r\n\r\n  } catch (error) {\r\n    auditor.log(`‚ùå Audit failed: ${error.message}`, 'red');\r\n    if (detailed) {\r\n      console.error(error);\r\n    }\r\n  }\r\n}\r\n\r\n// Run if called directly\r\nif (require.main === module) {\r\n  main().catch(console.error);\r\n}\r\n\r\nmodule.exports = { APIAuditor }; "
    },
    "complexity": {
      "totalLines": 668,
      "codeLines": 513,
      "commentLines": 45,
      "commentRatio": 0.08064516129032258,
      "averageLineLength": 34.3584229390681
    },
    "lastAnalyzed": "2025-07-28T07:19:59.068Z"
  },
  "contentHash": "1feb3b183a92996603f99a7417049481b4cfe3f7985550e7d16353d47f48debe",
  "discoveredAt": "2025-07-28T07:19:59.068Z"
}