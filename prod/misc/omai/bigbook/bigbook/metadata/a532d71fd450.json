{
  "id": "a532d71fd450",
  "originalPath": "/var/www/orthodox-church-mgmt/orthodoxmetrics/prod/docs/archive/07-09-25/SESSION_SECURITY.md",
  "relativePath": "docs/archive/07-09-25/SESSION_SECURITY.md",
  "name": "SESSION_SECURITY.md",
  "extension": ".md",
  "size": 25236,
  "modified": "2025-07-09T04:32:16.331Z",
  "created": "2025-07-09T04:32:16.331Z",
  "classification": {
    "type": "Documentation",
    "category": "Documentation",
    "confidence": 7
  },
  "metadata": {
    "fileStats": {
      "lines": 940,
      "characters": 25218,
      "words": 2472
    },
    "classification": {
      "type": "Documentation",
      "category": "Documentation",
      "confidence": 7
    },
    "dependencies": [
      {
        "type": "npm_package",
        "name": "express-session",
        "line": 31
      },
      {
        "type": "npm_package",
        "name": "express-mysql-session",
        "line": 32
      },
      {
        "type": "npm_package",
        "name": "crypto",
        "line": 33
      },
      {
        "type": "npm_package",
        "name": "crypto",
        "line": 147
      },
      {
        "type": "npm_package",
        "name": "crypto",
        "line": 350
      },
      {
        "type": "npm_package",
        "name": "express-mysql-session",
        "line": 402
      },
      {
        "type": "npm_package",
        "name": "express",
        "line": 846
      }
    ],
    "security": {
      "findings": [
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 37,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 38,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 39,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 40,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 72,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 85,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 93,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 198,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 218,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 352,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 476,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 684,
          "redacted": true
        }
      ],
      "hasSecurityIssues": true,
      "redactedContent": "# Session Security Implementation\r\n\r\n## 🔐 Orthodox Metrics Session Security\r\n\r\nThis document provides comprehensive documentation for the session security implementation in the Orthodox Metrics system.\r\n\r\n## 🛡️ Session Security Overview\r\n\r\n### Security Principles\r\n1. **Secure Session Storage**: MySQL-based session storage with encryption\r\n2. **Cookie Security**: HTTP-only, secure, and SameSite cookies\r\n3. **Session Validation**: Continuous session integrity checking\r\n4. **Timeout Management**: Automatic session expiration\r\n5. **Concurrent Session Control**: Prevent session hijacking\r\n6. **Activity Monitoring**: Track and log session activities\r\n\r\n### Security Features\r\n- **Session Encryption**: Encrypted session data\r\n- **IP Validation**: Session-IP binding\r\n- **User Agent Validation**: Browser fingerprinting\r\n- **Session Rotation**: Periodic session ID regeneration\r\n- **Secure Logout**: Proper session cleanup\r\n\r\n## 🔧 Session Configuration\r\n\r\n### 1. Secure Session Setup\r\n\r\n#### Enhanced Session Configuration\r\n```javascript\r\n// config/session.js\r\nconst session = require('express-session');\r\nconst MySQLStore = require('express-mysql-session')(session);\r\nconst crypto = require('crypto');\r\n\r\n// Create secure session store\r\nconst sessionStore = new MySQLStore({\r\n  host: process.env.[REDACTED],\r\n  user: process.env.[REDACTED],\r\n  password: process.env.[REDACTED],\r\n  database: process.env.[REDACTED],\r\n  \r\n  // Table configuration\r\n  createDatabaseTable: true,\r\n  schema: {\r\n    tableName: 'sessions',\r\n    columnNames: {\r\n      session_id: 'session_id',\r\n      expires: 'expires',\r\n      data: 'data'\r\n    }\r\n  },\r\n  \r\n  // Security options\r\n  clearExpired: true,\r\n  checkExpirationInterval: 900000, // 15 minutes\r\n  expiration: 1800000, // 30 minutes\r\n  \r\n  // Connection options\r\n  connectionLimit: 10,\r\n  acquireTimeout: 60000,\r\n  timeout: 60000,\r\n  reconnect: true\r\n});\r\n\r\n// Session configuration\r\nconst sessionConfig = {\r\n  // Session identification\r\n  key: 'orthodox.sid',\r\n  name: 'orthodox.sid',\r\n  \r\n  // Session secret (should be strong and unique)\r\n  secret: process.env.[REDACTED] || crypto.randomBytes(64).toString('hex'),\r\n  \r\n  // Store configuration\r\n  store: sessionStore,\r\n  \r\n  // Session behavior\r\n  resave: false,\r\n  saveUninitialized: false,\r\n  rolling: true, // Reset expiration on activity\r\n  \r\n  // Cookie security\r\n  cookie: {\r\n    // Security flags\r\n    secure: process.env.[REDACTED] === 'production', // HTTPS only in production\r\n    httpOnly: true, // Prevent XSS\r\n    sameSite: 'strict', // CSRF protection\r\n    \r\n    // Expiration\r\n    maxAge: 30 * 60 * 1000, // 30 minutes\r\n    \r\n    // Additional security\r\n    domain: process.env.[REDACTED] || undefined,\r\n    path: '/'\r\n  },\r\n  \r\n  // Custom session ID generator\r\n  genid: (req) => {\r\n    return crypto.randomBytes(32).toString('hex');\r\n  },\r\n  \r\n  // Session middleware options\r\n  proxy: true, // Trust proxy headers\r\n  unset: 'destroy' // Destroy session on unset\r\n};\r\n\r\nmodule.exports = session(sessionConfig);\r\n```\r\n\r\n### 2. Session Store Events\r\n\r\n#### Session Store Monitoring\r\n```javascript\r\n// config/session.js (continued)\r\nconst logger = require('../utils/logger');\r\n\r\n// Session store event handlers\r\nsessionStore.on('connect', () => {\r\n  logger.info('Session store connected to database');\r\n});\r\n\r\nsessionStore.on('disconnect', () => {\r\n  logger.warn('Session store disconnected from database');\r\n});\r\n\r\nsessionStore.on('error', (error) => {\r\n  logger.error('Session store error:', error);\r\n});\r\n\r\n// Session cleanup events\r\nsessionStore.on('destroy', (sessionId) => {\r\n  logger.debug('Session destroyed:', sessionId);\r\n});\r\n\r\nsessionStore.on('touch', (sessionId) => {\r\n  logger.debug('Session touched:', sessionId);\r\n});\r\n```\r\n\r\n## 🔒 Session Security Middleware\r\n\r\n### 1. Session Security Enhancement\r\n\r\n#### Session Security Middleware\r\n```javascript\r\n// middleware/sessionSecurity.js\r\nconst crypto = require('crypto');\r\nconst logger = require('../utils/logger');\r\n\r\nconst sessionSecurity = (req, res, next) => {\r\n  // Skip if no session\r\n  if (!req.session) {\r\n    return next();\r\n  }\r\n  \r\n  try {\r\n    // Get current request information\r\n    const currentIP = req.ip || req.connection.remoteAddress;\r\n    const currentUA = req.get('User-Agent') || '';\r\n    const currentTime = Date.now();\r\n    \r\n    // Initialize session security data\r\n    if (!req.session.security) {\r\n      req.session.security = {\r\n        createdAt: currentTime,\r\n        initialIP: currentIP,\r\n        initialUA: currentUA,\r\n        lastActivity: currentTime,\r\n        activityCount: 0,\r\n        ipHistory: [currentIP],\r\n        regenerationCount: 0\r\n      };\r\n    }\r\n    \r\n    const security = req.session.security;\r\n    \r\n    // Update activity tracking\r\n    security.lastActivity = currentTime;\r\n    security.activityCount++;\r\n    \r\n    // IP validation\r\n    if (security.initialIP !== currentIP) {\r\n      // Log IP change\r\n      logger.warn('Session IP change detected:', {\r\n        sessionId: req.sessionID,\r\n        userId: req.session.user?.id,\r\n        initialIP: security.initialIP,\r\n        currentIP: currentIP,\r\n        userAgent: currentUA\r\n      });\r\n      \r\n      // Add to IP history\r\n      if (!security.ipHistory.includes(currentIP)) {\r\n        security.ipHistory.push(currentIP);\r\n      }\r\n      \r\n      // Strict IP validation (optional)\r\n      if (process.env.[REDACTED] === 'true') {\r\n        logger.error('Session terminated due to IP change');\r\n        req.session.destroy();\r\n        return res.status(401).json({\r\n          success: false,\r\n          error: 'Session terminated for security reasons'\r\n        });\r\n      }\r\n    }\r\n    \r\n    // User Agent validation\r\n    if (security.initialUA !== currentUA) {\r\n      logger.warn('Session User Agent change detected:', {\r\n        sessionId: req.sessionID,\r\n        userId: req.session.user?.id,\r\n        initialUA: security.initialUA,\r\n        currentUA: currentUA\r\n      });\r\n      \r\n      // Optionally terminate session on UA change\r\n      if (process.env.[REDACTED] === 'true') {\r\n        logger.error('Session terminated due to User Agent change');\r\n        req.session.destroy();\r\n        return res.status(401).json({\r\n          success: false,\r\n          error: 'Session terminated for security reasons'\r\n        });\r\n      }\r\n    }\r\n    \r\n    // Session duration validation\r\n    const sessionDuration = currentTime - security.createdAt;\r\n    const maxSessionDuration = 12 * 60 * 60 * 1000; // 12 hours\r\n    \r\n    if (sessionDuration > maxSessionDuration) {\r\n      logger.info('Session terminated due to maximum duration exceeded:', {\r\n        sessionId: req.sessionID,\r\n        userId: req.session.user?.id,\r\n        duration: sessionDuration\r\n      });\r\n      \r\n      req.session.destroy();\r\n      return res.status(401).json({\r\n        success: false,\r\n        error: 'Session expired due to maximum duration'\r\n      });\r\n    }\r\n    \r\n    // Activity-based session regeneration\r\n    if (security.activityCount > 0 && security.activityCount % 100 === 0) {\r\n      const oldSessionId = req.sessionID;\r\n      \r\n      req.session.regenerate((err) => {\r\n        if (err) {\r\n          logger.error('Session regeneration failed:', err);\r\n          return next();\r\n        }\r\n        \r\n        security.regenerationCount++;\r\n        \r\n        logger.info('Session regenerated:', {\r\n          oldSessionId: oldSessionId,\r\n          newSessionId: req.sessionID,\r\n          userId: req.session.user?.id,\r\n          regenerationCount: security.regenerationCount\r\n        });\r\n        \r\n        next();\r\n      });\r\n    } else {\r\n      next();\r\n    }\r\n    \r\n  } catch (error) {\r\n    logger.error('Session security middleware error:', error);\r\n    next();\r\n  }\r\n};\r\n\r\nmodule.exports = sessionSecurity;\r\n```\r\n\r\n### 2. Session Timeout Management\r\n\r\n#### Session Timeout Middleware\r\n```javascript\r\n// middleware/sessionTimeout.js\r\nconst logger = require('../utils/logger');\r\n\r\nconst sessionTimeout = (req, res, next) => {\r\n  if (!req.session || !req.session.user) {\r\n    return next();\r\n  }\r\n  \r\n  try {\r\n    const now = Date.now();\r\n    const lastActivity = req.session.lastActivity || now;\r\n    const sessionTimeout = 30 * 60 * 1000; // 30 minutes\r\n    const warningTime = 5 * 60 * 1000; // 5 minutes before timeout\r\n    \r\n    // Check if session has expired\r\n    if (now - lastActivity > sessionTimeout) {\r\n      logger.info('Session expired due to inactivity:', {\r\n        sessionId: req.sessionID,\r\n        userId: req.session.user.id,\r\n        lastActivity: new Date(lastActivity),\r\n        timeout: sessionTimeout\r\n      });\r\n      \r\n      req.session.destroy((err) => {\r\n        if (err) {\r\n          logger.error('Session destruction error:', err);\r\n        }\r\n        \r\n        res.status(401).json({\r\n          success: false,\r\n          error: 'Session expired due to inactivity',\r\n          code: 'SESSION_EXPIRED'\r\n        });\r\n      });\r\n      \r\n      return;\r\n    }\r\n    \r\n    // Update last activity\r\n    req.session.lastActivity = now;\r\n    \r\n    // Add timeout warning to response\r\n    const timeUntilExpiry = sessionTimeout - (now - lastActivity);\r\n    if (timeUntilExpiry <= warningTime) {\r\n      res.set('X-Session-Warning', 'true');\r\n      res.set('X-Session-Time-Left', Math.floor(timeUntilExpiry / 1000).toString());\r\n    }\r\n    \r\n    next();\r\n    \r\n  } catch (error) {\r\n    logger.error('Session timeout middleware error:', error);\r\n    next();\r\n  }\r\n};\r\n\r\nmodule.exports = sessionTimeout;\r\n```\r\n\r\n## 🔐 Session Encryption\r\n\r\n### 1. Session Data Encryption\r\n\r\n#### Session Encryption Utilities\r\n```javascript\r\n// utils/sessionEncryption.js\r\nconst crypto = require('crypto');\r\n\r\nconst ENCRYPTION_KEY = process.env.[REDACTED] || crypto.randomBytes(32);\r\nconst ALGORITHM = 'aes-256-gcm';\r\n\r\nconst encrypt = (data) => {\r\n  try {\r\n    const iv = crypto.randomBytes(16);\r\n    const cipher = crypto.createCipher(ALGORITHM, ENCRYPTION_KEY);\r\n    cipher.setAAD(Buffer.from('session-data', 'utf8'));\r\n    \r\n    let encrypted = cipher.update(JSON.stringify(data), 'utf8', 'hex');\r\n    encrypted += cipher.final('hex');\r\n    \r\n    const authTag = cipher.getAuthTag();\r\n    \r\n    return {\r\n      iv: iv.toString('hex'),\r\n      data: encrypted,\r\n      authTag: authTag.toString('hex')\r\n    };\r\n  } catch (error) {\r\n    throw new Error('Encryption failed');\r\n  }\r\n};\r\n\r\nconst decrypt = (encryptedData) => {\r\n  try {\r\n    const decipher = crypto.createDecipher(ALGORITHM, ENCRYPTION_KEY);\r\n    decipher.setAAD(Buffer.from('session-data', 'utf8'));\r\n    decipher.setAuthTag(Buffer.from(encryptedData.authTag, 'hex'));\r\n    \r\n    let decrypted = decipher.update(encryptedData.data, 'hex', 'utf8');\r\n    decrypted += decipher.final('utf8');\r\n    \r\n    return JSON.parse(decrypted);\r\n  } catch (error) {\r\n    throw new Error('Decryption failed');\r\n  }\r\n};\r\n\r\nmodule.exports = {\r\n  encrypt,\r\n  decrypt\r\n};\r\n```\r\n\r\n### 2. Secure Session Storage\r\n\r\n#### Custom Session Store with Encryption\r\n```javascript\r\n// stores/EncryptedMySQLStore.js\r\nconst MySQLStore = require('express-mysql-session');\r\nconst { encrypt, decrypt } = require('../utils/sessionEncryption');\r\n\r\nclass EncryptedMySQLStore extends MySQLStore {\r\n  constructor(options) {\r\n    super(options);\r\n  }\r\n  \r\n  // Override set method to encrypt data\r\n  set(sessionId, session, callback) {\r\n    try {\r\n      const encryptedSession = encrypt(session);\r\n      super.set(sessionId, encryptedSession, callback);\r\n    } catch (error) {\r\n      callback(error);\r\n    }\r\n  }\r\n  \r\n  // Override get method to decrypt data\r\n  get(sessionId, callback) {\r\n    super.get(sessionId, (error, session) => {\r\n      if (error) {\r\n        return callback(error);\r\n      }\r\n      \r\n      if (!session) {\r\n        return callback(null, null);\r\n      }\r\n      \r\n      try {\r\n        const decryptedSession = decrypt(session);\r\n        callback(null, decryptedSession);\r\n      } catch (decryptError) {\r\n        callback(decryptError);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = EncryptedMySQLStore;\r\n```\r\n\r\n## 🔍 Session Monitoring\r\n\r\n### 1. Session Activity Logging\r\n\r\n#### Session Activity Logger\r\n```javascript\r\n// middleware/sessionLogger.js\r\nconst logger = require('../utils/logger');\r\n\r\nconst sessionLogger = (req, res, next) => {\r\n  if (!req.session || !req.session.user) {\r\n    return next();\r\n  }\r\n  \r\n  try {\r\n    const sessionInfo = {\r\n      sessionId: req.sessionID,\r\n      userId: req.session.user.id,\r\n      userEmail: req.session.user.email,\r\n      ip: req.ip,\r\n      userAgent: req.get('User-Agent'),\r\n      method: req.method,\r\n      url: req.url,\r\n      timestamp: new Date().toISOString(),\r\n      referer: req.get('Referer'),\r\n      origin: req.get('Origin')\r\n    };\r\n    \r\n    // Log session activity\r\n    logger.info('Session activity:', sessionInfo);\r\n    \r\n    // Store activity in database for analysis\r\n    if (process.env.[REDACTED] === 'true') {\r\n      storeSessionActivity(sessionInfo);\r\n    }\r\n    \r\n    next();\r\n    \r\n  } catch (error) {\r\n    logger.error('Session logging error:', error);\r\n    next();\r\n  }\r\n};\r\n\r\nconst storeSessionActivity = async (activityData) => {\r\n  try {\r\n    const db = require('../database/connection');\r\n    \r\n    await db.execute(`\r\n      INSERT INTO session_activities (\r\n        session_id, user_id, ip_address, user_agent, method, url, \r\n        referer, origin, created_at\r\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, NOW())\r\n    `, [\r\n      activityData.sessionId,\r\n      activityData.userId,\r\n      activityData.ip,\r\n      activityData.userAgent,\r\n      activityData.method,\r\n      activityData.url,\r\n      activityData.referer,\r\n      activityData.origin\r\n    ]);\r\n    \r\n  } catch (error) {\r\n    logger.error('Failed to store session activity:', error);\r\n  }\r\n};\r\n\r\nmodule.exports = sessionLogger;\r\n```\r\n\r\n### 2. Session Analytics\r\n\r\n#### Session Analytics Utilities\r\n```javascript\r\n// utils/sessionAnalytics.js\r\nconst db = require('../database/connection');\r\n\r\nconst getSessionStats = async (timeRange = '24h') => {\r\n  try {\r\n    let timeCondition;\r\n    \r\n    switch (timeRange) {\r\n      case '1h':\r\n        timeCondition = 'created_at > DATE_SUB(NOW(), INTERVAL 1 HOUR)';\r\n        break;\r\n      case '24h':\r\n        timeCondition = 'created_at > DATE_SUB(NOW(), INTERVAL 24 HOUR)';\r\n        break;\r\n      case '7d':\r\n        timeCondition = 'created_at > DATE_SUB(NOW(), INTERVAL 7 DAY)';\r\n        break;\r\n      default:\r\n        timeCondition = 'created_at > DATE_SUB(NOW(), INTERVAL 24 HOUR)';\r\n    }\r\n    \r\n    const [results] = await db.execute(`\r\n      SELECT \r\n        COUNT(DISTINCT session_id) as active_sessions,\r\n        COUNT(DISTINCT user_id) as unique_users,\r\n        COUNT(*) as total_activities,\r\n        COUNT(DISTINCT ip_address) as unique_ips,\r\n        AVG(TIMESTAMPDIFF(MINUTE, MIN(created_at), MAX(created_at))) as avg_session_duration\r\n      FROM session_activities \r\n      WHERE ${timeCondition}\r\n    `);\r\n    \r\n    return results[0];\r\n  } catch (error) {\r\n    logger.error('Session analytics error:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\nconst getTopUsersByActivity = async (limit = 10) => {\r\n  try {\r\n    const [results] = await db.execute(`\r\n      SELECT \r\n        u.id,\r\n        u.email,\r\n        u.name,\r\n        COUNT(sa.id) as activity_count,\r\n        MAX(sa.created_at) as last_activity\r\n      FROM users u\r\n      JOIN session_activities sa ON u.id = sa.user_id\r\n      WHERE sa.created_at > DATE_SUB(NOW(), INTERVAL 24 HOUR)\r\n      GROUP BY u.id\r\n      ORDER BY activity_count DESC\r\n      LIMIT ?\r\n    `, [limit]);\r\n    \r\n    return results;\r\n  } catch (error) {\r\n    logger.error('Top users analytics error:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\nconst getSuspiciousActivities = async () => {\r\n  try {\r\n    const [results] = await db.execute(`\r\n      SELECT \r\n        user_id,\r\n        COUNT(DISTINCT ip_address) as ip_count,\r\n        COUNT(DISTINCT user_agent) as ua_count,\r\n        COUNT(*) as activity_count,\r\n        GROUP_CONCAT(DISTINCT ip_address) as ip_addresses\r\n      FROM session_activities\r\n      WHERE created_at > DATE_SUB(NOW(), INTERVAL 24 HOUR)\r\n      GROUP BY user_id\r\n      HAVING ip_count > 3 OR ua_count > 2\r\n      ORDER BY ip_count DESC, ua_count DESC\r\n    `);\r\n    \r\n    return results;\r\n  } catch (error) {\r\n    logger.error('Suspicious activities analytics error:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\nmodule.exports = {\r\n  getSessionStats,\r\n  getTopUsersByActivity,\r\n  getSuspiciousActivities\r\n};\r\n```\r\n\r\n## 🔒 Session Hijacking Prevention\r\n\r\n### 1. Session Hijacking Detection\r\n\r\n#### Session Hijacking Detector\r\n```javascript\r\n// middleware/hijackingDetector.js\r\nconst logger = require('../utils/logger');\r\nconst { logSecurityEvent } = require('../utils/securityLogger');\r\n\r\nconst hijackingDetector = (req, res, next) => {\r\n  if (!req.session || !req.session.user) {\r\n    return next();\r\n  }\r\n  \r\n  try {\r\n    const currentIP = req.ip;\r\n    const currentUA = req.get('User-Agent');\r\n    const sessionId = req.sessionID;\r\n    const userId = req.session.user.id;\r\n    \r\n    // Initialize fingerprint if not exists\r\n    if (!req.session.fingerprint) {\r\n      req.session.fingerprint = {\r\n        ip: currentIP,\r\n        userAgent: currentUA,\r\n        created: Date.now()\r\n      };\r\n    }\r\n    \r\n    const fingerprint = req.session.fingerprint;\r\n    \r\n    // Check for IP changes\r\n    if (fingerprint.ip !== currentIP) {\r\n      logSecurityEvent('IP_CHANGE', {\r\n        sessionId,\r\n        userId,\r\n        oldIP: fingerprint.ip,\r\n        newIP: currentIP,\r\n        userAgent: currentUA\r\n      });\r\n      \r\n      // Check if IP change is suspicious\r\n      if (await isSuspiciousIPChange(fingerprint.ip, currentIP)) {\r\n        logger.error('Suspicious IP change detected - terminating session:', {\r\n          sessionId,\r\n          userId,\r\n          oldIP: fingerprint.ip,\r\n          newIP: currentIP\r\n        });\r\n        \r\n        req.session.destroy();\r\n        return res.status(401).json({\r\n          success: false,\r\n          error: 'Session terminated for security reasons',\r\n          code: 'SUSPICIOUS_ACTIVITY'\r\n        });\r\n      }\r\n    }\r\n    \r\n    // Check for User Agent changes\r\n    if (fingerprint.userAgent !== currentUA) {\r\n      logSecurityEvent('USER_AGENT_CHANGE', {\r\n        sessionId,\r\n        userId,\r\n        oldUA: fingerprint.userAgent,\r\n        newUA: currentUA,\r\n        ip: currentIP\r\n      });\r\n      \r\n      // Terminate session on UA change (more strict)\r\n      if (process.env.[REDACTED] === 'true') {\r\n        logger.error('User Agent change detected - terminating session');\r\n        req.session.destroy();\r\n        return res.status(401).json({\r\n          success: false,\r\n          error: 'Session terminated for security reasons',\r\n          code: 'SUSPICIOUS_ACTIVITY'\r\n        });\r\n      }\r\n    }\r\n    \r\n    // Check for concurrent sessions\r\n    const concurrentSessions = await getConcurrentSessions(userId);\r\n    if (concurrentSessions > 3) {\r\n      logger.warn('Multiple concurrent sessions detected:', {\r\n        userId,\r\n        sessionCount: concurrentSessions\r\n      });\r\n      \r\n      logSecurityEvent('CONCURRENT_SESSIONS', {\r\n        userId,\r\n        sessionCount: concurrentSessions,\r\n        currentSessionId: sessionId\r\n      });\r\n    }\r\n    \r\n    next();\r\n    \r\n  } catch (error) {\r\n    logger.error('Hijacking detector error:', error);\r\n    next();\r\n  }\r\n};\r\n\r\nconst isSuspiciousIPChange = async (oldIP, newIP) => {\r\n  // Check if IPs are from different geographic regions\r\n  // This is a simplified check - in production, use a proper geolocation service\r\n  \r\n  const oldIPParts = oldIP.split('.');\r\n  const newIPParts = newIP.split('.');\r\n  \r\n  // Simple check for different subnets\r\n  if (oldIPParts[0] !== newIPParts[0] || oldIPParts[1] !== newIPParts[1]) {\r\n    return true;\r\n  }\r\n  \r\n  return false;\r\n};\r\n\r\nconst getConcurrentSessions = async (userId) => {\r\n  try {\r\n    const db = require('../database/connection');\r\n    \r\n    const [results] = await db.execute(`\r\n      SELECT COUNT(*) as session_count\r\n      FROM sessions \r\n      WHERE JSON_EXTRACT(data, '$.user.id') = ? \r\n      AND expires > NOW()\r\n    `, [userId]);\r\n    \r\n    return results[0].session_count;\r\n  } catch (error) {\r\n    logger.error('Failed to get concurrent sessions:', error);\r\n    return 0;\r\n  }\r\n};\r\n\r\nmodule.exports = hijackingDetector;\r\n```\r\n\r\n### 2. Session Cleanup\r\n\r\n#### Session Cleanup Utilities\r\n```javascript\r\n// utils/sessionCleanup.js\r\nconst db = require('../database/connection');\r\nconst logger = require('./logger');\r\n\r\nconst cleanupExpiredSessions = async () => {\r\n  try {\r\n    const [result] = await db.execute(`\r\n      DELETE FROM sessions \r\n      WHERE expires < NOW()\r\n    `);\r\n    \r\n    logger.info(`Cleaned up ${result.affectedRows} expired sessions`);\r\n    \r\n    return result.affectedRows;\r\n  } catch (error) {\r\n    logger.error('Session cleanup error:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\nconst cleanupOldSessionActivities = async (daysToKeep = 30) => {\r\n  try {\r\n    const [result] = await db.execute(`\r\n      DELETE FROM session_activities \r\n      WHERE created_at < DATE_SUB(NOW(), INTERVAL ? DAY)\r\n    `, [daysToKeep]);\r\n    \r\n    logger.info(`Cleaned up ${result.affectedRows} old session activities`);\r\n    \r\n    return result.affectedRows;\r\n  } catch (error) {\r\n    logger.error('Session activities cleanup error:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\nconst terminateUserSessions = async (userId) => {\r\n  try {\r\n    const [result] = await db.execute(`\r\n      DELETE FROM sessions \r\n      WHERE JSON_EXTRACT(data, '$.user.id') = ?\r\n    `, [userId]);\r\n    \r\n    logger.info(`Terminated ${result.affectedRows} sessions for user ${userId}`);\r\n    \r\n    return result.affectedRows;\r\n  } catch (error) {\r\n    logger.error('User session termination error:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n// Schedule cleanup jobs\r\nconst scheduleCleanup = () => {\r\n  // Clean expired sessions every hour\r\n  setInterval(async () => {\r\n    try {\r\n      await cleanupExpiredSessions();\r\n    } catch (error) {\r\n      logger.error('Scheduled session cleanup failed:', error);\r\n    }\r\n  }, 60 * 60 * 1000); // 1 hour\r\n  \r\n  // Clean old activities daily\r\n  setInterval(async () => {\r\n    try {\r\n      await cleanupOldSessionActivities();\r\n    } catch (error) {\r\n      logger.error('Scheduled activity cleanup failed:', error);\r\n    }\r\n  }, 24 * 60 * 60 * 1000); // 24 hours\r\n};\r\n\r\nmodule.exports = {\r\n  cleanupExpiredSessions,\r\n  cleanupOldSessionActivities,\r\n  terminateUserSessions,\r\n  scheduleCleanup\r\n};\r\n```\r\n\r\n## 📊 Session Security Dashboard\r\n\r\n### 1. Session Security Metrics\r\n\r\n#### Session Security API\r\n```javascript\r\n// routes/admin/sessionSecurity.js\r\nconst express = require('express');\r\nconst { requireAdmin } = require('../../middleware/auth');\r\nconst { getSessionStats, getSuspiciousActivities } = require('../../utils/sessionAnalytics');\r\n\r\nconst router = express.Router();\r\n\r\n// Get session security overview\r\nrouter.get('/overview', requireAdmin, async (req, res) => {\r\n  try {\r\n    const stats = await getSessionStats();\r\n    const suspiciousActivities = await getSuspiciousActivities();\r\n    \r\n    res.json({\r\n      success: true,\r\n      data: {\r\n        stats,\r\n        suspiciousActivities,\r\n        timestamp: new Date().toISOString()\r\n      }\r\n    });\r\n  } catch (error) {\r\n    res.status(500).json({\r\n      success: false,\r\n      error: 'Failed to get session security overview'\r\n    });\r\n  }\r\n});\r\n\r\n// Get active sessions\r\nrouter.get('/active-sessions', requireAdmin, async (req, res) => {\r\n  try {\r\n    const [sessions] = await db.execute(`\r\n      SELECT \r\n        session_id,\r\n        JSON_EXTRACT(data, '$.user.id') as user_id,\r\n        JSON_EXTRACT(data, '$.user.email') as user_email,\r\n        JSON_EXTRACT(data, '$.security.initialIP') as ip_address,\r\n        expires,\r\n        TIMESTAMPDIFF(MINUTE, \r\n          FROM_UNIXTIME(JSON_EXTRACT(data, '$.security.createdAt')/1000), \r\n          NOW()\r\n        ) as duration_minutes\r\n      FROM sessions \r\n      WHERE expires > NOW()\r\n      ORDER BY expires DESC\r\n    `);\r\n    \r\n    res.json({\r\n      success: true,\r\n      sessions: sessions\r\n    });\r\n  } catch (error) {\r\n    res.status(500).json({\r\n      success: false,\r\n      error: 'Failed to get active sessions'\r\n    });\r\n  }\r\n});\r\n\r\n// Terminate session\r\nrouter.delete('/sessions/:sessionId', requireAdmin, async (req, res) => {\r\n  try {\r\n    const { sessionId } = req.params;\r\n    \r\n    const [result] = await db.execute(\r\n      'DELETE FROM sessions WHERE session_id = ?',\r\n      [sessionId]\r\n    );\r\n    \r\n    if (result.affectedRows === 0) {\r\n      return res.status(404).json({\r\n        success: false,\r\n        error: 'Session not found'\r\n      });\r\n    }\r\n    \r\n    res.json({\r\n      success: true,\r\n      message: 'Session terminated successfully'\r\n    });\r\n  } catch (error) {\r\n    res.status(500).json({\r\n      success: false,\r\n      error: 'Failed to terminate session'\r\n    });\r\n  }\r\n});\r\n\r\nmodule.exports = router;\r\n```\r\n\r\n---\r\n\r\n*This session security documentation provides comprehensive coverage of the Orthodox Metrics session security implementation. It should be updated whenever session security features are modified or enhanced.*\r\n"
    },
    "complexity": {
      "totalLines": 940,
      "codeLines": 681,
      "commentLines": 96,
      "commentRatio": 0.12355212355212356,
      "averageLineLength": 30.577863577863578
    },
    "lastAnalyzed": "2025-07-28T07:19:57.967Z"
  },
  "contentHash": "580f0f17a89a5ac968d11022b79aa79ce158cb972e50c8a612db559e993c7640",
  "discoveredAt": "2025-07-28T07:19:57.967Z"
}