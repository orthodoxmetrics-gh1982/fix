{
  "id": "749165db9ed3",
  "originalPath": "/var/www/orthodox-church-mgmt/orthodoxmetrics/prod/front-end/src/ai/fixLogger.ts",
  "relativePath": "front-end/src/ai/fixLogger.ts",
  "name": "fixLogger.ts",
  "extension": ".ts",
  "size": 14194,
  "modified": "2025-07-25T04:29:32.909Z",
  "created": "2025-07-25T04:29:29.202Z",
  "classification": {
    "type": "Troubleshooting Utilities",
    "category": "Diagnostic Tools",
    "confidence": 3
  },
  "metadata": {
    "fileStats": {
      "lines": 488,
      "characters": 14192,
      "words": 1351
    },
    "classification": {
      "type": "Troubleshooting Utilities",
      "category": "Diagnostic Tools",
      "confidence": 3
    },
    "dependencies": [],
    "security": {
      "findings": [
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 84,
          "redacted": true
        }
      ],
      "hasSecurityIssues": true,
      "redactedContent": "import { DetectedIssue } from './errorClassifier';\r\nimport { FixResult } from './recoveryActions';\r\n\r\nexport interface FixRecord {\r\n  id: string;\r\n  componentId: string;\r\n  componentName: string;\r\n  timestamp: string;\r\n  issues: DetectedIssue[];\r\n  appliedFixes: FixResult[];\r\n  confidence: number;\r\n  userRole: string;\r\n  environment: 'development' | 'staging' | 'production';\r\n  success: boolean;\r\n  error?: string;\r\n  retryCount: number;\r\n  beforeSnapshot?: ComponentSnapshot;\r\n  afterSnapshot?: ComponentSnapshot;\r\n  metadata?: Record<string, any>;\r\n}\r\n\r\nexport interface ComponentSnapshot {\r\n  props: Record<string, any>;\r\n  styles: Record<string, string>;\r\n  classes: string[];\r\n  attributes: Record<string, string>;\r\n  content: string;\r\n  position: { x: number; y: number; width: number; height: number };\r\n}\r\n\r\nexport interface FixHistoryQuery {\r\n  componentId?: string;\r\n  componentName?: string;\r\n  startDate?: string;\r\n  endDate?: string;\r\n  success?: boolean;\r\n  userRole?: string;\r\n  environment?: string;\r\n  limit?: number;\r\n  offset?: number;\r\n}\r\n\r\nexport interface FixStatistics {\r\n  totalFixes: number;\r\n  successfulFixes: number;\r\n  failedFixes: number;\r\n  averageConfidence: number;\r\n  mostCommonIssues: Array<{ type: string; count: number }>;\r\n  fixesByComponent: Array<{ componentName: string; count: number }>;\r\n  fixesByStrategy: Array<{ strategy: string; count: number }>;\r\n}\r\n\r\nexport class FixLogger {\r\n  private storageKey = 'omai_fix_history';\r\n  private maxRecords = 1000; // Maximum number of records to keep in localStorage\r\n  private records: FixRecord[] = [];\r\n\r\n  constructor() {\r\n    this.loadRecords();\r\n  }\r\n\r\n  /**\r\n   * Log a fix attempt\r\n   */\r\n  async logFix(fixRecord: FixRecord): Promise<void> {\r\n    try {\r\n      // Add before/after snapshots if component element exists\r\n      if (fixRecord.appliedFixes.length > 0) {\r\n        fixRecord.beforeSnapshot = await this.createComponentSnapshot(fixRecord.componentId);\r\n      }\r\n\r\n      // Add to records\r\n      this.records.unshift(fixRecord);\r\n\r\n      // Limit the number of records\r\n      if (this.records.length > this.maxRecords) {\r\n        this.records = this.records.slice(0, this.maxRecords);\r\n      }\r\n\r\n      // Save to storage\r\n      this.saveRecords();\r\n\r\n      // Log to console in development\r\n      if (process.env.[REDACTED] === 'development') {\r\n        console.group(`ðŸ”§ OMAI Fix Logged: ${fixRecord.componentName}`);\r\n        console.log('Fix ID:', fixRecord.id);\r\n        console.log('Success:', fixRecord.success);\r\n        console.log('Confidence:', fixRecord.confidence);\r\n        console.log('Issues:', fixRecord.issues.length);\r\n        console.log('Applied Fixes:', fixRecord.appliedFixes.length);\r\n        console.log('Timestamp:', fixRecord.timestamp);\r\n        console.groupEnd();\r\n      }\r\n\r\n    } catch (error) {\r\n      console.error('Failed to log fix:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get fix history with optional filtering\r\n   */\r\n  async getFixHistory(query: FixHistoryQuery = {}): Promise<FixRecord[]> {\r\n    let filteredRecords = [...this.records];\r\n\r\n    // Apply filters\r\n    if (query.componentId) {\r\n      filteredRecords = filteredRecords.filter(record => \r\n        record.componentId === query.componentId\r\n      );\r\n    }\r\n\r\n    if (query.componentName) {\r\n      filteredRecords = filteredRecords.filter(record => \r\n        record.componentName.toLowerCase().includes(query.componentName!.toLowerCase())\r\n      );\r\n    }\r\n\r\n    if (query.startDate) {\r\n      filteredRecords = filteredRecords.filter(record => \r\n        record.timestamp >= query.startDate!\r\n      );\r\n    }\r\n\r\n    if (query.endDate) {\r\n      filteredRecords = filteredRecords.filter(record => \r\n        record.timestamp <= query.endDate!\r\n      );\r\n    }\r\n\r\n    if (query.success !== undefined) {\r\n      filteredRecords = filteredRecords.filter(record => \r\n        record.success === query.success\r\n      );\r\n    }\r\n\r\n    if (query.userRole) {\r\n      filteredRecords = filteredRecords.filter(record => \r\n        record.userRole === query.userRole\r\n      );\r\n    }\r\n\r\n    if (query.environment) {\r\n      filteredRecords = filteredRecords.filter(record => \r\n        record.environment === query.environment\r\n      );\r\n    }\r\n\r\n    // Apply pagination\r\n    const offset = query.offset || 0;\r\n    const limit = query.limit || filteredRecords.length;\r\n\r\n    return filteredRecords.slice(offset, offset + limit);\r\n  }\r\n\r\n  /**\r\n   * Get a specific fix record by ID\r\n   */\r\n  async getFixById(fixId: string): Promise<FixRecord | null> {\r\n    return this.records.find(record => record.id === fixId) || null;\r\n  }\r\n\r\n  /**\r\n   * Get fix statistics\r\n   */\r\n  async getFixStatistics(query: FixHistoryQuery = {}): Promise<FixStatistics> {\r\n    const records = await this.getFixHistory(query);\r\n\r\n    const totalFixes = records.length;\r\n    const successfulFixes = records.filter(r => r.success).length;\r\n    const failedFixes = totalFixes - successfulFixes;\r\n    const averageConfidence = records.length > 0 \r\n      ? records.reduce((sum, r) => sum + r.confidence, 0) / records.length \r\n      : 0;\r\n\r\n    // Most common issues\r\n    const issueCounts: Record<string, number> = {};\r\n    records.forEach(record => {\r\n      record.issues.forEach(issue => {\r\n        issueCounts[issue.type] = (issueCounts[issue.type] || 0) + 1;\r\n      });\r\n    });\r\n\r\n    const mostCommonIssues = Object.entries(issueCounts)\r\n      .map(([type, count]) => ({ type, count }))\r\n      .sort((a, b) => b.count - a.count)\r\n      .slice(0, 10);\r\n\r\n    // Fixes by component\r\n    const componentCounts: Record<string, number> = {};\r\n    records.forEach(record => {\r\n      componentCounts[record.componentName] = (componentCounts[record.componentName] || 0) + 1;\r\n    });\r\n\r\n    const fixesByComponent = Object.entries(componentCounts)\r\n      .map(([componentName, count]) => ({ componentName, count }))\r\n      .sort((a, b) => b.count - a.count)\r\n      .slice(0, 10);\r\n\r\n    // Fixes by strategy\r\n    const strategyCounts: Record<string, number> = {};\r\n    records.forEach(record => {\r\n      record.appliedFixes.forEach(fix => {\r\n        const strategyName = fix.strategy.name;\r\n        strategyCounts[strategyName] = (strategyCounts[strategyName] || 0) + 1;\r\n      });\r\n    });\r\n\r\n    const fixesByStrategy = Object.entries(strategyCounts)\r\n      .map(([strategy, count]) => ({ strategy, count }))\r\n      .sort((a, b) => b.count - a.count)\r\n      .slice(0, 10);\r\n\r\n    return {\r\n      totalFixes,\r\n      successfulFixes,\r\n      failedFixes,\r\n      averageConfidence,\r\n      mostCommonIssues,\r\n      fixesByComponent,\r\n      fixesByStrategy\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Rollback a specific fix\r\n   */\r\n  async rollbackFix(fixId: string): Promise<boolean> {\r\n    try {\r\n      const fixRecord = await this.getFixById(fixId);\r\n      \r\n      if (!fixRecord) {\r\n        throw new Error(`Fix record not found: ${fixId}`);\r\n      }\r\n\r\n      if (!fixRecord.beforeSnapshot) {\r\n        throw new Error('No before snapshot available for rollback');\r\n      }\r\n\r\n      // Apply rollback using the before snapshot\r\n      const success = await this.applySnapshot(fixRecord.componentId, fixRecord.beforeSnapshot);\r\n\r\n      if (success) {\r\n        // Log the rollback\r\n        await this.logFix({\r\n          id: this.generateFixId(),\r\n          componentId: fixRecord.componentId,\r\n          componentName: fixRecord.componentName,\r\n          timestamp: new Date().toISOString(),\r\n          issues: [],\r\n          appliedFixes: [],\r\n          confidence: 1.0,\r\n          userRole: fixRecord.userRole,\r\n          environment: fixRecord.environment,\r\n          success: true,\r\n          retryCount: 0,\r\n          metadata: {\r\n            rollbackOf: fixId,\r\n            rollbackReason: 'Manual rollback requested'\r\n          }\r\n        });\r\n      }\r\n\r\n      return success;\r\n\r\n    } catch (error) {\r\n      console.error('Failed to rollback fix:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create a snapshot of a component's current state\r\n   */\r\n  private async createComponentSnapshot(componentId: string): Promise<ComponentSnapshot | undefined> {\r\n    try {\r\n      // Find the component element\r\n      const element = document.querySelector(`[data-component-id=\"${componentId}\"]`) as HTMLElement;\r\n      \r\n      if (!element) {\r\n        return undefined;\r\n      }\r\n\r\n      const computedStyle = window.getComputedStyle(element);\r\n      const rect = element.getBoundingClientRect();\r\n\r\n      // Extract props from data attributes\r\n      const props: Record<string, any> = {};\r\n      for (const attr of element.attributes) {\r\n        if (attr.name.startsWith('data-prop-')) {\r\n          const propName = attr.name.replace('data-prop-', '');\r\n          try {\r\n            props[propName] = JSON.parse(attr.value);\r\n          } catch {\r\n            props[propName] = attr.value;\r\n          }\r\n        }\r\n      }\r\n\r\n      // Extract styles\r\n      const styles: Record<string, string> = {};\r\n      const styleProperties = [\r\n        'display', 'position', 'width', 'height', 'margin', 'padding',\r\n        'border', 'background', 'color', 'font-size', 'font-weight',\r\n        'overflow', 'z-index', 'opacity', 'visibility'\r\n      ];\r\n\r\n      for (const prop of styleProperties) {\r\n        styles[prop] = computedStyle.getPropertyValue(prop);\r\n      }\r\n\r\n      // Extract classes\r\n      const classes = Array.from(element.classList);\r\n\r\n      // Extract attributes\r\n      const attributes: Record<string, string> = {};\r\n      for (const attr of element.attributes) {\r\n        if (!attr.name.startsWith('data-prop-')) {\r\n          attributes[attr.name] = attr.value;\r\n        }\r\n      }\r\n\r\n      return {\r\n        props,\r\n        styles,\r\n        classes,\r\n        attributes,\r\n        content: element.textContent || '',\r\n        position: {\r\n          x: rect.x,\r\n          y: rect.y,\r\n          width: rect.width,\r\n          height: rect.height\r\n        }\r\n      };\r\n\r\n    } catch (error) {\r\n      console.error('Failed to create component snapshot:', error);\r\n      return undefined;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Apply a snapshot to restore component state\r\n   */\r\n  private async applySnapshot(componentId: string, snapshot: ComponentSnapshot): Promise<boolean> {\r\n    try {\r\n      const element = document.querySelector(`[data-component-id=\"${componentId}\"]`) as HTMLElement;\r\n      \r\n      if (!element) {\r\n        return false;\r\n      }\r\n\r\n      // Apply styles\r\n      for (const [property, value] of Object.entries(snapshot.styles)) {\r\n        element.style.setProperty(property, value);\r\n      }\r\n\r\n      // Apply classes\r\n      element.className = snapshot.classes.join(' ');\r\n\r\n      // Apply attributes\r\n      for (const [name, value] of Object.entries(snapshot.attributes)) {\r\n        element.setAttribute(name, value);\r\n      }\r\n\r\n      // Apply props (if they can be set via data attributes)\r\n      for (const [propName, propValue] of Object.entries(snapshot.props)) {\r\n        element.setAttribute(`data-prop-${propName}`, JSON.stringify(propValue));\r\n      }\r\n\r\n      return true;\r\n\r\n    } catch (error) {\r\n      console.error('Failed to apply snapshot:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Export fix history as JSON\r\n   */\r\n  async exportFixHistory(query: FixHistoryQuery = {}): Promise<string> {\r\n    const records = await this.getFixHistory(query);\r\n    return JSON.stringify(records, null, 2);\r\n  }\r\n\r\n  /**\r\n   * Import fix history from JSON\r\n   */\r\n  async importFixHistory(jsonData: string): Promise<number> {\r\n    try {\r\n      const records: FixRecord[] = JSON.parse(jsonData);\r\n      const validRecords = records.filter(record => this.validateFixRecord(record));\r\n      \r\n      this.records.unshift(...validRecords);\r\n      \r\n      // Limit the number of records\r\n      if (this.records.length > this.maxRecords) {\r\n        this.records = this.records.slice(0, this.maxRecords);\r\n      }\r\n\r\n      this.saveRecords();\r\n      return validRecords.length;\r\n\r\n    } catch (error) {\r\n      console.error('Failed to import fix history:', error);\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clear all fix history\r\n   */\r\n  async clearFixHistory(): Promise<void> {\r\n    this.records = [];\r\n    this.saveRecords();\r\n  }\r\n\r\n  /**\r\n   * Validate a fix record\r\n   */\r\n  private validateFixRecord(record: any): record is FixRecord {\r\n    return (\r\n      record &&\r\n      typeof record.id === 'string' &&\r\n      typeof record.componentId === 'string' &&\r\n      typeof record.componentName === 'string' &&\r\n      typeof record.timestamp === 'string' &&\r\n      Array.isArray(record.issues) &&\r\n      Array.isArray(record.appliedFixes) &&\r\n      typeof record.confidence === 'number' &&\r\n      typeof record.userRole === 'string' &&\r\n      typeof record.environment === 'string' &&\r\n      typeof record.success === 'boolean' &&\r\n      typeof record.retryCount === 'number'\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Load records from storage\r\n   */\r\n  private loadRecords(): void {\r\n    try {\r\n      const stored = localStorage.getItem(this.storageKey);\r\n      if (stored) {\r\n        const parsed = JSON.parse(stored);\r\n        this.records = Array.isArray(parsed) ? parsed : [];\r\n      }\r\n    } catch (error) {\r\n      console.error('Failed to load fix history from storage:', error);\r\n      this.records = [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Save records to storage\r\n   */\r\n  private saveRecords(): void {\r\n    try {\r\n      localStorage.setItem(this.storageKey, JSON.stringify(this.records));\r\n    } catch (error) {\r\n      console.error('Failed to save fix history to storage:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generate unique fix ID\r\n   */\r\n  private generateFixId(): string {\r\n    return `fix_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\r\n  }\r\n\r\n  /**\r\n   * Get storage usage statistics\r\n   */\r\n  getStorageStats(): { used: number; available: number; percentage: number } {\r\n    try {\r\n      const used = new Blob([JSON.stringify(this.records)]).size;\r\n      const available = 5 * 1024 * 1024; // 5MB localStorage limit\r\n      const percentage = (used / available) * 100;\r\n\r\n      return { used, available, percentage };\r\n    } catch (error) {\r\n      return { used: 0, available: 0, percentage: 0 };\r\n    }\r\n  }\r\n} "
    },
    "complexity": {
      "totalLines": 488,
      "codeLines": 351,
      "commentLines": 67,
      "commentRatio": 0.16028708133971292,
      "averageLineLength": 32.547846889952154
    },
    "lastAnalyzed": "2025-07-28T07:19:58.646Z"
  },
  "contentHash": "39656a7cf496bdf7025c5c5d14ea1332a351258e30d5f96030c38955f0f81f70",
  "discoveredAt": "2025-07-28T07:19:58.646Z"
}