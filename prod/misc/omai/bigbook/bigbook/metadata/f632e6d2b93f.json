{
  "id": "f632e6d2b93f",
  "originalPath": "/var/www/orthodox-church-mgmt/orthodoxmetrics/prod/server/legacy/phase2-create-transfer-service.js",
  "relativePath": "server/legacy/phase2-create-transfer-service.js",
  "name": "phase2-create-transfer-service.js",
  "extension": ".js",
  "size": 20126,
  "modified": "2025-07-24T14:51:40.472Z",
  "created": "2025-07-24T14:51:40.472Z",
  "classification": {
    "type": "Server Scripts",
    "category": "Backend > Server",
    "confidence": 3
  },
  "metadata": {
    "fileStats": {
      "lines": 609,
      "characters": 20048,
      "words": 1818
    },
    "classification": {
      "type": "Server Scripts",
      "category": "Backend > Server",
      "confidence": 3
    },
    "dependencies": [
      {
        "type": "npm_package",
        "name": "mysql2/promise",
        "line": 8
      },
      {
        "type": "npm_package",
        "name": "fs",
        "line": 9
      },
      {
        "type": "npm_package",
        "name": "path",
        "line": 10
      },
      {
        "type": "npm_package",
        "name": "mysql2/promise",
        "line": 20
      }
    ],
    "security": {
      "findings": [
        {
          "type": "sensitive_data",
          "pattern": "(?:password|pwd|pass)\\s*[:=]\\s*['\"]([^'\"]+)['\"]",
          "line": 550,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "(?:password|pwd|pass)\\s*[:=]\\s*['\"]([^'\"]+)['\"]",
          "line": 557,
          "redacted": true
        }
      ],
      "hasSecurityIssues": true,
      "redactedContent": "al#!/usr/bin/env node\n\n/**\n * Phase 2 - Step 2: OCR Transfer Service Implementation\n * Creates transferOcrResult() function and automated transfer service\n */\n\nconst mysql = require('mysql2/promise');\nconst fs = require('fs').promises;\nconst path = require('path');\n\nasync function createTransferService() {\n  try {\n    console.log('üîÑ PHASE 2 - Step 2: Creating OCR Transfer Service...');\n    console.log('================================================================================');\n    \n    // 1. Create the main transfer service\n    console.log('üìÅ Creating transfer service module...');\n    \n    const transferServiceCode = `import { Pool, PoolConnection, RowDataPacket } from 'mysql2/promise';\nimport { getOcrDbPool, getRecordsDbPool, getFrameworkDbPool } from '../utils/dbConnections';\nimport { \n  OcrJob, \n  OcrProcessingLog, \n  OcrReviewQueue, \n  OcrJobTransfer,\n  TransferStatus,\n  RecordType \n} from '../types/ocrTypes';\n\n/**\n * Core OCR Transfer Service\n * Handles transfer of completed OCR jobs from OCR DB to Records DB\n */\nexport class OcrTransferService {\n  \n  /**\n   * Transfer a completed OCR job from OCR DB to Records DB\n   * @param ocrJobId - The ID of the completed OCR job\n   * @param userId - The user initiating the transfer\n   * @returns Promise<OcrJobTransfer>\n   */\n  async transferOcrResult(ocrJobId: number, userId?: number): Promise<OcrJobTransfer> {\n    console.log(\\`üîÑ Starting transfer for OCR job \\${ocrJobId}\\`);\n    \n    const ocrPool = getOcrDbPool();\n    const recordsPool = getRecordsDbPool();\n    \n    let ocrConnection: PoolConnection | null = null;\n    let recordsConnection: PoolConnection | null = null;\n    \n    try {\n      // Get connections\n      ocrConnection = await ocrPool.getConnection();\n      recordsConnection = await recordsPool.getConnection();\n      \n      // Start transactions\n      await ocrConnection.beginTransaction();\n      await recordsConnection.beginTransaction();\n      \n      // 1. Fetch OCR job from source database\n      const ocrJob = await this.fetchOcrJob(ocrConnection, ocrJobId);\n      if (!ocrJob) {\n        throw new Error(\\`OCR job \\${ocrJobId} not found\\`);\n      }\n      \n      if (ocrJob.status !== 'complete') {\n        throw new Error(\\`OCR job \\${ocrJobId} is not complete (status: \\${ocrJob.status})\\`);\n      }\n      \n      // 2. Create processing log entry\n      const processingLogId = await this.createProcessingLog(\n        recordsConnection, \n        ocrJob, \n        userId\n      );\n      \n      // 3. Create review queue entry\n      const reviewQueueId = await this.createReviewQueueEntry(\n        recordsConnection,\n        ocrJob,\n        processingLogId\n      );\n      \n      // 4. Create transfer tracking record\n      const transferRecord = await this.createTransferRecord(\n        recordsConnection,\n        ocrJob,\n        processingLogId,\n        reviewQueueId,\n        userId\n      );\n      \n      // 5. Mark OCR job as transferred (optional flag)\n      await this.markOcrJobTransferred(ocrConnection, ocrJobId);\n      \n      // Commit transactions\n      await ocrConnection.commit();\n      await recordsConnection.commit();\n      \n      console.log(\\`‚úÖ Successfully transferred OCR job \\${ocrJobId} to Records DB\\`);\n      console.log(\\`   üìä Processing Log ID: \\${processingLogId}\\`);\n      console.log(\\`   üìã Review Queue ID: \\${reviewQueueId}\\`);\n      console.log(\\`   üîÑ Transfer ID: \\${transferRecord.id}\\`);\n      \n      return transferRecord;\n      \n    } catch (error) {\n      // Rollback transactions\n      if (ocrConnection) await ocrConnection.rollback();\n      if (recordsConnection) await recordsConnection.rollback();\n      \n      console.error(\\`‚ùå Transfer failed for OCR job \\${ocrJobId}:\\`, error);\n      throw error;\n    } finally {\n      // Release connections\n      if (ocrConnection) ocrConnection.release();\n      if (recordsConnection) recordsConnection.release();\n    }\n  }\n  \n  /**\n   * Fetch OCR job details from OCR database\n   */\n  private async fetchOcrJob(connection: PoolConnection, ocrJobId: number): Promise<OcrJob | null> {\n    const [rows] = await connection.execute<RowDataPacket[]>(\n      \\`SELECT \n        id, church_id, filename, original_filename, record_type, language,\n        status, extracted_text, extracted_entities, entity_confidence,\n        needs_review, detected_language, ocr_result, ocr_result_translation,\n        translation_confidence, created_at, updated_at, processing_started_at,\n        processing_completed_at, confidence_score\n      FROM ocr_jobs \n      WHERE id = ?\\`,\n      [ocrJobId]\n    );\n    \n    if (rows.length === 0) return null;\n    \n    return {\n      id: rows[0].id,\n      church_id: rows[0].church_id,\n      filename: rows[0].filename,\n      original_filename: rows[0].original_filename,\n      record_type: rows[0].record_type as RecordType,\n      language: rows[0].language,\n      status: rows[0].status,\n      extracted_text: rows[0].extracted_text,\n      extracted_entities: rows[0].extracted_entities ? JSON.parse(rows[0].extracted_entities) : null,\n      entity_confidence: rows[0].entity_confidence,\n      needs_review: Boolean(rows[0].needs_review),\n      detected_language: rows[0].detected_language,\n      ocr_result: rows[0].ocr_result,\n      ocr_result_translation: rows[0].ocr_result_translation,\n      translation_confidence: rows[0].translation_confidence,\n      created_at: rows[0].created_at,\n      updated_at: rows[0].updated_at,\n      processing_started_at: rows[0].processing_started_at,\n      processing_completed_at: rows[0].processing_completed_at,\n      confidence_score: rows[0].confidence_score\n    };\n  }\n  \n  /**\n   * Create processing log entry in Records DB\n   */\n  private async createProcessingLog(\n    connection: PoolConnection, \n    ocrJob: OcrJob, \n    userId?: number\n  ): Promise<number> {\n    const [result] = await connection.execute(\n      \\`INSERT INTO ocr_processing_log (\n        church_id, ocr_job_id, record_type, filename, status, user_id,\n        started_at, completed_at, processing_metadata, confidence_score\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\\`,\n      [\n        ocrJob.church_id,\n        ocrJob.id,\n        ocrJob.record_type,\n        ocrJob.original_filename || ocrJob.filename,\n        'transferred',\n        userId || null,\n        ocrJob.processing_started_at,\n        ocrJob.processing_completed_at,\n        JSON.stringify({\n          extracted_entities: ocrJob.extracted_entities,\n          entity_confidence: ocrJob.entity_confidence,\n          detected_language: ocrJob.detected_language,\n          translation_confidence: ocrJob.translation_confidence\n        }),\n        ocrJob.confidence_score\n      ]\n    );\n    \n    return (result as any).insertId;\n  }\n  \n  /**\n   * Create review queue entry in Records DB\n   */\n  private async createReviewQueueEntry(\n    connection: PoolConnection,\n    ocrJob: OcrJob,\n    processingLogId: number\n  ): Promise<number> {\n    // Determine if auto-insertable based on confidence\n    const autoInsertable = ocrJob.confidence_score && ocrJob.confidence_score >= 85 && !ocrJob.needs_review;\n    \n    // Set priority based on confidence and review needs\n    let priority = 'normal';\n    if (ocrJob.needs_review) priority = 'high';\n    else if (ocrJob.confidence_score && ocrJob.confidence_score < 50) priority = 'urgent';\n    else if (autoInsertable) priority = 'low';\n    \n    const [result] = await connection.execute(\n      \\`INSERT INTO ocr_review_queue (\n        church_id, ocr_job_id, processing_log_id, record_type, filename,\n        original_filename, extracted_text, confidence_avg, status, priority,\n        auto_insertable\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\\`,\n      [\n        ocrJob.church_id,\n        ocrJob.id,\n        processingLogId,\n        ocrJob.record_type,\n        ocrJob.filename,\n        ocrJob.original_filename,\n        ocrJob.extracted_text,\n        ocrJob.confidence_score,\n        'pending_review',\n        priority,\n        autoInsertable ? 1 : 0\n      ]\n    );\n    \n    return (result as any).insertId;\n  }\n  \n  /**\n   * Create transfer tracking record\n   */\n  private async createTransferRecord(\n    connection: PoolConnection,\n    ocrJob: OcrJob,\n    processingLogId: number,\n    reviewQueueId: number,\n    userId?: number\n  ): Promise<OcrJobTransfer> {\n    const [result] = await connection.execute(\n      \\`INSERT INTO ocr_job_transfers (\n        church_id, source_ocr_job_id, processing_log_id, review_queue_id,\n        transfer_status, record_type, initiated_by, transfer_started_at,\n        transfer_completed_at\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)\\`,\n      [\n        ocrJob.church_id,\n        ocrJob.id,\n        processingLogId,\n        reviewQueueId,\n        'completed',\n        ocrJob.record_type,\n        userId || null,\n        new Date(),\n        new Date()\n      ]\n    );\n    \n    const transferId = (result as any).insertId;\n    \n    return {\n      id: transferId,\n      church_id: ocrJob.church_id,\n      source_ocr_job_id: ocrJob.id,\n      processing_log_id: processingLogId,\n      review_queue_id: reviewQueueId,\n      transfer_status: 'completed' as TransferStatus,\n      transfer_type: 'auto',\n      source_database: 'saints_peter_and_paul_orthodox_church_db',\n      target_table: null,\n      record_type: ocrJob.record_type,\n      transferred_data: null,\n      target_record_id: null,\n      transfer_started_at: new Date(),\n      transfer_completed_at: new Date(),\n      error_message: null,\n      retry_count: 0,\n      initiated_by: userId || null,\n      created_at: new Date(),\n      updated_at: new Date()\n    };\n  }\n  \n  /**\n   * Mark OCR job as transferred (optional status update)\n   */\n  private async markOcrJobTransferred(connection: PoolConnection, ocrJobId: number): Promise<void> {\n    await connection.execute(\n      \\`UPDATE ocr_jobs SET \n        updated_at = NOW(),\n        processing_notes = CONCAT(\n          COALESCE(processing_notes, ''), \n          '\\\\n[', NOW(), '] Transferred to Records DB'\n        )\n      WHERE id = ?\\`,\n      [ocrJobId]\n    );\n  }\n  \n  /**\n   * Batch transfer multiple completed OCR jobs\n   */\n  async batchTransfer(churchId: number, userId?: number): Promise<OcrJobTransfer[]> {\n    console.log(\\`üîÑ Starting batch transfer for church \\${churchId}\\`);\n    \n    const ocrPool = getOcrDbPool();\n    let connection: PoolConnection | null = null;\n    \n    try {\n      connection = await ocrPool.getConnection();\n      \n      // Find completed OCR jobs that haven't been transferred\n      const [rows] = await connection.execute<RowDataPacket[]>(\n        \\`SELECT id FROM ocr_jobs \n         WHERE church_id = ? \n         AND status = 'complete' \n         AND (processing_notes IS NULL OR processing_notes NOT LIKE '%Transferred to Records DB%')\n         ORDER BY processing_completed_at ASC\n         LIMIT 10\\`,\n        [churchId]\n      );\n      \n      const transfers: OcrJobTransfer[] = [];\n      \n      for (const row of rows) {\n        try {\n          const transfer = await this.transferOcrResult(row.id, userId);\n          transfers.push(transfer);\n        } catch (error) {\n          console.error(\\`‚ùå Failed to transfer OCR job \\${row.id}:\\`, error);\n        }\n      }\n      \n      console.log(\\`‚úÖ Batch transfer completed: \\${transfers.length}/\\${rows.length} successful\\`);\n      return transfers;\n      \n    } finally {\n      if (connection) connection.release();\n    }\n  }\n  \n  /**\n   * Get transfer status for an OCR job\n   */\n  async getTransferStatus(ocrJobId: number): Promise<OcrJobTransfer | null> {\n    const recordsPool = getRecordsDbPool();\n    let connection: PoolConnection | null = null;\n    \n    try {\n      connection = await recordsPool.getConnection();\n      \n      const [rows] = await connection.execute<RowDataPacket[]>(\n        \\`SELECT * FROM ocr_job_transfers WHERE source_ocr_job_id = ? ORDER BY created_at DESC LIMIT 1\\`,\n        [ocrJobId]\n      );\n      \n      if (rows.length === 0) return null;\n      \n      const row = rows[0];\n      return {\n        id: row.id,\n        church_id: row.church_id,\n        source_ocr_job_id: row.source_ocr_job_id,\n        processing_log_id: row.processing_log_id,\n        review_queue_id: row.review_queue_id,\n        transfer_status: row.transfer_status as TransferStatus,\n        transfer_type: row.transfer_type,\n        source_database: row.source_database,\n        target_table: row.target_table,\n        record_type: row.record_type as RecordType,\n        transferred_data: row.transferred_data ? JSON.parse(row.transferred_data) : null,\n        target_record_id: row.target_record_id,\n        transfer_started_at: row.transfer_started_at,\n        transfer_completed_at: row.transfer_completed_at,\n        error_message: row.error_message,\n        retry_count: row.retry_count,\n        initiated_by: row.initiated_by,\n        created_at: row.created_at,\n        updated_at: row.updated_at\n      };\n      \n    } finally {\n      if (connection) connection.release();\n    }\n  }\n}\n\n// Export singleton instance\nexport const ocrTransferService = new OcrTransferService();\n\n// Export individual function for backward compatibility\nexport const transferOcrResult = (ocrJobId: number, userId?: number) => \n  ocrTransferService.transferOcrResult(ocrJobId, userId);\n`;\n    \n    const transferServicePath = path.join(__dirname, '..', 'services', 'ocrTransferService.ts');\n    await fs.writeFile(transferServicePath, transferServiceCode);\n    console.log('‚úÖ Created OCR transfer service');\n    \n    // 2. Create automated background service\n    console.log('ü§ñ Creating automated transfer background service...');\n    \n    const backgroundServiceCode = `import { ocrTransferService } from './ocrTransferService';\nimport { getFrameworkDbPool } from '../utils/dbConnections';\n\n/**\n * Automated OCR Transfer Background Service\n * Runs periodically to transfer completed OCR jobs\n */\nexport class OcrTransferBackgroundService {\n  private intervalId: NodeJS.Timer | null = null;\n  private isRunning = false;\n  \n  /**\n   * Start the automated transfer service\n   * @param intervalMinutes - How often to check for transfers (default: 5 minutes)\n   */\n  start(intervalMinutes: number = 5): void {\n    if (this.isRunning) {\n      console.log('‚ö†Ô∏è  OCR Transfer Background Service is already running');\n      return;\n    }\n    \n    console.log(\\`ü§ñ Starting OCR Transfer Background Service (interval: \\${intervalMinutes} minutes)\\`);\n    \n    this.isRunning = true;\n    \n    // Run immediately\n    this.runTransferCheck();\n    \n    // Set up interval\n    this.intervalId = setInterval(() => {\n      this.runTransferCheck();\n    }, intervalMinutes * 60 * 1000);\n  }\n  \n  /**\n   * Stop the automated transfer service\n   */\n  stop(): void {\n    if (!this.isRunning) {\n      console.log('‚ö†Ô∏è  OCR Transfer Background Service is not running');\n      return;\n    }\n    \n    console.log('üõë Stopping OCR Transfer Background Service');\n    \n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n      this.intervalId = null;\n    }\n    \n    this.isRunning = false;\n  }\n  \n  /**\n   * Check for completed OCR jobs and transfer them\n   */\n  private async runTransferCheck(): Promise<void> {\n    try {\n      console.log(\\`üîç [\\${new Date().toISOString()}] Checking for completed OCR jobs to transfer...\\`);\n      \n      // Get all active churches\n      const churches = await this.getActiveChurches();\n      \n      let totalTransfers = 0;\n      \n      for (const church of churches) {\n        try {\n          const transfers = await ocrTransferService.batchTransfer(church.id);\n          totalTransfers += transfers.length;\n          \n          if (transfers.length > 0) {\n            console.log(\\`‚úÖ Church \\${church.id} (\\${church.name}): \\${transfers.length} OCR jobs transferred\\`);\n          }\n        } catch (error) {\n          console.error(\\`‚ùå Failed batch transfer for church \\${church.id}:\\`, error);\n        }\n      }\n      \n      if (totalTransfers > 0) {\n        console.log(\\`üéâ Transfer check complete: \\${totalTransfers} total transfers\\`);\n      } else {\n        console.log(\\`‚ÑπÔ∏è  No OCR jobs ready for transfer\\`);\n      }\n      \n    } catch (error) {\n      console.error('‚ùå Error during transfer check:', error);\n    }\n  }\n  \n  /**\n   * Get list of active churches\n   */\n  private async getActiveChurches(): Promise<Array<{id: number, name: string}>> {\n    const frameworkPool = getFrameworkDbPool();\n    let connection = null;\n    \n    try {\n      connection = await frameworkPool.getConnection();\n      \n      const [rows] = await connection.execute(\n        \\`SELECT id, church_name as name FROM churches WHERE is_active = 1\\`\n      );\n      \n      return rows as Array<{id: number, name: string}>;\n      \n    } finally {\n      if (connection) connection.release();\n    }\n  }\n  \n  /**\n   * Get service status\n   */\n  getStatus(): {isRunning: boolean, uptime?: number} {\n    return {\n      isRunning: this.isRunning,\n      uptime: this.intervalId ? Date.now() : undefined\n    };\n  }\n}\n\n// Export singleton instance\nexport const ocrTransferBackgroundService = new OcrTransferBackgroundService();\n`;\n    \n    const backgroundServicePath = path.join(__dirname, '..', 'services', 'ocrTransferBackgroundService.ts');\n    await fs.writeFile(backgroundServicePath, backgroundServiceCode);\n    console.log('‚úÖ Created automated background transfer service');\n    \n    // 3. Test the transfer service\n    console.log('üß™ Testing transfer service...');\n    \n    try {\n      // Check database connections\n      const connection1 = await mysql.createConnection({\n        host: 'localhost',\n        user: 'orthodoxapps',\n        password: '[REDACTED]',\n        database: 'saints_peter_and_paul_orthodox_church_db'\n      });\n      \n      const connection2 = await mysql.createConnection({\n        host: 'localhost',\n        user: 'orthodoxapps',\n        password: '[REDACTED]',\n        database: 'ssppoc_records_db'\n      });\n      \n      // Check for completed OCR jobs\n      const [ocrJobs] = await connection1.execute(\n        'SELECT id, status FROM ocr_jobs WHERE status = \"complete\" LIMIT 1'\n      );\n      \n      // Check new tables exist\n      const [tables] = await connection2.execute(\n        \"SELECT COUNT(*) as count FROM information_schema.tables WHERE table_schema = 'ssppoc_records_db' AND table_name IN ('ocr_processing_log', 'ocr_review_queue', 'ocr_job_transfers')\"\n      );\n      \n      await connection1.end();\n      await connection2.end();\n      \n      console.log(`   ‚úÖ OCR DB connection: Working`);\n      console.log(`   ‚úÖ Records DB connection: Working`);\n      console.log(`   ‚úÖ OCR tables: ${tables[0].count}/3 found`);\n      console.log(`   üìä Completed OCR jobs available: ${ocrJobs.length}`);\n      \n    } catch (error) {\n      console.log(`   ‚ö†Ô∏è  Test connection failed: ${error.message}`);\n    }\n    }\n    \n    console.log('================================================================================');\n    console.log('üéâ OCR Transfer Service Creation Complete!');\n    console.log('üìÅ Files created:');\n    console.log('   - server/services/ocrTransferService.ts');\n    console.log('   - server/services/ocrTransferBackgroundService.ts');\n    console.log('');\n    console.log('üîÑ Key Features:');\n    console.log('   - transferOcrResult() function for single transfers');\n    console.log('   - Batch transfer support for multiple jobs');\n    console.log('   - Automated background service with configurable intervals');\n    console.log('   - Full transaction support with rollback on errors');\n    console.log('   - Transfer status tracking and monitoring');\n    console.log('   - Auto-insertion detection based on confidence scores');\n    console.log('');\n    console.log('üìù Next step: Run phase2-create-field-mapping.js');\n    console.log('================================================================================');\n    \n  } catch (error) {\n    console.error('‚ùå OCR Transfer Service creation failed:', error.message);\n    process.exit(1);\n  }\n}\n\n// Run transfer service creation\ncreateTransferService().catch(console.error);\n"
    },
    "complexity": {
      "totalLines": 609,
      "codeLines": 437,
      "commentLines": 81,
      "commentRatio": 0.15637065637065636,
      "averageLineLength": 36.80694980694981
    },
    "lastAnalyzed": "2025-07-28T07:20:00.284Z"
  },
  "contentHash": "2fe3677d13daf7c5aa0532b760829108cdf0f97ec216b3c59d089303a2479717",
  "discoveredAt": "2025-07-28T07:20:00.284Z"
}