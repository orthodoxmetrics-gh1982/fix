{
  "id": "586c48761dd5",
  "originalPath": "/var/www/orthodox-church-mgmt/orthodoxmetrics/prod/front-end/src/ai/vrt/vrtConfigManager.ts",
  "relativePath": "front-end/src/ai/vrt/vrtConfigManager.ts",
  "name": "vrtConfigManager.ts",
  "extension": ".ts",
  "size": 16079,
  "modified": "2025-07-25T05:34:43.193Z",
  "created": "2025-07-25T05:34:41.806Z",
  "classification": {
    "type": "Configuration",
    "category": "Configuration",
    "confidence": 2
  },
  "metadata": {
    "fileStats": {
      "lines": 536,
      "characters": 16079,
      "words": 1505
    },
    "classification": {
      "type": "Configuration",
      "category": "Configuration",
      "confidence": 2
    },
    "dependencies": [],
    "security": {
      "findings": [
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 508,
          "redacted": true
        }
      ],
      "hasSecurityIssues": true,
      "redactedContent": "// VRT Configuration Manager\r\n// Centralizes configuration management for all VRT modules and coordinates logging\r\n\r\nimport { SnapshotConfig } from '../visualTesting/snapshotEngine';\r\nimport { DiffConfig } from '../visualTesting/diffAnalyzer';\r\nimport { ConfidenceConfig } from '../visualTesting/confidenceAdjuster';\r\nimport { PlaywrightConfig } from '../visualTesting/playwrightTests';\r\nimport { LearningConfig } from '../learning/regressionFeedback';\r\nimport { vrtSecurity, VRTUser, logVRTAction } from './vrtSecurity';\r\n\r\nexport interface VRTMasterConfig {\r\n  snapshot: SnapshotConfig;\r\n  diff: DiffConfig;\r\n  confidence: ConfidenceConfig;\r\n  playwright: PlaywrightConfig;\r\n  learning: LearningConfig;\r\n  security: {\r\n    enabledInProduction: boolean;\r\n    requireSuperAdmin: boolean;\r\n    auditLogging: boolean;\r\n    maxSnapshotRetention: number;\r\n    maxAuditLogRetention: number;\r\n    rateLimitPerHour: number;\r\n  };\r\n  system: {\r\n    version: string;\r\n    lastUpdated: string;\r\n    environment: 'development' | 'staging' | 'production';\r\n    debugMode: boolean;\r\n    performanceLogging: boolean;\r\n  };\r\n}\r\n\r\nexport interface VRTConfigEvent {\r\n  timestamp: string;\r\n  user: string;\r\n  action: 'CONFIG_LOADED' | 'CONFIG_SAVED' | 'CONFIG_RESET' | 'CONFIG_VALIDATED' | 'CONFIG_ERROR';\r\n  module: string;\r\n  changes?: Record<string, any>;\r\n  errors?: string[];\r\n  success: boolean;\r\n}\r\n\r\nexport class VRTConfigManager {\r\n  private static instance: VRTConfigManager;\r\n  private config: VRTMasterConfig;\r\n  private configEvents: VRTConfigEvent[] = [];\r\n  private storageKey = 'vrt_master_config';\r\n  private eventsKey = 'vrt_config_events';\r\n  private currentUser: VRTUser | null = null;\r\n\r\n  private constructor() {\r\n    this.config = this.loadDefaultConfig();\r\n    this.loadPersistedConfig();\r\n    this.loadConfigEvents();\r\n    this.validateConfig();\r\n  }\r\n\r\n  public static getInstance(): VRTConfigManager {\r\n    if (!VRTConfigManager.instance) {\r\n      VRTConfigManager.instance = new VRTConfigManager();\r\n    }\r\n    return VRTConfigManager.instance;\r\n  }\r\n\r\n  /**\r\n   * Set current user for logging and security\r\n   */\r\n  public setUser(user: VRTUser | null): void {\r\n    this.currentUser = user;\r\n  }\r\n\r\n  /**\r\n   * Get complete VRT configuration\r\n   */\r\n  public getConfig(): VRTMasterConfig {\r\n    return JSON.parse(JSON.stringify(this.config)); // Deep clone\r\n  }\r\n\r\n  /**\r\n   * Get specific module configuration\r\n   */\r\n  public getModuleConfig<T extends keyof VRTMasterConfig>(module: T): VRTMasterConfig[T] {\r\n    return JSON.parse(JSON.stringify(this.config[module]));\r\n  }\r\n\r\n  /**\r\n   * Update configuration for a specific module\r\n   */\r\n  public async updateModuleConfig<T extends keyof VRTMasterConfig>(\r\n    module: T,\r\n    newConfig: Partial<VRTMasterConfig[T]>,\r\n    user?: VRTUser\r\n  ): Promise<{ success: boolean; errors?: string[] }> {\r\n    const effectiveUser = user || this.currentUser;\r\n    \r\n    try {\r\n      // Validate the new configuration\r\n      const validationResult = this.validateModuleConfig(module, newConfig);\r\n      if (!validationResult.valid) {\r\n        await this.logConfigEvent({\r\n          action: 'CONFIG_ERROR',\r\n          module: module as string,\r\n          errors: validationResult.errors,\r\n          success: false\r\n        }, effectiveUser);\r\n        \r\n        return { success: false, errors: validationResult.errors };\r\n      }\r\n\r\n      // Store old config for logging\r\n      const oldConfig = { ...this.config[module] };\r\n\r\n      // Update the configuration\r\n      this.config[module] = {\r\n        ...this.config[module],\r\n        ...newConfig\r\n      } as VRTMasterConfig[T];\r\n\r\n      // Update system metadata\r\n      this.config.system.lastUpdated = new Date().toISOString();\r\n\r\n      // Persist the configuration\r\n      await this.persistConfig();\r\n\r\n      // Log the configuration change\r\n      await this.logConfigEvent({\r\n        action: 'CONFIG_SAVED',\r\n        module: module as string,\r\n        changes: this.getConfigDiff(oldConfig, this.config[module]),\r\n        success: true\r\n      }, effectiveUser);\r\n\r\n      // Also log via VRT security system\r\n      if (effectiveUser) {\r\n        await logVRTAction(effectiveUser, 'SETTINGS_UPDATE', {\r\n          module: module as string,\r\n          configUpdated: Object.keys(newConfig),\r\n          timestamp: new Date().toISOString()\r\n        });\r\n      }\r\n\r\n      console.log(`[VRT Config] Successfully updated ${module} configuration`, {\r\n        changes: Object.keys(newConfig),\r\n        timestamp: this.config.system.lastUpdated\r\n      });\r\n\r\n      return { success: true };\r\n\r\n    } catch (error) {\r\n      const errorMessage = error instanceof Error ? error.message : 'Unknown configuration error';\r\n      \r\n      await this.logConfigEvent({\r\n        action: 'CONFIG_ERROR',\r\n        module: module as string,\r\n        errors: [errorMessage],\r\n        success: false\r\n      }, effectiveUser);\r\n\r\n      console.error(`[VRT Config] Failed to update ${module} configuration:`, error);\r\n      return { success: false, errors: [errorMessage] };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Reset configuration to defaults\r\n   */\r\n  public async resetConfig(user?: VRTUser): Promise<{ success: boolean; errors?: string[] }> {\r\n    const effectiveUser = user || this.currentUser;\r\n    \r\n    try {\r\n      const oldConfig = { ...this.config };\r\n      this.config = this.loadDefaultConfig();\r\n      this.config.system.lastUpdated = new Date().toISOString();\r\n\r\n      await this.persistConfig();\r\n\r\n      await this.logConfigEvent({\r\n        action: 'CONFIG_RESET',\r\n        module: 'ALL',\r\n        changes: { reset_to_defaults: true },\r\n        success: true\r\n      }, effectiveUser);\r\n\r\n      if (effectiveUser) {\r\n        await logVRTAction(effectiveUser, 'SETTINGS_UPDATE', {\r\n          action: 'config_reset_all_modules',\r\n          timestamp: new Date().toISOString()\r\n        });\r\n      }\r\n\r\n      console.log('[VRT Config] Configuration reset to defaults');\r\n      return { success: true };\r\n\r\n    } catch (error) {\r\n      const errorMessage = error instanceof Error ? error.message : 'Failed to reset configuration';\r\n      \r\n      await this.logConfigEvent({\r\n        action: 'CONFIG_ERROR',\r\n        module: 'ALL',\r\n        errors: [errorMessage],\r\n        success: false\r\n      }, effectiveUser);\r\n\r\n      return { success: false, errors: [errorMessage] };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get configuration events for audit purposes\r\n   */\r\n  public getConfigEvents(\r\n    module?: string,\r\n    action?: VRTConfigEvent['action'],\r\n    startDate?: Date,\r\n    endDate?: Date\r\n  ): VRTConfigEvent[] {\r\n    let events = [...this.configEvents];\r\n\r\n    if (module && module !== 'ALL') {\r\n      events = events.filter(event => event.module === module);\r\n    }\r\n\r\n    if (action) {\r\n      events = events.filter(event => event.action === action);\r\n    }\r\n\r\n    if (startDate) {\r\n      events = events.filter(event => new Date(event.timestamp) >= startDate);\r\n    }\r\n\r\n    if (endDate) {\r\n      events = events.filter(event => new Date(event.timestamp) <= endDate);\r\n    }\r\n\r\n    return events.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());\r\n  }\r\n\r\n  /**\r\n   * Export configuration as JSON\r\n   */\r\n  public exportConfig(): string {\r\n    const exportData = {\r\n      config: this.config,\r\n      exported: new Date().toISOString(),\r\n      version: this.config.system.version,\r\n      environment: this.config.system.environment\r\n    };\r\n\r\n    return JSON.stringify(exportData, null, 2);\r\n  }\r\n\r\n  /**\r\n   * Import configuration from JSON\r\n   */\r\n  public async importConfig(configJson: string, user?: VRTUser): Promise<{ success: boolean; errors?: string[] }> {\r\n    const effectiveUser = user || this.currentUser;\r\n    \r\n    try {\r\n      const importData = JSON.parse(configJson);\r\n      \r\n      if (!importData.config) {\r\n        throw new Error('Invalid configuration format: missing config object');\r\n      }\r\n\r\n      // Validate the imported configuration\r\n      const validationResult = this.validateCompleteConfig(importData.config);\r\n      if (!validationResult.valid) {\r\n        return { success: false, errors: validationResult.errors };\r\n      }\r\n\r\n      const oldConfig = { ...this.config };\r\n      this.config = {\r\n        ...importData.config,\r\n        system: {\r\n          ...importData.config.system,\r\n          lastUpdated: new Date().toISOString()\r\n        }\r\n      };\r\n\r\n      await this.persistConfig();\r\n\r\n      await this.logConfigEvent({\r\n        action: 'CONFIG_LOADED',\r\n        module: 'ALL',\r\n        changes: { imported_from: importData.exported || 'unknown' },\r\n        success: true\r\n      }, effectiveUser);\r\n\r\n      if (effectiveUser) {\r\n        await logVRTAction(effectiveUser, 'SETTINGS_UPDATE', {\r\n          action: 'config_imported',\r\n          sourceVersion: importData.version,\r\n          sourceEnvironment: importData.environment,\r\n          timestamp: new Date().toISOString()\r\n        });\r\n      }\r\n\r\n      console.log('[VRT Config] Configuration imported successfully');\r\n      return { success: true };\r\n\r\n    } catch (error) {\r\n      const errorMessage = error instanceof Error ? error.message : 'Failed to import configuration';\r\n      \r\n      await this.logConfigEvent({\r\n        action: 'CONFIG_ERROR',\r\n        module: 'ALL',\r\n        errors: [errorMessage],\r\n        success: false\r\n      }, effectiveUser);\r\n\r\n      return { success: false, errors: [errorMessage] };\r\n    }\r\n  }\r\n\r\n  // Private helper methods\r\n\r\n  private loadDefaultConfig(): VRTMasterConfig {\r\n    return {\r\n      snapshot: {\r\n        enabled: true,\r\n        retentionDays: 30,\r\n        breakpoints: {\r\n          desktop: { width: 1920, height: 1080 },\r\n          tablet: { width: 768, height: 1024 },\r\n          mobile: { width: 375, height: 667 }\r\n        },\r\n        quality: 0.9,\r\n        format: 'png'\r\n      },\r\n      diff: {\r\n        sensitivity: 0.05,\r\n        ignoreRegions: [],\r\n        colorThreshold: 10,\r\n        pixelThreshold: 0.01\r\n      },\r\n      confidence: {\r\n        enabled: true,\r\n        baselineConfidence: 0.8,\r\n        diffThreshold: 0.1,\r\n        learningRate: 0.1\r\n      },\r\n      playwright: {\r\n        enabled: true,\r\n        timeout: 30000,\r\n        browsers: ['chromium', 'firefox'],\r\n        retries: 2\r\n      },\r\n      learning: {\r\n        enabled: true,\r\n        minSamples: 50,\r\n        learningRate: 0.1,\r\n        retentionDays: 90\r\n      },\r\n      security: {\r\n        enabledInProduction: false,\r\n        requireSuperAdmin: true,\r\n        auditLogging: true,\r\n        maxSnapshotRetention: 30,\r\n        maxAuditLogRetention: 90,\r\n        rateLimitPerHour: 100\r\n      },\r\n      system: {\r\n        version: '1.0.0',\r\n        lastUpdated: new Date().toISOString(),\r\n        environment: this.detectEnvironment(),\r\n        debugMode: this.detectEnvironment() === 'development',\r\n        performanceLogging: true\r\n      }\r\n    };\r\n  }\r\n\r\n  private loadPersistedConfig(): void {\r\n    try {\r\n      const stored = localStorage.getItem(this.storageKey);\r\n      if (stored) {\r\n        const persistedConfig = JSON.parse(stored);\r\n        this.config = {\r\n          ...this.config,\r\n          ...persistedConfig,\r\n          system: {\r\n            ...this.config.system,\r\n            ...persistedConfig.system\r\n          }\r\n        };\r\n      }\r\n    } catch (error) {\r\n      console.warn('[VRT Config] Failed to load persisted configuration, using defaults');\r\n    }\r\n  }\r\n\r\n  private async persistConfig(): Promise<void> {\r\n    try {\r\n      localStorage.setItem(this.storageKey, JSON.stringify(this.config));\r\n    } catch (error) {\r\n      console.error('[VRT Config] Failed to persist configuration:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  private loadConfigEvents(): void {\r\n    try {\r\n      const stored = localStorage.getItem(this.eventsKey);\r\n      if (stored) {\r\n        this.configEvents = JSON.parse(stored);\r\n      }\r\n    } catch (error) {\r\n      console.warn('[VRT Config] Failed to load config events');\r\n      this.configEvents = [];\r\n    }\r\n  }\r\n\r\n  private async logConfigEvent(\r\n    event: Omit<VRTConfigEvent, 'timestamp' | 'user'>,\r\n    user?: VRTUser | null\r\n  ): Promise<void> {\r\n    const configEvent: VRTConfigEvent = {\r\n      ...event,\r\n      timestamp: new Date().toISOString(),\r\n      user: user?.name || 'system'\r\n    };\r\n\r\n    this.configEvents.push(configEvent);\r\n\r\n    // Keep only recent events to avoid storage bloat\r\n    if (this.configEvents.length > 500) {\r\n      this.configEvents = this.configEvents.slice(-500);\r\n    }\r\n\r\n    try {\r\n      localStorage.setItem(this.eventsKey, JSON.stringify(this.configEvents));\r\n    } catch (error) {\r\n      console.error('[VRT Config] Failed to save config event:', error);\r\n    }\r\n\r\n    console.log(`[VRT Config Event] ${event.action} - ${event.module}`, configEvent);\r\n  }\r\n\r\n  private validateConfig(): void {\r\n    const validationResult = this.validateCompleteConfig(this.config);\r\n    if (!validationResult.valid) {\r\n      console.warn('[VRT Config] Configuration validation failed:', validationResult.errors);\r\n      // Reset to defaults if validation fails\r\n      this.config = this.loadDefaultConfig();\r\n    }\r\n  }\r\n\r\n  private validateModuleConfig(module: string, config: any): { valid: boolean; errors?: string[] } {\r\n    const errors: string[] = [];\r\n\r\n    // Add specific validation logic for each module\r\n    switch (module) {\r\n      case 'snapshot':\r\n        if (config.quality && (config.quality < 0 || config.quality > 1)) {\r\n          errors.push('Snapshot quality must be between 0 and 1');\r\n        }\r\n        if (config.retentionDays && config.retentionDays < 1) {\r\n          errors.push('Retention days must be at least 1');\r\n        }\r\n        break;\r\n\r\n      case 'diff':\r\n        if (config.sensitivity && (config.sensitivity < 0 || config.sensitivity > 1)) {\r\n          errors.push('Diff sensitivity must be between 0 and 1');\r\n        }\r\n        break;\r\n\r\n      case 'security':\r\n        if (config.rateLimitPerHour && config.rateLimitPerHour < 1) {\r\n          errors.push('Rate limit must be at least 1 action per hour');\r\n        }\r\n        break;\r\n    }\r\n\r\n    return { valid: errors.length === 0, errors: errors.length > 0 ? errors : undefined };\r\n  }\r\n\r\n  private validateCompleteConfig(config: any): { valid: boolean; errors?: string[] } {\r\n    const errors: string[] = [];\r\n\r\n    // Validate required top-level properties\r\n    const requiredModules = ['snapshot', 'diff', 'confidence', 'playwright', 'learning', 'security', 'system'];\r\n    for (const module of requiredModules) {\r\n      if (!config[module]) {\r\n        errors.push(`Missing required module: ${module}`);\r\n      }\r\n    }\r\n\r\n    return { valid: errors.length === 0, errors: errors.length > 0 ? errors : undefined };\r\n  }\r\n\r\n  private getConfigDiff(oldConfig: any, newConfig: any): Record<string, any> {\r\n    const changes: Record<string, any> = {};\r\n    \r\n    for (const key in newConfig) {\r\n      if (oldConfig[key] !== newConfig[key]) {\r\n        changes[key] = {\r\n          from: oldConfig[key],\r\n          to: newConfig[key]\r\n        };\r\n      }\r\n    }\r\n\r\n    return changes;\r\n  }\r\n\r\n  private detectEnvironment(): 'development' | 'staging' | 'production' {\r\n    if (process.env.[REDACTED] === 'production') {\r\n      return 'production';\r\n    } else if (window.location.hostname.includes('staging')) {\r\n      return 'staging';\r\n    } else {\r\n      return 'development';\r\n    }\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const vrtConfigManager = VRTConfigManager.getInstance();\r\n\r\n// Helper functions for easy access\r\nexport function getVRTConfig(): VRTMasterConfig {\r\n  return vrtConfigManager.getConfig();\r\n}\r\n\r\nexport function getVRTModuleConfig<T extends keyof VRTMasterConfig>(module: T): VRTMasterConfig[T] {\r\n  return vrtConfigManager.getModuleConfig(module);\r\n}\r\n\r\nexport async function updateVRTConfig<T extends keyof VRTMasterConfig>(\r\n  module: T,\r\n  config: Partial<VRTMasterConfig[T]>,\r\n  user?: VRTUser\r\n): Promise<{ success: boolean; errors?: string[] }> {\r\n  return vrtConfigManager.updateModuleConfig(module, config, user);\r\n} "
    },
    "complexity": {
      "totalLines": 536,
      "codeLines": 416,
      "commentLines": 41,
      "commentRatio": 0.08971553610503283,
      "averageLineLength": 33.735229759299784
    },
    "lastAnalyzed": "2025-07-28T07:19:58.667Z"
  },
  "contentHash": "9aaa356cc17ff6a6ad07fb59f4b9fa58ec49cb3d85419fe152ab21e622424901",
  "discoveredAt": "2025-07-28T07:19:58.667Z"
}