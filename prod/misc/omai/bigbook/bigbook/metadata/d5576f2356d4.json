{
  "id": "d5576f2356d4",
  "originalPath": "/var/www/orthodox-church-mgmt/orthodoxmetrics/prod/server/utils/dbConnections.ts",
  "relativePath": "server/utils/dbConnections.ts",
  "name": "dbConnections.ts",
  "extension": ".ts",
  "size": 7704,
  "modified": "2025-07-24T14:51:40.492Z",
  "created": "2025-07-24T14:51:40.492Z",
  "classification": {
    "type": "Database Scripts",
    "category": "Backend > Database",
    "confidence": 3
  },
  "metadata": {
    "fileStats": {
      "lines": 312,
      "characters": 7700,
      "words": 865
    },
    "classification": {
      "type": "Database Scripts",
      "category": "Backend > Database",
      "confidence": 3
    },
    "dependencies": [
      {
        "type": "npm_package",
        "name": "mysql2/promise",
        "line": 7
      }
    ],
    "security": {
      "findings": [
        {
          "type": "sensitive_data",
          "pattern": "(?:password|pwd|pass)\\s*[:=]\\s*['\"]([^'\"]+)['\"]",
          "line": 14,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 45,
          "redacted": true
        }
      ],
      "hasSecurityIssues": true,
      "redactedContent": "/**\n * Cross-Database Connection Utilities for OCR System\n * Handles connections between orthodoxmetrics_db ↔ ssppoc_records_db ↔ orthodoxmetrics_ocr_db\n * Generated by Phase 1 setup script\n */\n\nimport mysql from 'mysql2/promise';\nimport { promisePool as centralPool } from '../config/db';\n\n// Database Configuration\nconst DB_CONFIG = {\n  host: 'localhost',\n  user: 'orthodoxapps',\n  password: '[REDACTED]',\n  charset: 'utf8mb4',\n  connectionLimit: 10,\n  acquireTimeout: 60000,\n  timeout: 60000\n};\n\n// Connection pools for each database\nlet recordsPool: mysql.Pool | null = null;\nlet ocrPool: mysql.Pool | null = null;\n\n/**\n * Get connection pool for Records Database (ssppoc_records_db)\n */\nexport function getRecordsDbPool(): mysql.Pool {\n  if (!recordsPool) {\n    recordsPool = mysql.createPool({\n      ...DB_CONFIG,\n      database: 'ssppoc_records_db'\n    });\n  }\n  return recordsPool;\n}\n\n/**\n * Get connection pool for OCR Processing Database (orthodoxmetrics_ocr_db)\n */\nexport function getOcrDbPool(): mysql.Pool {\n  if (!ocrPool) {\n    ocrPool = mysql.createPool({\n      ...DB_CONFIG,\n      database: process.env.[REDACTED] || 'orthodoxmetrics_ocr_db'\n    });\n  }\n  return ocrPool;\n}\n\n/**\n * Get single connection to Records Database\n */\nexport async function getRecordsDbConnection(): Promise<mysql.PoolConnection> {\n  const pool = getRecordsDbPool();\n  return await pool.getConnection();\n}\n\n/**\n * Get single connection to OCR Database  \n */\nexport async function getOcrDbConnection(): Promise<mysql.PoolConnection> {\n  const pool = getOcrDbPool();\n  return await pool.getConnection();\n}\n\n/**\n * Execute query on Records Database\n */\nexport async function executeRecordsQuery<T = any>(\n  query: string, \n  params: any[] = []\n): Promise<[T[], mysql.FieldPacket[]]> {\n  const pool = getRecordsDbPool();\n  return await pool.execute(query, params) as [T[], mysql.FieldPacket[]];\n}\n\n/**\n * Execute query on OCR Database\n */\nexport async function executeOcrQuery<T = any>(\n  query: string,\n  params: any[] = []\n): Promise<[T[], mysql.FieldPacket[]]> {\n  const pool = getOcrDbPool();\n  return await pool.execute(query, params) as [T[], mysql.FieldPacket[]];\n}\n\n/**\n * Execute query on Central Database (orthodoxmetrics_db)\n */\nexport async function executeCentralQuery<T = any>(\n  query: string,\n  params: any[] = []\n): Promise<[T[], mysql.FieldPacket[]]> {\n  return await centralPool.execute(query, params) as [T[], mysql.FieldPacket[]];\n}\n\n/**\n * Transaction wrapper for Records Database\n */\nexport async function withRecordsTransaction<T>(\n  callback: (connection: mysql.PoolConnection) => Promise<T>\n): Promise<T> {\n  const connection = await getRecordsDbConnection();\n  \n  try {\n    await connection.beginTransaction();\n    const result = await callback(connection);\n    await connection.commit();\n    return result;\n  } catch (error) {\n    await connection.rollback();\n    throw error;\n  } finally {\n    connection.release();\n  }\n}\n\n/**\n * Transaction wrapper for OCR Database\n */\nexport async function withOcrTransaction<T>(\n  callback: (connection: mysql.PoolConnection) => Promise<T>\n): Promise<T> {\n  const connection = await getOcrDbConnection();\n  \n  try {\n    await connection.beginTransaction();\n    const result = await callback(connection);\n    await connection.commit();\n    return result;\n  } catch (error) {\n    await connection.rollback();\n    throw error;\n  } finally {\n    connection.release();\n  }\n}\n\n/**\n * Cross-database transaction (Records + OCR)\n */\nexport async function withCrossDbTransaction<T>(\n  callback: (recordsConn: mysql.PoolConnection, ocrConn: mysql.PoolConnection) => Promise<T>\n): Promise<T> {\n  const recordsConnection = await getRecordsDbConnection();\n  const ocrConnection = await getOcrDbConnection();\n  \n  try {\n    await recordsConnection.beginTransaction();\n    await ocrConnection.beginTransaction();\n    \n    const result = await callback(recordsConnection, ocrConnection);\n    \n    await recordsConnection.commit();\n    await ocrConnection.commit();\n    \n    return result;\n  } catch (error) {\n    await recordsConnection.rollback();\n    await ocrConnection.rollback();\n    throw error;\n  } finally {\n    recordsConnection.release();\n    ocrConnection.release();\n  }\n}\n\n/**\n * Get church information from central database\n */\nexport async function getChurchInfo(churchId: number): Promise<any> {\n  const [rows] = await executeCentralQuery(\n    'SELECT * FROM churches WHERE id = ?',\n    [churchId]\n  );\n  \n  if (rows.length === 0) {\n    throw new Error(`Church not found: ${churchId}`);\n  }\n  \n  return rows[0];\n}\n\n/**\n * Validate user permissions for OCR operations\n */\nexport async function validateUserPermissions(\n  userId: number, \n  action: string,\n  churchId?: number\n): Promise<boolean> {\n  try {\n    // Get user role and permissions\n    const [userRows] = await executeCentralQuery(\n      `SELECT u.*, ur.role_name \n       FROM users u \n       LEFT JOIN user_roles ur ON u.role_id = ur.id \n       WHERE u.id = ?`,\n      [userId]\n    );\n    \n    if (userRows.length === 0) {\n      return false;\n    }\n    \n    const user = userRows[0];\n    \n    // Super admin can do everything\n    if (user.email === 'superadmin@orthodoxmetrics.com') {\n      return true;\n    }\n    \n    // Check church-specific permissions if churchId provided\n    if (churchId) {\n      const [permRows] = await executeCentralQuery(\n        `SELECT * FROM church_permissions \n         WHERE user_id = ? AND church_id = ? AND permission_type = ?`,\n        [userId, churchId, action]\n      );\n      \n      if (permRows.length > 0) {\n        return true;\n      }\n    }\n    \n    // Check role-based permissions\n    const rolePermissions: Record<string, string[]> = {\n      'admin': ['ocr_upload', 'ocr_review', 'ocr_approve', 'ocr_configure'],\n      'clergy': ['ocr_upload', 'ocr_review', 'ocr_approve'],\n      'volunteer': ['ocr_upload']\n    };\n    \n    const allowedActions = rolePermissions[user.role_name] || [];\n    return allowedActions.includes(action);\n    \n  } catch (error) {\n    console.error('Permission validation error:', error);\n    return false;\n  }\n}\n\n/**\n * Test all database connections\n */\nexport async function testConnections(): Promise<{ success: boolean; results: any }> {\n  const results = {\n    central: { connected: false, error: null },\n    records: { connected: false, error: null },\n    ocr: { connected: false, error: null }\n  };\n  \n  try {\n    // Test central database\n    const [centralRows] = await executeCentralQuery('SELECT 1 as test');\n    results.central.connected = true;\n  } catch (error) {\n    results.central.error = error.message;\n  }\n  \n  try {\n    // Test records database\n    const [recordsRows] = await executeRecordsQuery('SELECT 1 as test');\n    results.records.connected = true;\n  } catch (error) {\n    results.records.error = error.message;\n  }\n  \n  try {\n    // Test OCR database\n    const [ocrRows] = await executeOcrQuery('SELECT 1 as test');\n    results.ocr.connected = true;\n  } catch (error) {\n    results.ocr.error = error.message;\n  }\n  \n  const success = results.central.connected && results.records.connected && results.ocr.connected;\n  \n  return { success, results };\n}\n\n/**\n * Close all database connections\n */\nexport async function closeAllConnections(): Promise<void> {\n  const promises = [];\n  \n  if (recordsPool) {\n    promises.push(recordsPool.end());\n    recordsPool = null;\n  }\n  \n  if (ocrPool) {\n    promises.push(ocrPool.end());\n    ocrPool = null;\n  }\n  \n  await Promise.all(promises);\n}\n\n// Graceful shutdown\nprocess.on('SIGINT', async () => {\n  await closeAllConnections();\n  process.exit(0);\n});\n\nprocess.on('SIGTERM', async () => {\n  await closeAllConnections(); \n  process.exit(0);\n});\n"
    },
    "complexity": {
      "totalLines": 312,
      "codeLines": 211,
      "commentLines": 57,
      "commentRatio": 0.2126865671641791,
      "averageLineLength": 27.30223880597015
    },
    "lastAnalyzed": "2025-07-28T07:20:01.242Z"
  },
  "contentHash": "286536e27a8e396b1ce8d8a7771f67dacbd5afe45d305c411b782500ff060bc1",
  "discoveredAt": "2025-07-28T07:20:01.242Z"
}