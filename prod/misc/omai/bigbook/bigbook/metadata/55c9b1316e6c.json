{
  "id": "55c9b1316e6c",
  "originalPath": "/var/www/orthodox-church-mgmt/orthodoxmetrics/prod/backend/services/jitSessionManager.js",
  "relativePath": "backend/services/jitSessionManager.js",
  "name": "jitSessionManager.js",
  "extension": ".js",
  "size": 15431,
  "modified": "2025-07-25T06:05:28.026Z",
  "created": "2025-07-25T06:05:26.609Z",
  "classification": {
    "type": "Testing Scripts",
    "category": "DevOps > Test",
    "confidence": 1
  },
  "metadata": {
    "fileStats": {
      "lines": 518,
      "characters": 15431,
      "words": 1358
    },
    "classification": {
      "type": "Testing Scripts",
      "category": "DevOps > Test",
      "confidence": 1
    },
    "dependencies": [
      {
        "type": "npm_package",
        "name": "node-pty",
        "line": 4
      },
      {
        "type": "npm_package",
        "name": "fs",
        "line": 5
      },
      {
        "type": "npm_package",
        "name": "path",
        "line": 6
      },
      {
        "type": "npm_package",
        "name": "crypto",
        "line": 7
      },
      {
        "type": "npm_package",
        "name": "events",
        "line": 8
      }
    ],
    "security": {
      "findings": [
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 16,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 25,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 26,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 27,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 28,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 29,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 30,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 31,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 60,
          "redacted": true
        }
      ],
      "hasSecurityIssues": true,
      "redactedContent": "// JIT Session Manager Service\r\n// Manages PTY sessions, WebSocket connections, logging, and security for JIT Terminal\r\n\r\nconst pty = require('node-pty');\r\nconst fs = require('fs').promises;\r\nconst path = require('path');\r\nconst crypto = require('crypto');\r\nconst EventEmitter = require('events');\r\n\r\nclass JITSessionManager extends EventEmitter {\r\n  constructor() {\r\n    super();\r\n    this.sessions = new Map();\r\n    this.config = this.loadDefaultConfig();\r\n    this.auditLogs = [];\r\n    this.logDirectory = process.env.[REDACTED] || '/var/log/orthodoxmetrics';\r\n    this.ensureLogDirectory();\r\n    \r\n    // Cleanup expired sessions every minute\r\n    setInterval(() => this.cleanupExpiredSessions(), 60000);\r\n  }\r\n\r\n  loadDefaultConfig() {\r\n    return {\r\n      enabled: process.env.[REDACTED] === 'true',\r\n      allowInProduction: process.env.[REDACTED] === 'true',\r\n      sessionTimeoutMinutes: parseInt(process.env.[REDACTED]) || 10,\r\n      maxConcurrentSessions: parseInt(process.env.[REDACTED]) || 3,\r\n      requireReauth: process.env.[REDACTED] === 'true',\r\n      logCommands: process.env.[REDACTED] !== 'false',\r\n      logDirectory: process.env.[REDACTED] || '/var/log/orthodoxmetrics'\r\n    };\r\n  }\r\n\r\n  async ensureLogDirectory() {\r\n    try {\r\n      await fs.mkdir(this.logDirectory, { recursive: true });\r\n      await fs.mkdir(path.join(this.logDirectory, 'jit_sessions'), { recursive: true });\r\n    } catch (error) {\r\n      console.error('[JIT Manager] Failed to create log directory:', error);\r\n    }\r\n  }\r\n\r\n  generateSessionId() {\r\n    return 'jit-' + crypto.randomBytes(16).toString('hex');\r\n  }\r\n\r\n  async createSession(user, options = {}) {\r\n    const sessionId = this.generateSessionId();\r\n    const timeoutMinutes = options.timeoutMinutes || this.config.sessionTimeoutMinutes;\r\n    const startTime = Date.now();\r\n    const expiryTime = startTime + (timeoutMinutes * 60 * 1000);\r\n\r\n    // Create PTY process with elevated privileges\r\n    const shell = process.platform === 'win32' ? 'powershell.exe' : '/bin/bash';\r\n    const ptyProcess = pty.spawn(shell, [], {\r\n      name: 'xterm-color',\r\n      cols: 80,\r\n      rows: 24,\r\n      cwd: process.env.[REDACTED] || '/home/ubuntu',\r\n      env: {\r\n        ...process.env,\r\n        TERM: 'xterm-color',\r\n        JIT_SESSION_ID: sessionId,\r\n        JIT_USER_ID: user.id,\r\n        JIT_USER_NAME: user.name\r\n      }\r\n    });\r\n\r\n    const session = {\r\n      id: sessionId,\r\n      userId: user.id,\r\n      userName: user.name,\r\n      startTime,\r\n      expiryTime,\r\n      isActive: true,\r\n      commandCount: 0,\r\n      lastActivity: startTime,\r\n      ptyProcess,\r\n      websockets: new Set(),\r\n      logStream: null,\r\n      commandBuffer: '',\r\n      outputBuffer: ''\r\n    };\r\n\r\n    // Set up logging\r\n    if (this.config.logCommands) {\r\n      await this.setupSessionLogging(session);\r\n    }\r\n\r\n    // Set up PTY event handlers\r\n    this.setupPTYHandlers(session);\r\n\r\n    this.sessions.set(sessionId, session);\r\n\r\n    // Log session creation\r\n    await this.logAuditEvent({\r\n      action: 'SESSION_CREATED',\r\n      sessionId,\r\n      userId: user.id,\r\n      userName: user.name,\r\n      details: {\r\n        timeoutMinutes,\r\n        expiryTime,\r\n        shell\r\n      }\r\n    });\r\n\r\n    console.log(`[JIT Manager] Session created: ${sessionId} for user ${user.name} (expires in ${timeoutMinutes} minutes)`);\r\n\r\n    return {\r\n      id: sessionId,\r\n      userId: user.id,\r\n      userName: user.name,\r\n      startTime,\r\n      expiryTime,\r\n      isActive: true,\r\n      commandCount: 0,\r\n      lastActivity: startTime\r\n    };\r\n  }\r\n\r\n  async setupSessionLogging(session) {\r\n    const logFile = path.join(this.logDirectory, 'jit_sessions', `${session.id}.log`);\r\n    \r\n    try {\r\n      const logHeader = [\r\n        `JIT Terminal Session Log`,\r\n        `========================`,\r\n        `Session ID: ${session.id}`,\r\n        `User: ${session.userName} (${session.userId})`,\r\n        `Start Time: ${new Date(session.startTime).toISOString()}`,\r\n        `Shell: ${session.ptyProcess.process}`,\r\n        ``,\r\n        `Command Log:`,\r\n        `============`,\r\n        ``\r\n      ].join('\\n');\r\n\r\n      await fs.writeFile(logFile, logHeader);\r\n      \r\n      session.logFile = logFile;\r\n      console.log(`[JIT Manager] Session logging enabled: ${logFile}`);\r\n      \r\n    } catch (error) {\r\n      console.error(`[JIT Manager] Failed to setup logging for session ${session.id}:`, error);\r\n    }\r\n  }\r\n\r\n  setupPTYHandlers(session) {\r\n    // Handle PTY output\r\n    session.ptyProcess.onData((data) => {\r\n      session.lastActivity = Date.now();\r\n      session.outputBuffer += data;\r\n      \r\n      // Send to all connected WebSockets\r\n      const message = JSON.stringify({\r\n        type: 'output',\r\n        data: data\r\n      });\r\n      \r\n      session.websockets.forEach(ws => {\r\n        if (ws.readyState === 1) { // WebSocket.OPEN\r\n          ws.send(message);\r\n        }\r\n      });\r\n\r\n      // Log output if enabled\r\n      if (this.config.logCommands && session.logFile) {\r\n        this.appendToSessionLog(session, `[OUTPUT] ${data}`);\r\n      }\r\n    });\r\n\r\n    // Handle PTY exit\r\n    session.ptyProcess.onExit((exitCode, signal) => {\r\n      console.log(`[JIT Manager] PTY process exited for session ${session.id}: code=${exitCode}, signal=${signal}`);\r\n      this.terminateSession(session.id, null, `PTY process exited (code: ${exitCode})`);\r\n    });\r\n  }\r\n\r\n  async attachWebSocket(sessionId, ws) {\r\n    const session = this.sessions.get(sessionId);\r\n    if (!session || !session.isActive) {\r\n      throw new Error('Session not found or inactive');\r\n    }\r\n\r\n    session.websockets.add(ws);\r\n    session.lastActivity = Date.now();\r\n\r\n    // Handle WebSocket messages (terminal input)\r\n    ws.on('message', async (message) => {\r\n      try {\r\n        const data = JSON.parse(message);\r\n        \r\n        if (data.type === 'input') {\r\n          session.ptyProcess.write(data.data);\r\n          session.lastActivity = Date.now();\r\n          \r\n          // Track commands (detect Enter key)\r\n          session.commandBuffer += data.data;\r\n          if (data.data.includes('\\r') || data.data.includes('\\n')) {\r\n            const command = session.commandBuffer.trim();\r\n            if (command) {\r\n              session.commandCount++;\r\n              \r\n              // Log command\r\n              if (this.config.logCommands) {\r\n                await this.logCommand(session, command);\r\n              }\r\n              \r\n              // Send command logged event\r\n              const commandMessage = JSON.stringify({\r\n                type: 'command_logged',\r\n                command: command\r\n              });\r\n              \r\n              session.websockets.forEach(clientWs => {\r\n                if (clientWs.readyState === 1) {\r\n                  clientWs.send(commandMessage);\r\n                }\r\n              });\r\n            }\r\n            session.commandBuffer = '';\r\n          }\r\n        }\r\n      } catch (error) {\r\n        console.error(`[JIT Manager] WebSocket message error for session ${sessionId}:`, error);\r\n      }\r\n    });\r\n\r\n    // Handle WebSocket close\r\n    ws.on('close', () => {\r\n      session.websockets.delete(ws);\r\n      console.log(`[JIT Manager] WebSocket disconnected from session ${sessionId}`);\r\n    });\r\n\r\n    // Handle WebSocket error\r\n    ws.on('error', (error) => {\r\n      console.error(`[JIT Manager] WebSocket error for session ${sessionId}:`, error);\r\n      session.websockets.delete(ws);\r\n    });\r\n\r\n    console.log(`[JIT Manager] WebSocket attached to session ${sessionId}`);\r\n  }\r\n\r\n  async logCommand(session, command) {\r\n    try {\r\n      const timestamp = new Date().toISOString();\r\n      const logEntry = `[${timestamp}] [COMMAND] ${command}\\n`;\r\n      \r\n      await fs.appendFile(session.logFile, logEntry);\r\n      \r\n      // Also log to audit system\r\n      await this.logAuditEvent({\r\n        action: 'COMMAND_EXECUTED',\r\n        sessionId: session.id,\r\n        userId: session.userId,\r\n        userName: session.userName,\r\n        details: {\r\n          command,\r\n          timestamp\r\n        }\r\n      });\r\n      \r\n    } catch (error) {\r\n      console.error(`[JIT Manager] Failed to log command for session ${session.id}:`, error);\r\n    }\r\n  }\r\n\r\n  async appendToSessionLog(session, data) {\r\n    if (!session.logFile) return;\r\n    \r\n    try {\r\n      const timestamp = new Date().toISOString();\r\n      const logEntry = `[${timestamp}] ${data}\\n`;\r\n      await fs.appendFile(session.logFile, logEntry);\r\n    } catch (error) {\r\n      console.error(`[JIT Manager] Failed to append to session log ${session.id}:`, error);\r\n    }\r\n  }\r\n\r\n  async terminateSession(sessionId, user = null, reason = 'Manual termination') {\r\n    const session = this.sessions.get(sessionId);\r\n    if (!session) {\r\n      throw new Error('Session not found');\r\n    }\r\n\r\n    session.isActive = false;\r\n\r\n    // Close all WebSocket connections\r\n    session.websockets.forEach(ws => {\r\n      if (ws.readyState === 1) {\r\n        ws.send(JSON.stringify({\r\n          type: 'session_expired'\r\n        }));\r\n        ws.close(1000, 'Session terminated');\r\n      }\r\n    });\r\n    session.websockets.clear();\r\n\r\n    // Kill PTY process\r\n    try {\r\n      session.ptyProcess.kill();\r\n    } catch (error) {\r\n      console.error(`[JIT Manager] Failed to kill PTY process for session ${sessionId}:`, error);\r\n    }\r\n\r\n    // Finalize session log\r\n    if (session.logFile) {\r\n      const endLog = [\r\n        ``,\r\n        `Session End:`,\r\n        `============`,\r\n        `End Time: ${new Date().toISOString()}`,\r\n        `Reason: ${reason}`,\r\n        `Commands Executed: ${session.commandCount}`,\r\n        `Duration: ${Math.round((Date.now() - session.startTime) / 1000)} seconds`,\r\n        ``\r\n      ].join('\\n');\r\n      \r\n      try {\r\n        await fs.appendFile(session.logFile, endLog);\r\n      } catch (error) {\r\n        console.error(`[JIT Manager] Failed to finalize session log ${sessionId}:`, error);\r\n      }\r\n    }\r\n\r\n    // Log session termination\r\n    await this.logAuditEvent({\r\n      action: 'SESSION_TERMINATED',\r\n      sessionId,\r\n      userId: session.userId,\r\n      userName: session.userName,\r\n      details: {\r\n        reason,\r\n        duration: Date.now() - session.startTime,\r\n        commandCount: session.commandCount,\r\n        terminatedBy: user ? user.name : 'system'\r\n      }\r\n    });\r\n\r\n    this.sessions.delete(sessionId);\r\n    console.log(`[JIT Manager] Session terminated: ${sessionId} (${reason})`);\r\n  }\r\n\r\n  async cleanupExpiredSessions() {\r\n    const now = Date.now();\r\n    const expiredSessions = [];\r\n\r\n    for (const [sessionId, session] of this.sessions) {\r\n      if (session.isActive && now > session.expiryTime) {\r\n        expiredSessions.push(sessionId);\r\n      }\r\n    }\r\n\r\n    for (const sessionId of expiredSessions) {\r\n      await this.terminateSession(sessionId, null, 'Session expired');\r\n    }\r\n\r\n    if (expiredSessions.length > 0) {\r\n      console.log(`[JIT Manager] Cleaned up ${expiredSessions.length} expired sessions`);\r\n    }\r\n  }\r\n\r\n  async getSession(sessionId) {\r\n    const session = this.sessions.get(sessionId);\r\n    if (!session) return null;\r\n\r\n    return {\r\n      id: session.id,\r\n      userId: session.userId,\r\n      userName: session.userName,\r\n      startTime: session.startTime,\r\n      expiryTime: session.expiryTime,\r\n      isActive: session.isActive,\r\n      commandCount: session.commandCount,\r\n      lastActivity: session.lastActivity\r\n    };\r\n  }\r\n\r\n  async getSessions(userId = null, includeAll = false) {\r\n    const sessions = [];\r\n    \r\n    for (const session of this.sessions.values()) {\r\n      // Filter by user unless includeAll is true (for super_admin)\r\n      if (!includeAll && session.userId !== userId) {\r\n        continue;\r\n      }\r\n\r\n      sessions.push({\r\n        id: session.id,\r\n        userId: session.userId,\r\n        userName: session.userName,\r\n        startTime: session.startTime,\r\n        expiryTime: session.expiryTime,\r\n        isActive: session.isActive,\r\n        commandCount: session.commandCount,\r\n        lastActivity: session.lastActivity\r\n      });\r\n    }\r\n\r\n    return sessions.sort((a, b) => b.startTime - a.startTime);\r\n  }\r\n\r\n  async getActiveSessions(userId) {\r\n    const sessions = await this.getSessions(userId);\r\n    return sessions.filter(session => session.isActive);\r\n  }\r\n\r\n  async getSessionLogPath(sessionId) {\r\n    const session = this.sessions.get(sessionId);\r\n    if (!session) {\r\n      // Check if log file exists for historical session\r\n      const logFile = path.join(this.logDirectory, 'jit_sessions', `${sessionId}.log`);\r\n      return logFile;\r\n    }\r\n    \r\n    return session.logFile;\r\n  }\r\n\r\n  async getConfig() {\r\n    return { ...this.config };\r\n  }\r\n\r\n  async updateConfig(newConfig, user) {\r\n    const oldConfig = { ...this.config };\r\n    this.config = { ...this.config, ...newConfig };\r\n\r\n    // Update log directory if changed\r\n    if (newConfig.logDirectory && newConfig.logDirectory !== oldConfig.logDirectory) {\r\n      this.logDirectory = newConfig.logDirectory;\r\n      await this.ensureLogDirectory();\r\n    }\r\n\r\n    // Log configuration change\r\n    await this.logAuditEvent({\r\n      action: 'CONFIG_UPDATED',\r\n      userId: user ? user.id : 'system',\r\n      userName: user ? user.name : 'system',\r\n      details: {\r\n        oldConfig,\r\n        newConfig,\r\n        changedFields: Object.keys(newConfig)\r\n      }\r\n    });\r\n\r\n    console.log(`[JIT Manager] Configuration updated by ${user ? user.name : 'system'}`);\r\n  }\r\n\r\n  async logAuditEvent(event) {\r\n    const auditEntry = {\r\n      id: crypto.randomUUID(),\r\n      timestamp: new Date().toISOString(),\r\n      ...event\r\n    };\r\n\r\n    this.auditLogs.push(auditEntry);\r\n\r\n    // Keep only recent audit logs in memory\r\n    if (this.auditLogs.length > 1000) {\r\n      this.auditLogs = this.auditLogs.slice(-1000);\r\n    }\r\n\r\n    // Write to audit log file\r\n    try {\r\n      const auditLogFile = path.join(this.logDirectory, 'jit_terminal.log');\r\n      const logLine = JSON.stringify(auditEntry) + '\\n';\r\n      await fs.appendFile(auditLogFile, logLine);\r\n    } catch (error) {\r\n      console.error('[JIT Manager] Failed to write audit log:', error);\r\n    }\r\n  }\r\n\r\n  async getAuditLogs(filters = {}) {\r\n    let logs = [...this.auditLogs];\r\n\r\n    if (filters.userId) {\r\n      logs = logs.filter(log => log.userId === filters.userId);\r\n    }\r\n\r\n    if (filters.action) {\r\n      logs = logs.filter(log => log.action === filters.action);\r\n    }\r\n\r\n    if (filters.startDate) {\r\n      logs = logs.filter(log => new Date(log.timestamp) >= filters.startDate);\r\n    }\r\n\r\n    if (filters.endDate) {\r\n      logs = logs.filter(log => new Date(log.timestamp) <= filters.endDate);\r\n    }\r\n\r\n    return logs.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());\r\n  }\r\n\r\n  // Graceful shutdown\r\n  async shutdown() {\r\n    console.log('[JIT Manager] Shutting down...');\r\n    \r\n    const sessionIds = Array.from(this.sessions.keys());\r\n    for (const sessionId of sessionIds) {\r\n      await this.terminateSession(sessionId, null, 'System shutdown');\r\n    }\r\n\r\n    await this.logAuditEvent({\r\n      action: 'SYSTEM_SHUTDOWN',\r\n      userId: 'system',\r\n      userName: 'system',\r\n      details: {\r\n        sessionsTerminated: sessionIds.length\r\n      }\r\n    });\r\n\r\n    console.log('[JIT Manager] Shutdown complete');\r\n  }\r\n}\r\n\r\nmodule.exports = JITSessionManager; "
    },
    "complexity": {
      "totalLines": 518,
      "codeLines": 406,
      "commentLines": 29,
      "commentRatio": 0.06666666666666667,
      "averageLineLength": 33.79080459770115
    },
    "lastAnalyzed": "2025-07-28T07:19:56.504Z"
  },
  "contentHash": "5a40e0152c183928db3b78947614fef8aa97125d7bf72250e47ad4d436332bbe",
  "discoveredAt": "2025-07-28T07:19:56.504Z"
}