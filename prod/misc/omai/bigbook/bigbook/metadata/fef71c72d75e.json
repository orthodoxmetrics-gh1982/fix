{
  "id": "fef71c72d75e",
  "originalPath": "/var/www/orthodox-church-mgmt/orthodoxmetrics/prod/bigbook/metadata/d5576f2356d4.json",
  "relativePath": "bigbook/metadata/d5576f2356d4.json",
  "name": "d5576f2356d4.json",
  "extension": ".json",
  "size": 9643,
  "modified": "2025-07-26T04:17:11.770Z",
  "created": "2025-07-26T04:17:11.770Z",
  "classification": {
    "type": "Configuration",
    "category": "Configuration",
    "confidence": 3
  },
  "metadata": {
    "fileStats": {
      "lines": 62,
      "characters": 9639,
      "words": 948
    },
    "classification": {
      "type": "Configuration",
      "category": "Configuration",
      "confidence": 3
    },
    "dependencies": [],
    "security": {
      "findings": [
        {
          "type": "sensitive_data",
          "pattern": "(?:password|pwd|pass)\\s*[:=]\\s*['\"]([^'\"]+)['\"]",
          "line": 49,
          "redacted": true
        }
      ],
      "hasSecurityIssues": true,
      "redactedContent": "{\n  \"id\": \"d5576f2356d4\",\n  \"originalPath\": \"/var/www/orthodox-church-mgmt/orthodoxmetrics/prod/server/utils/dbConnections.ts\",\n  \"relativePath\": \"server/utils/dbConnections.ts\",\n  \"name\": \"dbConnections.ts\",\n  \"extension\": \".ts\",\n  \"size\": 7704,\n  \"modified\": \"2025-07-24T14:51:40.492Z\",\n  \"created\": \"2025-07-24T14:51:40.492Z\",\n  \"classification\": {\n    \"type\": \"Database Scripts\",\n    \"category\": \"Backend > Database\",\n    \"confidence\": 3\n  },\n  \"metadata\": {\n    \"fileStats\": {\n      \"lines\": 312,\n      \"characters\": 7700,\n      \"words\": 865\n    },\n    \"classification\": {\n      \"type\": \"Database Scripts\",\n      \"category\": \"Backend > Database\",\n      \"confidence\": 3\n    },\n    \"dependencies\": [\n      {\n        \"type\": \"npm_package\",\n        \"name\": \"mysql2/promise\",\n        \"line\": 7\n      }\n    ],\n    \"security\": {\n      \"findings\": [\n        {\n          \"type\": \"sensitive_data\",\n          \"pattern\": \"(?:password|pwd|pass)\\\\s*[:=]\\\\s*['\\\"]([^'\\\"]+)['\\\"]\",\n          \"line\": 14,\n          \"redacted\": true\n        },\n        {\n          \"type\": \"sensitive_data\",\n          \"pattern\": \"process\\\\.env\\\\.([A-Z_]+)\",\n          \"line\": 45,\n          \"redacted\": true\n        }\n      ],\n      \"hasSecurityIssues\": true,\n      \"redactedContent\": \"/**\\n * Cross-Database Connection Utilities for OCR System\\n * Handles connections between orthodoxmetrics_db ↔ ssppoc_records_db ↔ orthodoxmetrics_ocr_db\\n * Generated by Phase 1 setup script\\n */\\n\\nimport mysql from 'mysql2/promise';\\nimport { promisePool as centralPool } from '../config/db';\\n\\n// Database Configuration\\nconst DB_CONFIG = {\\n  host: 'localhost',\\n  user: 'orthodoxapps',\\n  password: '[REDACTED]',\\n  charset: 'utf8mb4',\\n  connectionLimit: 10,\\n  acquireTimeout: 60000,\\n  timeout: 60000\\n};\\n\\n// Connection pools for each database\\nlet recordsPool: mysql.Pool | null = null;\\nlet ocrPool: mysql.Pool | null = null;\\n\\n/**\\n * Get connection pool for Records Database (ssppoc_records_db)\\n */\\nexport function getRecordsDbPool(): mysql.Pool {\\n  if (!recordsPool) {\\n    recordsPool = mysql.createPool({\\n      ...DB_CONFIG,\\n      database: 'ssppoc_records_db'\\n    });\\n  }\\n  return recordsPool;\\n}\\n\\n/**\\n * Get connection pool for OCR Processing Database (orthodoxmetrics_ocr_db)\\n */\\nexport function getOcrDbPool(): mysql.Pool {\\n  if (!ocrPool) {\\n    ocrPool = mysql.createPool({\\n      ...DB_CONFIG,\\n      database: process.env.[REDACTED] || 'orthodoxmetrics_ocr_db'\\n    });\\n  }\\n  return ocrPool;\\n}\\n\\n/**\\n * Get single connection to Records Database\\n */\\nexport async function getRecordsDbConnection(): Promise<mysql.PoolConnection> {\\n  const pool = getRecordsDbPool();\\n  return await pool.getConnection();\\n}\\n\\n/**\\n * Get single connection to OCR Database  \\n */\\nexport async function getOcrDbConnection(): Promise<mysql.PoolConnection> {\\n  const pool = getOcrDbPool();\\n  return await pool.getConnection();\\n}\\n\\n/**\\n * Execute query on Records Database\\n */\\nexport async function executeRecordsQuery<T = any>(\\n  query: string, \\n  params: any[] = []\\n): Promise<[T[], mysql.FieldPacket[]]> {\\n  const pool = getRecordsDbPool();\\n  return await pool.execute(query, params) as [T[], mysql.FieldPacket[]];\\n}\\n\\n/**\\n * Execute query on OCR Database\\n */\\nexport async function executeOcrQuery<T = any>(\\n  query: string,\\n  params: any[] = []\\n): Promise<[T[], mysql.FieldPacket[]]> {\\n  const pool = getOcrDbPool();\\n  return await pool.execute(query, params) as [T[], mysql.FieldPacket[]];\\n}\\n\\n/**\\n * Execute query on Central Database (orthodoxmetrics_db)\\n */\\nexport async function executeCentralQuery<T = any>(\\n  query: string,\\n  params: any[] = []\\n): Promise<[T[], mysql.FieldPacket[]]> {\\n  return await centralPool.execute(query, params) as [T[], mysql.FieldPacket[]];\\n}\\n\\n/**\\n * Transaction wrapper for Records Database\\n */\\nexport async function withRecordsTransaction<T>(\\n  callback: (connection: mysql.PoolConnection) => Promise<T>\\n): Promise<T> {\\n  const connection = await getRecordsDbConnection();\\n  \\n  try {\\n    await connection.beginTransaction();\\n    const result = await callback(connection);\\n    await connection.commit();\\n    return result;\\n  } catch (error) {\\n    await connection.rollback();\\n    throw error;\\n  } finally {\\n    connection.release();\\n  }\\n}\\n\\n/**\\n * Transaction wrapper for OCR Database\\n */\\nexport async function withOcrTransaction<T>(\\n  callback: (connection: mysql.PoolConnection) => Promise<T>\\n): Promise<T> {\\n  const connection = await getOcrDbConnection();\\n  \\n  try {\\n    await connection.beginTransaction();\\n    const result = await callback(connection);\\n    await connection.commit();\\n    return result;\\n  } catch (error) {\\n    await connection.rollback();\\n    throw error;\\n  } finally {\\n    connection.release();\\n  }\\n}\\n\\n/**\\n * Cross-database transaction (Records + OCR)\\n */\\nexport async function withCrossDbTransaction<T>(\\n  callback: (recordsConn: mysql.PoolConnection, ocrConn: mysql.PoolConnection) => Promise<T>\\n): Promise<T> {\\n  const recordsConnection = await getRecordsDbConnection();\\n  const ocrConnection = await getOcrDbConnection();\\n  \\n  try {\\n    await recordsConnection.beginTransaction();\\n    await ocrConnection.beginTransaction();\\n    \\n    const result = await callback(recordsConnection, ocrConnection);\\n    \\n    await recordsConnection.commit();\\n    await ocrConnection.commit();\\n    \\n    return result;\\n  } catch (error) {\\n    await recordsConnection.rollback();\\n    await ocrConnection.rollback();\\n    throw error;\\n  } finally {\\n    recordsConnection.release();\\n    ocrConnection.release();\\n  }\\n}\\n\\n/**\\n * Get church information from central database\\n */\\nexport async function getChurchInfo(churchId: number): Promise<any> {\\n  const [rows] = await executeCentralQuery(\\n    'SELECT * FROM churches WHERE id = ?',\\n    [churchId]\\n  );\\n  \\n  if (rows.length === 0) {\\n    throw new Error(`Church not found: ${churchId}`);\\n  }\\n  \\n  return rows[0];\\n}\\n\\n/**\\n * Validate user permissions for OCR operations\\n */\\nexport async function validateUserPermissions(\\n  userId: number, \\n  action: string,\\n  churchId?: number\\n): Promise<boolean> {\\n  try {\\n    // Get user role and permissions\\n    const [userRows] = await executeCentralQuery(\\n      `SELECT u.*, ur.role_name \\n       FROM users u \\n       LEFT JOIN user_roles ur ON u.role_id = ur.id \\n       WHERE u.id = ?`,\\n      [userId]\\n    );\\n    \\n    if (userRows.length === 0) {\\n      return false;\\n    }\\n    \\n    const user = userRows[0];\\n    \\n    // Super admin can do everything\\n    if (user.email === 'superadmin@orthodoxmetrics.com') {\\n      return true;\\n    }\\n    \\n    // Check church-specific permissions if churchId provided\\n    if (churchId) {\\n      const [permRows] = await executeCentralQuery(\\n        `SELECT * FROM church_permissions \\n         WHERE user_id = ? AND church_id = ? AND permission_type = ?`,\\n        [userId, churchId, action]\\n      );\\n      \\n      if (permRows.length > 0) {\\n        return true;\\n      }\\n    }\\n    \\n    // Check role-based permissions\\n    const rolePermissions: Record<string, string[]> = {\\n      'admin': ['ocr_upload', 'ocr_review', 'ocr_approve', 'ocr_configure'],\\n      'clergy': ['ocr_upload', 'ocr_review', 'ocr_approve'],\\n      'volunteer': ['ocr_upload']\\n    };\\n    \\n    const allowedActions = rolePermissions[user.role_name] || [];\\n    return allowedActions.includes(action);\\n    \\n  } catch (error) {\\n    console.error('Permission validation error:', error);\\n    return false;\\n  }\\n}\\n\\n/**\\n * Test all database connections\\n */\\nexport async function testConnections(): Promise<{ success: boolean; results: any }> {\\n  const results = {\\n    central: { connected: false, error: null },\\n    records: { connected: false, error: null },\\n    ocr: { connected: false, error: null }\\n  };\\n  \\n  try {\\n    // Test central database\\n    const [centralRows] = await executeCentralQuery('SELECT 1 as test');\\n    results.central.connected = true;\\n  } catch (error) {\\n    results.central.error = error.message;\\n  }\\n  \\n  try {\\n    // Test records database\\n    const [recordsRows] = await executeRecordsQuery('SELECT 1 as test');\\n    results.records.connected = true;\\n  } catch (error) {\\n    results.records.error = error.message;\\n  }\\n  \\n  try {\\n    // Test OCR database\\n    const [ocrRows] = await executeOcrQuery('SELECT 1 as test');\\n    results.ocr.connected = true;\\n  } catch (error) {\\n    results.ocr.error = error.message;\\n  }\\n  \\n  const success = results.central.connected && results.records.connected && results.ocr.connected;\\n  \\n  return { success, results };\\n}\\n\\n/**\\n * Close all database connections\\n */\\nexport async function closeAllConnections(): Promise<void> {\\n  const promises = [];\\n  \\n  if (recordsPool) {\\n    promises.push(recordsPool.end());\\n    recordsPool = null;\\n  }\\n  \\n  if (ocrPool) {\\n    promises.push(ocrPool.end());\\n    ocrPool = null;\\n  }\\n  \\n  await Promise.all(promises);\\n}\\n\\n// Graceful shutdown\\nprocess.on('SIGINT', async () => {\\n  await closeAllConnections();\\n  process.exit(0);\\n});\\n\\nprocess.on('SIGTERM', async () => {\\n  await closeAllConnections(); \\n  process.exit(0);\\n});\\n\"\n    },\n    \"complexity\": {\n      \"totalLines\": 312,\n      \"codeLines\": 211,\n      \"commentLines\": 57,\n      \"commentRatio\": 0.2126865671641791,\n      \"averageLineLength\": 27.30223880597015\n    },\n    \"lastAnalyzed\": \"2025-07-26T04:17:11.773Z\"\n  },\n  \"contentHash\": \"286536e27a8e396b1ce8d8a7771f67dacbd5afe45d305c411b782500ff060bc1\",\n  \"discoveredAt\": \"2025-07-26T04:17:11.773Z\"\n}"
    },
    "complexity": {
      "totalLines": 62,
      "codeLines": 62,
      "commentLines": 0,
      "commentRatio": 0,
      "averageLineLength": 154.48387096774192
    },
    "lastAnalyzed": "2025-07-28T07:19:57.494Z"
  },
  "contentHash": "d43900b197c78562abb464491e98f9e1ce050b287c92393122a466bb8cee2816",
  "discoveredAt": "2025-07-28T07:19:57.494Z"
}