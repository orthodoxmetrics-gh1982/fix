{
  "id": "bc45e074f531",
  "originalPath": "/var/www/orthodox-church-mgmt/orthodoxmetrics/prod/server/database/database-manager.js",
  "relativePath": "server/database/database-manager.js",
  "name": "database-manager.js",
  "extension": ".js",
  "size": 19664,
  "modified": "2025-07-21T21:54:28.196Z",
  "created": "2025-07-18T18:57:46.991Z",
  "classification": {
    "type": "Database Scripts",
    "category": "Backend > Database",
    "confidence": 5
  },
  "metadata": {
    "fileStats": {
      "lines": 547,
      "characters": 19596,
      "words": 1662
    },
    "classification": {
      "type": "Database Scripts",
      "category": "Backend > Database",
      "confidence": 5
    },
    "dependencies": [
      {
        "type": "npm_package",
        "name": "mysql2/promise",
        "line": 9
      },
      {
        "type": "npm_package",
        "name": "fs",
        "line": 10
      },
      {
        "type": "npm_package",
        "name": "path",
        "line": 11
      }
    ],
    "security": {
      "findings": [
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 37,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 38,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 39,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 40,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 41,
          "redacted": true
        }
      ],
      "hasSecurityIssues": true,
      "redactedContent": "#!/usr/bin/env node\r\n\r\n/**\r\n * Orthodox Metrics - Database Management Suite\r\n * Consolidates: setup-ocr-tables.js, fix-database-tables.js, database-maintenance.js\r\n * Provides: Complete database management and maintenance\r\n */\r\n\r\nconst mysql = require('mysql2/promise');\r\nconst fs = require('fs').promises;\r\nconst path = require('path');\r\n\r\n// ANSI color codes\r\nconst colors = {\r\n  reset: '\\x1b[0m',\r\n  red: '\\x1b[31m',\r\n  green: '\\x1b[32m',\r\n  yellow: '\\x1b[33m',\r\n  blue: '\\x1b[34m',\r\n  cyan: '\\x1b[36m',\r\n};\r\n\r\nfunction colorLog(message, color = 'white') {\r\n  console.log(`${colors[color] || ''}${message}${colors.reset}`);\r\n}\r\n\r\nclass DatabaseManager {\r\n  constructor(options = {}) {\r\n    this.options = {\r\n      dryRun: false,\r\n      backup: true,\r\n      force: false,\r\n      ...options\r\n    };\r\n\r\n    this.dbConfig = {\r\n      host: process.env.[REDACTED] || 'localhost',\r\n      user: process.env.[REDACTED] || 'root',\r\n      password: process.env.[REDACTED],\r\n      database: process.env.[REDACTED] || 'orthodoxmetrics',\r\n      port: process.env.[REDACTED] || 3306,\r\n      multipleStatements: true\r\n    };\r\n  }\r\n\r\n  async getConnection() {\r\n    return await mysql.createConnection(this.dbConfig);\r\n  }\r\n\r\n  async executeQuery(connection, query, description) {\r\n    colorLog(`   Executing: ${description}`, 'blue');\r\n    \r\n    if (this.options.dryRun) {\r\n      colorLog(`   DRY RUN: ${query.substring(0, 100)}...`, 'yellow');\r\n      return { success: true, dryRun: true };\r\n    }\r\n\r\n    try {\r\n      const [result] = await connection.execute(query);\r\n      colorLog(`   ‚úÖ Success: ${description}`, 'green');\r\n      return { success: true, result };\r\n    } catch (error) {\r\n      colorLog(`   ‚ùå Failed: ${description} - ${error.message}`, 'red');\r\n      return { success: false, error };\r\n    }\r\n  }\r\n\r\n  async createBackup() {\r\n    if (!this.options.backup) {\r\n      colorLog('‚è≠Ô∏è  Skipping backup creation', 'yellow');\r\n      return;\r\n    }\r\n\r\n    colorLog('\\nüíæ Creating Database Backup...', 'cyan');\r\n    \r\n    const connection = await this.getConnection();\r\n    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\r\n    const backupDir = path.join(__dirname, '..', '..', 'backups');\r\n    \r\n    try {\r\n      await fs.mkdir(backupDir, { recursive: true });\r\n      \r\n      // Get all tables\r\n      const [tables] = await connection.execute('SHOW TABLES');\r\n      const tableNames = tables.map(row => Object.values(row)[0]);\r\n      \r\n      let backupSql = `-- Orthodox Metrics Database Backup\\n-- Created: ${new Date().toISOString()}\\n\\n`;\r\n      \r\n      for (const tableName of tableNames) {\r\n        // Get table structure\r\n        const [createTable] = await connection.execute(`SHOW CREATE TABLE \\`${tableName}\\``);\r\n        backupSql += `DROP TABLE IF EXISTS \\`${tableName}\\`;\\n`;\r\n        backupSql += `${createTable[0]['Create Table']};\\n\\n`;\r\n        \r\n        // Get table data\r\n        const [rows] = await connection.execute(`SELECT * FROM \\`${tableName}\\``);\r\n        if (rows.length > 0) {\r\n          backupSql += `INSERT INTO \\`${tableName}\\` VALUES\\n`;\r\n          const values = rows.map(row => {\r\n            const escapedValues = Object.values(row).map(value => {\r\n              if (value === null) return 'NULL';\r\n              if (typeof value === 'string') return `'${value.replace(/'/g, \"\\\\'\")}'`;\r\n              return value;\r\n            });\r\n            return `(${escapedValues.join(', ')})`;\r\n          });\r\n          backupSql += values.join(',\\n') + ';\\n\\n';\r\n        }\r\n      }\r\n      \r\n      const backupFile = path.join(backupDir, `orthodox_backup_${timestamp}.sql`);\r\n      await fs.writeFile(backupFile, backupSql);\r\n      \r\n      colorLog(`‚úÖ Backup created: ${backupFile}`, 'green');\r\n      \r\n    } catch (error) {\r\n      colorLog(`‚ùå Backup failed: ${error.message}`, 'red');\r\n      throw error;\r\n    } finally {\r\n      await connection.end();\r\n    }\r\n  }\r\n\r\n  async createSchema() {\r\n    colorLog('\\nüèóÔ∏è  Creating Database Schema...', 'cyan');\r\n    \r\n    const connection = await this.getConnection();\r\n    \r\n    try {\r\n      // Core tables\r\n      const coreSchemas = [\r\n        {\r\n          name: 'church_info',\r\n          sql: `\r\n            CREATE TABLE IF NOT EXISTS church_info (\r\n              id INT AUTO_INCREMENT PRIMARY KEY,\r\n              name VARCHAR(255) NOT NULL,\r\n              address TEXT,\r\n              phone VARCHAR(50),\r\n              email VARCHAR(255),\r\n              website VARCHAR(255),\r\n              priest_name VARCHAR(255),\r\n              parish_type ENUM('parish', 'cathedral', 'monastery') DEFAULT 'parish',\r\n              jurisdiction VARCHAR(255),\r\n              is_test_church BOOLEAN DEFAULT FALSE,\r\n              created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\r\n              updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP\r\n            ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci\r\n          `\r\n        },\r\n        // NOTE: Users are stored in orthodoxmetrics_db, not in individual church databases\r\n        // Church databases are for records only. User management is handled centrally.\r\n        // Use the church_users junction table in orthodoxmetrics_db to assign users to churches.\r\n        {\r\n          name: 'baptism_records',\r\n          sql: `\r\n            CREATE TABLE IF NOT EXISTS baptism_records (\r\n              id INT AUTO_INCREMENT PRIMARY KEY,\r\n              church_id INT NOT NULL,\r\n              record_number VARCHAR(50),\r\n              baptism_date DATE,\r\n              child_name VARCHAR(255),\r\n              child_birth_date DATE,\r\n              child_birth_place VARCHAR(255),\r\n              father_name VARCHAR(255),\r\n              mother_name VARCHAR(255),\r\n              godparent_1 VARCHAR(255),\r\n              godparent_2 VARCHAR(255),\r\n              priest_name VARCHAR(255),\r\n              notes TEXT,\r\n              original_language ENUM('greek', 'russian', 'romanian', 'english', 'other'),\r\n              translation_status ENUM('original', 'translated', 'reviewed') DEFAULT 'original',\r\n              created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\r\n              updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\r\n              FOREIGN KEY (church_id) REFERENCES church_info(id) ON DELETE CASCADE,\r\n              INDEX idx_church_record (church_id, record_number),\r\n              INDEX idx_baptism_date (baptism_date),\r\n              INDEX idx_child_name (child_name)\r\n            ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci\r\n          `\r\n        },\r\n        {\r\n          name: 'marriage_records',\r\n          sql: `\r\n            CREATE TABLE IF NOT EXISTS marriage_records (\r\n              id INT AUTO_INCREMENT PRIMARY KEY,\r\n              church_id INT NOT NULL,\r\n              record_number VARCHAR(50),\r\n              marriage_date DATE,\r\n              groom_name VARCHAR(255),\r\n              groom_birth_date DATE,\r\n              groom_birth_place VARCHAR(255),\r\n              bride_name VARCHAR(255),\r\n              bride_birth_date DATE,\r\n              bride_birth_place VARCHAR(255),\r\n              witness_1 VARCHAR(255),\r\n              witness_2 VARCHAR(255),\r\n              priest_name VARCHAR(255),\r\n              notes TEXT,\r\n              original_language ENUM('greek', 'russian', 'romanian', 'english', 'other'),\r\n              translation_status ENUM('original', 'translated', 'reviewed') DEFAULT 'original',\r\n              created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\r\n              updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\r\n              FOREIGN KEY (church_id) REFERENCES church_info(id) ON DELETE CASCADE,\r\n              INDEX idx_church_record (church_id, record_number),\r\n              INDEX idx_marriage_date (marriage_date),\r\n              INDEX idx_groom_name (groom_name),\r\n              INDEX idx_bride_name (bride_name)\r\n            ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci\r\n          `\r\n        },\r\n        {\r\n          name: 'funeral_records',\r\n          sql: `\r\n            CREATE TABLE IF NOT EXISTS funeral_records (\r\n              id INT AUTO_INCREMENT PRIMARY KEY,\r\n              church_id INT NOT NULL,\r\n              record_number VARCHAR(50),\r\n              death_date DATE,\r\n              burial_date DATE,\r\n              deceased_name VARCHAR(255),\r\n              deceased_birth_date DATE,\r\n              deceased_birth_place VARCHAR(255),\r\n              age_at_death INT,\r\n              cause_of_death VARCHAR(255),\r\n              burial_place VARCHAR(255),\r\n              priest_name VARCHAR(255),\r\n              next_of_kin VARCHAR(255),\r\n              notes TEXT,\r\n              original_language ENUM('greek', 'russian', 'romanian', 'english', 'other'),\r\n              translation_status ENUM('original', 'translated', 'reviewed') DEFAULT 'original',\r\n              created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\r\n              updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\r\n              FOREIGN KEY (church_id) REFERENCES church_info(id) ON DELETE CASCADE,\r\n              INDEX idx_church_record (church_id, record_number),\r\n              INDEX idx_death_date (death_date),\r\n              INDEX idx_deceased_name (deceased_name)\r\n            ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci\r\n          `\r\n        }\r\n      ];\r\n\r\n      for (const schema of coreSchemas) {\r\n        await this.executeQuery(connection, schema.sql, `Create table: ${schema.name}`);\r\n      }\r\n\r\n      colorLog('‚úÖ Core schema creation completed', 'green');\r\n\r\n    } catch (error) {\r\n      colorLog(`‚ùå Schema creation failed: ${error.message}`, 'red');\r\n      throw error;\r\n    } finally {\r\n      await connection.end();\r\n    }\r\n  }\r\n\r\n  async setupOcrTables() {\r\n    colorLog('\\nüîç Setting up OCR Tables...', 'cyan');\r\n    \r\n    const connection = await this.getConnection();\r\n    \r\n    try {\r\n      const ocrSchemas = [\r\n        {\r\n          name: 'ocr_jobs',\r\n          sql: `\r\n            CREATE TABLE IF NOT EXISTS ocr_jobs (\r\n              id INT AUTO_INCREMENT PRIMARY KEY,\r\n              church_id INT NOT NULL,\r\n              job_id VARCHAR(100) UNIQUE NOT NULL,\r\n              file_name VARCHAR(255),\r\n              file_path VARCHAR(500),\r\n              record_type ENUM('baptism', 'marriage', 'funeral') NOT NULL,\r\n              status ENUM('pending', 'processing', 'completed', 'failed') DEFAULT 'pending',\r\n              ocr_text TEXT,\r\n              translated_text TEXT,\r\n              confidence_score DECIMAL(5,2),\r\n              language_detected VARCHAR(50),\r\n              processing_time_ms INT,\r\n              error_message TEXT,\r\n              created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\r\n              updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\r\n              FOREIGN KEY (church_id) REFERENCES church_info(id) ON DELETE CASCADE,\r\n              INDEX idx_job_id (job_id),\r\n              INDEX idx_status (status),\r\n              INDEX idx_church_type (church_id, record_type)\r\n            ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci\r\n          `\r\n        },\r\n        {\r\n          name: 'ocr_field_mappings',\r\n          sql: `\r\n            CREATE TABLE IF NOT EXISTS ocr_field_mappings (\r\n              id INT AUTO_INCREMENT PRIMARY KEY,\r\n              church_id INT NOT NULL,\r\n              record_type ENUM('baptism', 'marriage', 'funeral') NOT NULL,\r\n              ocr_text_pattern VARCHAR(500),\r\n              field_name VARCHAR(100),\r\n              field_type ENUM('text', 'date', 'number') DEFAULT 'text',\r\n              confidence_threshold DECIMAL(5,2) DEFAULT 0.8,\r\n              validation_regex VARCHAR(500),\r\n              is_required BOOLEAN DEFAULT FALSE,\r\n              is_active BOOLEAN DEFAULT TRUE,\r\n              created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\r\n              FOREIGN KEY (church_id) REFERENCES church_info(id) ON DELETE CASCADE,\r\n              INDEX idx_church_type (church_id, record_type),\r\n              INDEX idx_field_name (field_name)\r\n            ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci\r\n          `\r\n        },\r\n        {\r\n          name: 'ocr_training_data',\r\n          sql: `\r\n            CREATE TABLE IF NOT EXISTS ocr_training_data (\r\n              id INT AUTO_INCREMENT PRIMARY KEY,\r\n              church_id INT,\r\n              record_type ENUM('baptism', 'marriage', 'funeral') NOT NULL,\r\n              language ENUM('greek', 'russian', 'romanian', 'english', 'other') NOT NULL,\r\n              original_image_path VARCHAR(500),\r\n              verified_text TEXT,\r\n              field_extractions JSON,\r\n              quality_score DECIMAL(5,2),\r\n              reviewer_notes TEXT,\r\n              is_validated BOOLEAN DEFAULT FALSE,\r\n              created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\r\n              FOREIGN KEY (church_id) REFERENCES church_info(id) ON DELETE SET NULL,\r\n              INDEX idx_type_language (record_type, language),\r\n              INDEX idx_quality (quality_score),\r\n              INDEX idx_validated (is_validated)\r\n            ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci\r\n          `\r\n        }\r\n      ];\r\n\r\n      for (const schema of ocrSchemas) {\r\n        await this.executeQuery(connection, schema.sql, `Create OCR table: ${schema.name}`);\r\n      }\r\n\r\n      colorLog('‚úÖ OCR tables setup completed', 'green');\r\n\r\n    } catch (error) {\r\n      colorLog(`‚ùå OCR tables setup failed: ${error.message}`, 'red');\r\n      throw error;\r\n    } finally {\r\n      await connection.end();\r\n    }\r\n  }\r\n\r\n  async optimizeDatabase() {\r\n    colorLog('\\n‚ö° Optimizing Database Performance...', 'cyan');\r\n    \r\n    const connection = await this.getConnection();\r\n    \r\n    try {\r\n      // Get all tables\r\n      const [tables] = await connection.execute('SHOW TABLES');\r\n      const tableNames = tables.map(row => Object.values(row)[0]);\r\n      \r\n      for (const tableName of tableNames) {\r\n        await this.executeQuery(connection, `OPTIMIZE TABLE \\`${tableName}\\``, `Optimize: ${tableName}`);\r\n      }\r\n\r\n      // Update table statistics\r\n      await this.executeQuery(connection, 'ANALYZE TABLE `baptism_records`, `marriage_records`, `funeral_records`, `ocr_jobs`', 'Update table statistics');\r\n\r\n      colorLog('‚úÖ Database optimization completed', 'green');\r\n\r\n    } catch (error) {\r\n      colorLog(`‚ùå Database optimization failed: ${error.message}`, 'red');\r\n      throw error;\r\n    } finally {\r\n      await connection.end();\r\n    }\r\n  }\r\n\r\n  async validateSchema() {\r\n    colorLog('\\n‚úÖ Validating Database Schema...', 'cyan');\r\n    \r\n    const connection = await this.getConnection();\r\n    \r\n    try {\r\n      const requiredTables = [\r\n        'church_info', 'baptism_records', 'marriage_records', \r\n        'funeral_records', 'ocr_jobs', 'ocr_field_mappings'\r\n      ];\r\n\r\n      const [tables] = await connection.execute('SHOW TABLES');\r\n      const existingTables = tables.map(row => Object.values(row)[0]);\r\n      \r\n      let validationPassed = true;\r\n\r\n      for (const requiredTable of requiredTables) {\r\n        if (existingTables.includes(requiredTable)) {\r\n          colorLog(`   ‚úÖ Table exists: ${requiredTable}`, 'green');\r\n        } else {\r\n          colorLog(`   ‚ùå Missing table: ${requiredTable}`, 'red');\r\n          validationPassed = false;\r\n        }\r\n      }\r\n\r\n      // Check foreign key constraints\r\n      const [constraints] = await connection.execute(`\r\n        SELECT TABLE_NAME, CONSTRAINT_NAME, REFERENCED_TABLE_NAME \r\n        FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE \r\n        WHERE REFERENCED_TABLE_SCHEMA = ? AND REFERENCED_TABLE_NAME IS NOT NULL\r\n      `, [this.dbConfig.database]);\r\n\r\n      if (constraints.length > 0) {\r\n        colorLog(`   ‚úÖ Found ${constraints.length} foreign key constraints`, 'green');\r\n      } else {\r\n        colorLog('   ‚ö†Ô∏è  No foreign key constraints found', 'yellow');\r\n      }\r\n\r\n      if (validationPassed) {\r\n        colorLog('‚úÖ Schema validation passed', 'green');\r\n      } else {\r\n        colorLog('‚ùå Schema validation failed', 'red');\r\n        throw new Error('Database schema validation failed');\r\n      }\r\n\r\n    } catch (error) {\r\n      colorLog(`‚ùå Schema validation failed: ${error.message}`, 'red');\r\n      throw error;\r\n    } finally {\r\n      await connection.end();\r\n    }\r\n  }\r\n\r\n  async run(command) {\r\n    const startTime = Date.now();\r\n    \r\n    colorLog('üóÑÔ∏è  Orthodox Metrics - Database Manager', 'cyan');\r\n    colorLog('‚ïê'.repeat(60), 'blue');\r\n    colorLog(`Command: ${command}`, 'blue');\r\n    \r\n    if (this.options.dryRun) {\r\n      colorLog('üîç DRY RUN MODE - No changes will be made', 'yellow');\r\n    }\r\n\r\n    try {\r\n      if (this.options.backup && !this.options.dryRun) {\r\n        await this.createBackup();\r\n      }\r\n\r\n      switch (command) {\r\n        case 'setup':\r\n          await this.createSchema();\r\n          await this.setupOcrTables();\r\n          await this.validateSchema();\r\n          break;\r\n        \r\n        case 'schema':\r\n          await this.createSchema();\r\n          break;\r\n        \r\n        case 'ocr':\r\n          await this.setupOcrTables();\r\n          break;\r\n        \r\n        case 'optimize':\r\n          await this.optimizeDatabase();\r\n          break;\r\n        \r\n        case 'validate':\r\n          await this.validateSchema();\r\n          break;\r\n        \r\n        case 'backup':\r\n          await this.createBackup();\r\n          break;\r\n        \r\n        default:\r\n          throw new Error(`Unknown command: ${command}`);\r\n      }\r\n\r\n      const duration = ((Date.now() - startTime) / 1000).toFixed(1);\r\n      \r\n      colorLog(`\\nüéâ DATABASE OPERATION COMPLETED!`, 'green');\r\n      colorLog(`‚è±Ô∏è  Duration: ${duration}s`, 'green');\r\n\r\n    } catch (error) {\r\n      colorLog(`\\nüí• DATABASE OPERATION FAILED: ${error.message}`, 'red');\r\n      process.exit(1);\r\n    }\r\n  }\r\n}\r\n\r\n// CLI interface\r\nasync function main() {\r\n  const args = process.argv.slice(2);\r\n  \r\n  if (args.length === 0 || args.includes('--help')) {\r\n    console.log(`\r\nOrthodox Metrics Database Manager\r\n\r\nUsage: node database-manager.js <command> [options]\r\n\r\nCommands:\r\n  setup       Complete database setup (schema + OCR tables)\r\n  schema      Create core database schema only\r\n  ocr         Setup OCR-related tables only\r\n  optimize    Optimize database performance\r\n  validate    Validate database schema\r\n  backup      Create database backup\r\n\r\nOptions:\r\n  --dry-run          Show what would be done without making changes\r\n  --no-backup        Skip automatic backup creation\r\n  --force            Force operation even if risky\r\n  --help             Show this help message\r\n\r\nExamples:\r\n  node database-manager.js setup                    # Full setup\r\n  node database-manager.js schema --dry-run         # Preview schema creation\r\n  node database-manager.js optimize                 # Optimize performance\r\n  node database-manager.js backup                   # Create backup only\r\n    `);\r\n    process.exit(0);\r\n  }\r\n\r\n  const command = args[0];\r\n  const options = {};\r\n\r\n  for (let i = 1; i < args.length; i++) {\r\n    switch (args[i]) {\r\n      case '--dry-run':\r\n        options.dryRun = true;\r\n        break;\r\n      case '--no-backup':\r\n        options.backup = false;\r\n        break;\r\n      case '--force':\r\n        options.force = true;\r\n        break;\r\n    }\r\n  }\r\n\r\n  const dbManager = new DatabaseManager(options);\r\n  await dbManager.run(command);\r\n}\r\n\r\nif (require.main === module) {\r\n  main().catch(console.error);\r\n}\r\n\r\nmodule.exports = DatabaseManager;\r\n"
    },
    "complexity": {
      "totalLines": 547,
      "codeLines": 453,
      "commentLines": 18,
      "commentRatio": 0.03821656050955414,
      "averageLineLength": 39.938428874734605
    },
    "lastAnalyzed": "2025-07-28T07:19:59.985Z"
  },
  "contentHash": "427c55e239ff61c816eacbb0a526e3996bcd14edac191d1dd0c712a4137e459f",
  "discoveredAt": "2025-07-28T07:19:59.985Z"
}