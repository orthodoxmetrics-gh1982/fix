{
  "id": "b0aca0dec249",
  "originalPath": "/var/www/orthodox-church-mgmt/orthodoxmetrics/prod/server/routes/clients.js",
  "relativePath": "server/routes/clients.js",
  "name": "clients.js",
  "extension": ".js",
  "size": 14990,
  "modified": "2025-07-24T14:50:26.280Z",
  "created": "2025-07-24T14:50:26.280Z",
  "classification": {
    "type": "Server Scripts",
    "category": "Backend > Server",
    "confidence": 7
  },
  "metadata": {
    "fileStats": {
      "lines": 422,
      "characters": 14974,
      "words": 1295
    },
    "classification": {
      "type": "Server Scripts",
      "category": "Backend > Server",
      "confidence": 7
    },
    "dependencies": [
      {
        "type": "npm_package",
        "name": "express",
        "line": 4
      },
      {
        "type": "npm_package",
        "name": "path",
        "line": 8
      },
      {
        "type": "npm_package",
        "name": "mysql2/promise",
        "line": 142
      },
      {
        "type": "npm_package",
        "name": "fs",
        "line": 143
      },
      {
        "type": "npm_package",
        "name": "mysql2/promise",
        "line": 336
      },
      {
        "type": "npm_package",
        "name": "mysql2/promise",
        "line": 390
      }
    ],
    "security": {
      "findings": [
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 163,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 164,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 165,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 338,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 339,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 340,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 392,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 393,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 394,
          "redacted": true
        }
      ],
      "hasSecurityIssues": true,
      "redactedContent": "// server/routes/clients.js\r\n// Main client management API endpoints for Orthodox Metrics SaaS platform\r\n\r\nconst express = require('express');\r\nconst router = express.Router();\r\nconst { promisePool } = require('../../config/db');\r\nconst { rootPool } = require('../config/db-root');\r\nconst path = require('path');\r\n\r\n// Get all clients\r\nrouter.get('/', async (req, res) => {\r\n    try {\r\n        // Handle pagination parameters\r\n        const page = parseInt(req.query.page) || 1;\r\n        const limit = parseInt(req.query.limit) || 50;\r\n        const offset = (page - 1) * limit;\r\n\r\n        // Get total count for pagination\r\n        const [countResult] = await promisePool.execute('SELECT COUNT(*) as total FROM clients');\r\n        const total = countResult[0].total;\r\n\r\n        // Get clients with pagination\r\n        const [clients] = await promisePool.execute(`\r\n      SELECT \r\n        id,\r\n        name,\r\n        slug,\r\n        contact_email,\r\n        database_name,\r\n        status,\r\n        branding_config,\r\n        created_at,\r\n        updated_at\r\n      FROM clients \r\n      ORDER BY created_at DESC\r\n      LIMIT ? OFFSET ?\r\n    `, [limit, offset]);\r\n\r\n        // Parse branding JSON for each client\r\n        const clientsWithBranding = clients.map(client => ({\r\n            ...client,\r\n            branding_config: client.branding_config ? JSON.parse(client.branding_config) : {}\r\n        }));\r\n\r\n        // Calculate pagination info\r\n        const totalPages = Math.ceil(total / limit);\r\n\r\n        // Return structured response for frontend compatibility\r\n        res.json({\r\n            data: {\r\n                clients: clientsWithBranding,\r\n                total,\r\n                totalPages,\r\n                currentPage: page,\r\n                limit\r\n            }\r\n        });\r\n    } catch (error) {\r\n        console.error('Error fetching clients:', error);\r\n        res.status(500).json({ error: 'Failed to fetch clients' });\r\n    }\r\n});\r\n\r\n// Get specific client by ID\r\nrouter.get('/:id', async (req, res) => {\r\n    try {\r\n        const [clients] = await promisePool.execute(`\r\n      SELECT \r\n        id,\r\n        name,\r\n        slug,\r\n        contact_email,\r\n        database_name,\r\n        status,\r\n        branding_config,\r\n        created_at,\r\n        updated_at\r\n      FROM clients \r\n      WHERE id = ?\r\n    `, [req.params.id]);\r\n\r\n        if (clients.length === 0) {\r\n            return res.status(404).json({ error: 'Client not found' });\r\n        }\r\n\r\n        const client = {\r\n            ...clients[0],\r\n            branding_config: clients[0].branding_config ? JSON.parse(clients[0].branding_config) : {}\r\n        };\r\n\r\n        res.json(client);\r\n    } catch (error) {\r\n        console.error('Error fetching client:', error);\r\n        res.status(500).json({ error: 'Failed to fetch client' });\r\n    }\r\n});\r\n\r\n// Create new client with automated database setup\r\nrouter.post('/', async (req, res) => {\r\n    try {\r\n        console.log('📝 POST /api/clients - Request body:', JSON.stringify(req.body, null, 2));\r\n        \r\n        const { name, slug, contact_email, branding_config = {}, branding = {} } = req.body;\r\n        \r\n        // Use contact_email from frontend, fallback to contactEmail for backwards compatibility\r\n        const contactEmail = contact_email;\r\n        \r\n        // Use branding from frontend, fallback to branding_config\r\n        const finalBrandingConfig = Object.keys(branding).length > 0 ? branding : branding_config;\r\n\r\n        console.log('📝 Extracted fields:', { name, slug, contactEmail, finalBrandingConfig });\r\n\r\n        // Validate required fields\r\n        if (!name || !slug || !contactEmail) {\r\n            console.log('❌ Validation failed - missing fields:', { \r\n                name: !!name, \r\n                slug: !!slug, \r\n                contactEmail: !!contactEmail \r\n            });\r\n            return res.status(400).json({\r\n                error: 'Name, slug, and contact email are required'\r\n            });\r\n        }\r\n\r\n        // Check if slug already exists\r\n        const [existingClients] = await promisePool.execute(\r\n            'SELECT id FROM clients WHERE slug = ?',\r\n            [slug]\r\n        );\r\n\r\n        if (existingClients.length > 0) {\r\n            console.log('❌ Slug already exists:', slug);\r\n            return res.status(400).json({\r\n                error: 'Client slug already exists. Please choose a different slug.'\r\n            });\r\n        }\r\n\r\n        console.log('✅ Validation passed, creating client...');\r\n\r\n        // Create client database directly using root pool\r\n        try {\r\n            const mysql = require('mysql2/promise');\r\n            const fs = require('fs').promises;\r\n            const databaseName = `orthodox_${slug}`;\r\n            \r\n            console.log(`Creating database: ${databaseName}`);\r\n            \r\n            // Basic name sanitization\r\n            if (!/^orthodox_[a-zA-Z0-9_-]+$/.test(databaseName)) {\r\n                return res.status(400).json({ error: 'Invalid database name format.' });\r\n            }\r\n            \r\n            // Create database using root pool\r\n            await rootPool.execute(`CREATE DATABASE IF NOT EXISTS \\`${databaseName}\\``);\r\n            \r\n            // Grant privileges to orthodoxapps user for the new database\r\n            await rootPool.execute(`GRANT ALL PRIVILEGES ON \\`${databaseName}\\`.* TO 'orthodoxapps'@'localhost'`);\r\n            await rootPool.execute(`FLUSH PRIVILEGES`);\r\n            console.log(`✅ Database ${databaseName} created and privileges granted`);\r\n            \r\n            // Connect to the new database to create tables\r\n            const clientConnection = await mysql.createConnection({\r\n                host: process.env.[REDACTED] || 'localhost',\r\n                user: process.env.[REDACTED] || 'orthodoxapps',\r\n                password: process.env.[REDACTED] || 'Summerof1982@!',\r\n                database: databaseName\r\n            });\r\n            \r\n            try {\r\n                // Read template schema\r\n                const schemaPath = path.resolve(__dirname, '../../scripts/clientDatabaseTemplate.sql');\r\n                const schemaSql = await fs.readFile(schemaPath, 'utf8');\r\n                \r\n                // Replace placeholders\r\n                const clientSql = schemaSql\r\n                    .replace(/{DATABASE_NAME}/g, databaseName)\r\n                    .replace(/{CLIENT_NAME}/g, name)\r\n                    .replace(/{CONTACT_EMAIL}/g, contactEmail);\r\n                \r\n                // Execute schema\r\n                const statements = clientSql.split(';').filter(stmt => stmt.trim());\r\n                \r\n                for (const statement of statements) {\r\n                    if (statement.trim()) {\r\n                        await clientConnection.execute(statement);\r\n                    }\r\n                }\r\n                \r\n                console.log(`✅ Database ${databaseName} schema created successfully`);\r\n                \r\n                // Insert client record into main database\r\n                const [insertResult] = await promisePool.execute(`\r\n                    INSERT INTO clients (name, slug, contact_email, database_name, status, branding_config, created_at, updated_at)\r\n                    VALUES (?, ?, ?, ?, 'active', ?, NOW(), NOW())\r\n                `, [name, slug, contactEmail, databaseName, JSON.stringify(finalBrandingConfig)]);\r\n                \r\n                console.log(`✅ Client record created with ID: ${insertResult.insertId}`);\r\n                \r\n                // Fetch the newly created client\r\n                const [newClient] = await promisePool.execute(`\r\n                    SELECT \r\n                      id,\r\n                      name,\r\n                      slug,\r\n                      contact_email,\r\n                      database_name,\r\n                      status,\r\n                      branding_config,\r\n                      created_at,\r\n                      updated_at\r\n                    FROM clients \r\n                    WHERE id = ?\r\n                `, [insertResult.insertId]);\r\n\r\n                const client = {\r\n                    ...newClient[0],\r\n                    branding_config: newClient[0].branding_config ? JSON.parse(newClient[0].branding_config) : {}\r\n                };\r\n\r\n                res.status(201).json({\r\n                    message: 'Client created successfully',\r\n                    client\r\n                });\r\n                \r\n            } finally {\r\n                await clientConnection.end();\r\n            }\r\n            \r\n        } catch (createError) {\r\n            console.error('Error creating client database:', createError);\r\n            res.status(500).json({\r\n                error: 'Failed to create client database',\r\n                details: createError.message\r\n            });\r\n        }\r\n\r\n    } catch (error) {\r\n        console.error('Error creating client:', error);\r\n        res.status(500).json({ error: 'Failed to create client' });\r\n    }\r\n});\r\n\r\n// Update client\r\nrouter.put('/:id', async (req, res) => {\r\n    try {\r\n        const { name, contactEmail, status, branding_config } = req.body;\r\n        const clientId = req.params.id;\r\n\r\n        const [result] = await promisePool.execute(`\r\n      UPDATE clients \r\n      SET \r\n        name = ?,\r\n        contact_email = ?,\r\n        status = ?,\r\n        branding_config = ?,\r\n        updated_at = NOW()\r\n      WHERE id = ?\r\n    `, [name, contactEmail, status, JSON.stringify(branding_config || {}), clientId]);\r\n\r\n        if (result.affectedRows === 0) {\r\n            return res.status(404).json({ error: 'Client not found' });\r\n        }\r\n\r\n        // Fetch updated client\r\n        const [clients] = await promisePool.execute(`\r\n      SELECT \r\n        id,\r\n        name,\r\n        slug,\r\n        contact_email,\r\n        database_name,\r\n        status,\r\n        branding_config,\r\n        created_at,\r\n        updated_at\r\n      FROM clients \r\n      WHERE id = ?\r\n    `, [clientId]);\r\n\r\n        const client = {\r\n            ...clients[0],\r\n            branding_config: clients[0].branding_config ? JSON.parse(clients[0].branding_config) : {}\r\n        };\r\n\r\n        res.json({\r\n            message: 'Client updated successfully',\r\n            client\r\n        });\r\n    } catch (error) {\r\n        console.error('Error updating client:', error);\r\n        res.status(500).json({ error: 'Failed to update client' });\r\n    }\r\n});\r\n\r\n// Delete client (soft delete - set status to inactive)\r\nrouter.delete('/:id', async (req, res) => {\r\n    try {\r\n        const clientId = req.params.id;\r\n\r\n        const [result] = await promisePool.execute(`\r\n      UPDATE clients \r\n      SET \r\n        status = 'inactive',\r\n        updated_at = NOW()\r\n      WHERE id = ?\r\n    `, [clientId]);\r\n\r\n        if (result.affectedRows === 0) {\r\n            return res.status(404).json({ error: 'Client not found' });\r\n        }\r\n\r\n        res.json({ message: 'Client deactivated successfully' });\r\n    } catch (error) {\r\n        console.error('Error deactivating client:', error);\r\n        res.status(500).json({ error: 'Failed to deactivate client' });\r\n    }\r\n});\r\n\r\n// Get client statistics\r\nrouter.get('/:id/stats', async (req, res) => {\r\n    try {\r\n        const clientId = req.params.id;\r\n\r\n        // Get client info\r\n        const [clients] = await promisePool.execute(`\r\n      SELECT database_name FROM clients WHERE id = ?\r\n    `, [clientId]);\r\n\r\n        if (clients.length === 0) {\r\n            return res.status(404).json({ error: 'Client not found' });\r\n        }\r\n\r\n        const databaseName = clients[0].database_name;\r\n\r\n        // Connect to client database and get statistics\r\n        const mysql = require('mysql2/promise');\r\n        const clientConnection = await mysql.createConnection({\r\n            host: process.env.[REDACTED] || 'localhost',\r\n            user: process.env.[REDACTED] || 'root',\r\n            password: process.env.[REDACTED] || 'Summerof1982@!',\r\n            database: databaseName\r\n        });\r\n\r\n        try {\r\n            // Get record counts from church database\r\n            const [baptismCount] = await clientConnection.execute('SELECT COUNT(*) as count FROM baptism_records');\r\n            const [marriageCount] = await clientConnection.execute('SELECT COUNT(*) as count FROM marriage_records');\r\n            const [funeralCount] = await clientConnection.execute('SELECT COUNT(*) as count FROM funeral_records');\r\n\r\n            // Get church metadata from platform database\r\n            const [churchInfo] = await promisePool.query('SELECT * FROM churches WHERE database_name = ?', [database]);\r\n\r\n            const stats = {\r\n                records: {\r\n                    baptisms: baptismCount[0].count,\r\n                    marriages: marriageCount[0].count,\r\n                    funerals: funeralCount[0].count,\r\n                    total: baptismCount[0].count + marriageCount[0].count + funeralCount[0].count\r\n                },\r\n                church: churchInfo[0] || null\r\n            };\r\n\r\n            res.json(stats);\r\n        } finally {\r\n            await clientConnection.end();\r\n        }\r\n    } catch (error) {\r\n        console.error('Error fetching client stats:', error);\r\n        res.status(500).json({ error: 'Failed to fetch client statistics' });\r\n    }\r\n});\r\n\r\n// Test client database connection\r\nrouter.get('/:id/test-connection', async (req, res) => {\r\n    try {\r\n        const clientId = req.params.id;\r\n\r\n        // Get client info\r\n        const [clients] = await promisePool.execute(`\r\n      SELECT database_name FROM clients WHERE id = ?\r\n    `, [clientId]);\r\n\r\n        if (clients.length === 0) {\r\n            return res.status(404).json({ error: 'Client not found' });\r\n        }\r\n\r\n        const { database_name } = clients[0];\r\n\r\n        // Test connection to client database\r\n        const mysql = require('mysql2/promise');\r\n        const clientConnection = await mysql.createConnection({\r\n            host: process.env.[REDACTED] || 'localhost',\r\n            user: process.env.[REDACTED] || 'root',\r\n            password: process.env.[REDACTED] || 'Summerof1982@!',\r\n            database: database_name\r\n        });\r\n\r\n        try {\r\n            await clientConnection.execute('SELECT 1');\r\n            await clientConnection.end();\r\n\r\n            res.json({\r\n                success: true,\r\n                message: 'Client database connection successful',\r\n                database: database_name\r\n            });\r\n        } catch (connectionError) {\r\n            res.status(500).json({\r\n                success: false,\r\n                message: 'Client database connection failed',\r\n                error: connectionError.message,\r\n                database: database_name\r\n            });\r\n        }\r\n    } catch (error) {\r\n        console.error('Error testing client connection:', error);\r\n        res.status(500).json({ error: 'Failed to test client connection' });\r\n    }\r\n});\r\n\r\nmodule.exports = router;\r\n"
    },
    "complexity": {
      "totalLines": 422,
      "codeLines": 319,
      "commentLines": 36,
      "commentRatio": 0.10140845070422536,
      "averageLineLength": 40.14366197183099
    },
    "lastAnalyzed": "2025-07-28T07:20:00.442Z"
  },
  "contentHash": "9eeab050af325467b5a88081ae4330a4d6bff7ee1962f1f397e21db53d234ee2",
  "discoveredAt": "2025-07-28T07:20:00.442Z"
}