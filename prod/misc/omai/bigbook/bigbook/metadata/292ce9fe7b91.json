{
  "id": "292ce9fe7b91",
  "originalPath": "/var/www/orthodox-church-mgmt/orthodoxmetrics/prod/docs/archive/temp_extract/07-09-25/AUTHENTICATION_FLOWS.md",
  "relativePath": "docs/archive/temp_extract/07-09-25/AUTHENTICATION_FLOWS.md",
  "name": "AUTHENTICATION_FLOWS.md",
  "extension": ".md",
  "size": 25848,
  "modified": "2025-07-09T04:32:16.000Z",
  "created": "2025-07-14T05:44:04.708Z",
  "classification": {
    "type": "Documentation",
    "category": "Documentation",
    "confidence": 7
  },
  "metadata": {
    "fileStats": {
      "lines": 927,
      "characters": 24634,
      "words": 2400
    },
    "classification": {
      "type": "Documentation",
      "category": "Documentation",
      "confidence": 7
    },
    "dependencies": [
      {
        "type": "npm_package",
        "name": "redis",
        "line": 886
      }
    ],
    "security": {
      "findings": [
        {
          "type": "sensitive_data",
          "pattern": "(?:password|pwd|pass)\\s*[:=]\\s*['\"]([^'\"]+)['\"]",
          "line": 845,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 266,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 268,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 269,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 270,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 271,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 286,
          "redacted": true
        }
      ],
      "hasSecurityIssues": true,
      "redactedContent": "# Authentication Flow Documentation\r\n\r\n## 🔐 Orthodox Metrics Authentication System\r\n\r\nThis document provides comprehensive documentation for the authentication and authorization flows in the Orthodox Metrics system.\r\n\r\n## 🎯 Authentication Overview\r\n\r\n### Authentication Methods\r\n- **Session-based Authentication**: Primary method using cookies\r\n- **Role-based Access Control**: Hierarchical permission system\r\n- **Multi-factor Authentication**: Optional TOTP-based MFA\r\n- **Password Security**: BCrypt hashing with salt\r\n\r\n### Flow Types\r\n1. **Login Flow**: User authentication and session creation\r\n2. **Logout Flow**: Session termination and cleanup\r\n3. **Password Change Flow**: Secure password updates\r\n4. **Session Validation**: Ongoing authentication verification\r\n5. **Access Control**: Permission-based resource access\r\n\r\n## 🚀 Login Flow\r\n\r\n### 1. User Login Process\r\n\r\n#### Frontend Login Request\r\n```typescript\r\n// Login component - frontend\r\nconst handleLogin = async (credentials: LoginCredentials) => {\r\n  try {\r\n    const response = await fetch('/api/auth/login', {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json'\r\n      },\r\n      credentials: 'include', // Include cookies\r\n      body: JSON.stringify(credentials)\r\n    });\r\n    \r\n    const data = await response.json();\r\n    \r\n    if (data.success) {\r\n      // Update auth context\r\n      setUser(data.user);\r\n      setIsAuthenticated(true);\r\n      \r\n      // Redirect to dashboard\r\n      navigate('/admin/dashboard');\r\n    } else {\r\n      setError(data.error);\r\n    }\r\n  } catch (error) {\r\n    setError('Login failed. Please try again.');\r\n  }\r\n};\r\n```\r\n\r\n#### Backend Login Handler\r\n```javascript\r\n// controllers/authController.js\r\nconst login = async (req, res) => {\r\n  try {\r\n    const { email, password } = req.body;\r\n    \r\n    // Step 1: Validate input\r\n    if (!email || !password) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        error: 'Email and password are required'\r\n      });\r\n    }\r\n    \r\n    // Step 2: Rate limiting check\r\n    const clientIP = req.ip;\r\n    const attempts = await getFailedAttempts(clientIP);\r\n    \r\n    if (attempts >= 5) {\r\n      await logSecurityEvent('LOGIN_BLOCKED', {\r\n        ip: clientIP,\r\n        email: email,\r\n        reason: 'Too many failed attempts'\r\n      });\r\n      \r\n      return res.status(429).json({\r\n        success: false,\r\n        error: 'Account temporarily locked. Try again later.'\r\n      });\r\n    }\r\n    \r\n    // Step 3: Find user in database\r\n    const [users] = await db.execute(\r\n      'SELECT id, email, password, name, role, is_active, mfa_secret FROM users WHERE email = ?',\r\n      [email]\r\n    );\r\n    \r\n    if (users.length === 0) {\r\n      await incrementFailedAttempts(clientIP);\r\n      await logSecurityEvent('LOGIN_FAILED', {\r\n        ip: clientIP,\r\n        email: email,\r\n        reason: 'User not found'\r\n      });\r\n      \r\n      return res.status(401).json({\r\n        success: false,\r\n        error: 'Invalid credentials'\r\n      });\r\n    }\r\n    \r\n    const user = users[0];\r\n    \r\n    // Step 4: Check if account is active\r\n    if (!user.is_active) {\r\n      await logSecurityEvent('LOGIN_FAILED', {\r\n        ip: clientIP,\r\n        email: email,\r\n        reason: 'Account inactive'\r\n      });\r\n      \r\n      return res.status(401).json({\r\n        success: false,\r\n        error: 'Account is inactive'\r\n      });\r\n    }\r\n    \r\n    // Step 5: Verify password\r\n    const isValidPassword = await bcrypt.compare(password, user.password);\r\n    \r\n    if (!isValidPassword) {\r\n      await incrementFailedAttempts(clientIP);\r\n      await logSecurityEvent('LOGIN_FAILED', {\r\n        ip: clientIP,\r\n        email: email,\r\n        reason: 'Invalid password'\r\n      });\r\n      \r\n      return res.status(401).json({\r\n        success: false,\r\n        error: 'Invalid credentials'\r\n      });\r\n    }\r\n    \r\n    // Step 6: MFA verification (if enabled)\r\n    if (user.mfa_secret && req.body.mfaToken) {\r\n      const isValidMFA = verifyMFAToken(req.body.mfaToken, user.mfa_secret);\r\n      \r\n      if (!isValidMFA) {\r\n        await logSecurityEvent('LOGIN_FAILED', {\r\n          ip: clientIP,\r\n          email: email,\r\n          reason: 'Invalid MFA token'\r\n        });\r\n        \r\n        return res.status(401).json({\r\n          success: false,\r\n          error: 'Invalid MFA token'\r\n        });\r\n      }\r\n    } else if (user.mfa_secret && !req.body.mfaToken) {\r\n      // MFA required but not provided\r\n      return res.status(200).json({\r\n        success: false,\r\n        requiresMFA: true,\r\n        message: 'MFA token required'\r\n      });\r\n    }\r\n    \r\n    // Step 7: Create session\r\n    req.session.user = {\r\n      id: user.id,\r\n      email: user.email,\r\n      name: user.name,\r\n      role: user.role\r\n    };\r\n    \r\n    req.session.loginTime = new Date();\r\n    req.session.lastActivity = new Date();\r\n    \r\n    // Step 8: Clear failed attempts\r\n    await clearFailedAttempts(clientIP);\r\n    \r\n    // Step 9: Log successful login\r\n    await logSecurityEvent('LOGIN_SUCCESS', {\r\n      ip: clientIP,\r\n      userId: user.id,\r\n      email: user.email,\r\n      sessionId: req.sessionID\r\n    });\r\n    \r\n    // Step 10: Update user last login\r\n    await db.execute(\r\n      'UPDATE users SET last_login = CURRENT_TIMESTAMP WHERE id = ?',\r\n      [user.id]\r\n    );\r\n    \r\n    // Step 11: Return success response\r\n    res.json({\r\n      success: true,\r\n      message: 'Login successful',\r\n      user: {\r\n        id: user.id,\r\n        email: user.email,\r\n        name: user.name,\r\n        role: user.role\r\n      }\r\n    });\r\n    \r\n  } catch (error) {\r\n    logger.error('Login error:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      error: 'Login failed'\r\n    });\r\n  }\r\n};\r\n```\r\n\r\n### 2. Login Flow Diagram\r\n\r\n```\r\n┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐\r\n│   Frontend      │    │    Backend      │    │   Database      │\r\n│   (React)       │    │   (Express)     │    │   (MySQL)       │\r\n└─────────────────┘    └─────────────────┘    └─────────────────┘\r\n         │                        │                        │\r\n         │ POST /auth/login       │                        │\r\n         │ { email, password }    │                        │\r\n         │──────────────────────> │                        │\r\n         │                        │                        │\r\n         │                        │ SELECT user WHERE      │\r\n         │                        │ email = ?              │\r\n         │                        │──────────────────────> │\r\n         │                        │                        │\r\n         │                        │ User data              │\r\n         │                        │ <────────────────────── │\r\n         │                        │                        │\r\n         │                        │ bcrypt.compare()       │\r\n         │                        │ (password verification)│\r\n         │                        │                        │\r\n         │                        │ CREATE SESSION         │\r\n         │                        │ req.session.user = {}  │\r\n         │                        │                        │\r\n         │                        │ UPDATE last_login      │\r\n         │                        │──────────────────────> │\r\n         │                        │                        │\r\n         │ { success: true,       │                        │\r\n         │   user: {...} }        │                        │\r\n         │ <────────────────────── │                        │\r\n         │                        │                        │\r\n         │ Set-Cookie: connect.sid│                        │\r\n         │ <────────────────────── │                        │\r\n         │                        │                        │\r\n         │ Redirect to /dashboard │                        │\r\n         └────────────────────────┘                        │\r\n```\r\n\r\n## 🔒 Session Management Flow\r\n\r\n### 1. Session Creation and Storage\r\n\r\n#### Session Configuration\r\n```javascript\r\n// config/session.js\r\nconst sessionConfig = {\r\n  key: 'orthodox.sid',\r\n  secret: process.env.[REDACTED],\r\n  store: new MySQLStore({\r\n    host: process.env.[REDACTED],\r\n    user: process.env.[REDACTED],\r\n    password: process.env.[REDACTED],\r\n    database: process.env.[REDACTED],\r\n    createDatabaseTable: true,\r\n    schema: {\r\n      tableName: 'sessions',\r\n      columnNames: {\r\n        session_id: 'session_id',\r\n        expires: 'expires',\r\n        data: 'data'\r\n      }\r\n    }\r\n  }),\r\n  resave: false,\r\n  saveUninitialized: false,\r\n  rolling: true,\r\n  cookie: {\r\n    secure: process.env.[REDACTED] === 'production',\r\n    httpOnly: true,\r\n    maxAge: 30 * 60 * 1000, // 30 minutes\r\n    sameSite: 'strict'\r\n  }\r\n};\r\n```\r\n\r\n#### Session Validation Middleware\r\n```javascript\r\n// middleware/auth.js\r\nconst requireAuth = async (req, res, next) => {\r\n  try {\r\n    // Check if session exists\r\n    if (!req.session) {\r\n      return res.status(401).json({\r\n        success: false,\r\n        error: 'No session found'\r\n      });\r\n    }\r\n    \r\n    // Check if user is in session\r\n    if (!req.session.user) {\r\n      return res.status(401).json({\r\n        success: false,\r\n        error: 'Authentication required'\r\n      });\r\n    }\r\n    \r\n    // Check session expiry\r\n    const now = new Date();\r\n    const lastActivity = new Date(req.session.lastActivity);\r\n    const sessionTimeout = 30 * 60 * 1000; // 30 minutes\r\n    \r\n    if (now - lastActivity > sessionTimeout) {\r\n      req.session.destroy();\r\n      return res.status(401).json({\r\n        success: false,\r\n        error: 'Session expired'\r\n      });\r\n    }\r\n    \r\n    // Update last activity\r\n    req.session.lastActivity = now;\r\n    \r\n    // Verify user still exists and is active\r\n    const [users] = await db.execute(\r\n      'SELECT id, email, name, role, is_active FROM users WHERE id = ? AND is_active = 1',\r\n      [req.session.user.id]\r\n    );\r\n    \r\n    if (users.length === 0) {\r\n      req.session.destroy();\r\n      return res.status(401).json({\r\n        success: false,\r\n        error: 'User account not found or inactive'\r\n      });\r\n    }\r\n    \r\n    // Update session with current user data\r\n    req.session.user = users[0];\r\n    \r\n    next();\r\n  } catch (error) {\r\n    logger.error('Auth middleware error:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      error: 'Authentication check failed'\r\n    });\r\n  }\r\n};\r\n```\r\n\r\n### 2. Session Lifecycle\r\n\r\n```\r\n┌─────────────────┐\r\n│  Session Start  │\r\n│  (Login)        │\r\n└─────────────────┘\r\n         │\r\n         ▼\r\n┌─────────────────┐\r\n│  Create Session │\r\n│  Store in MySQL │\r\n│  Set Cookie     │\r\n└─────────────────┘\r\n         │\r\n         ▼\r\n┌─────────────────┐\r\n│  Session Active │\r\n│  Validate on    │\r\n│  Each Request   │\r\n└─────────────────┘\r\n         │\r\n         ▼\r\n┌─────────────────┐\r\n│  Session Update │\r\n│  Last Activity  │\r\n│  Rolling Expiry │\r\n└─────────────────┘\r\n         │\r\n         ▼\r\n┌─────────────────┐\r\n│  Session End    │\r\n│  (Logout/Expire)│\r\n│  Clear Cookie   │\r\n└─────────────────┘\r\n```\r\n\r\n## 🔐 Authorization Flow\r\n\r\n### 1. Role-Based Access Control\r\n\r\n#### Role Hierarchy\r\n```javascript\r\n// utils/roles.js\r\nconst ROLES = {\r\n  SUPER_ADMIN: 'super_admin',\r\n  ADMIN: 'admin',\r\n  MODERATOR: 'moderator',\r\n  USER: 'user'\r\n};\r\n\r\nconst ROLE_LEVELS = {\r\n  [ROLES.SUPER_ADMIN]: 4,\r\n  [ROLES.ADMIN]: 3,\r\n  [ROLES.MODERATOR]: 2,\r\n  [ROLES.USER]: 1\r\n};\r\n\r\nconst hasRole = (userRole, requiredRole) => {\r\n  return ROLE_LEVELS[userRole] >= ROLE_LEVELS[requiredRole];\r\n};\r\n```\r\n\r\n#### Permission Checking Middleware\r\n```javascript\r\n// middleware/permissions.js\r\nconst requireRole = (requiredRole) => {\r\n  return async (req, res, next) => {\r\n    try {\r\n      // First check authentication\r\n      if (!req.session?.user) {\r\n        return res.status(401).json({\r\n          success: false,\r\n          error: 'Authentication required'\r\n        });\r\n      }\r\n      \r\n      const userRole = req.session.user.role;\r\n      \r\n      // Check if user has required role\r\n      if (!hasRole(userRole, requiredRole)) {\r\n        await logSecurityEvent('ACCESS_DENIED', {\r\n          userId: req.session.user.id,\r\n          userRole: userRole,\r\n          requiredRole: requiredRole,\r\n          resource: req.path,\r\n          ip: req.ip\r\n        });\r\n        \r\n        return res.status(403).json({\r\n          success: false,\r\n          error: 'Insufficient permissions'\r\n        });\r\n      }\r\n      \r\n      next();\r\n    } catch (error) {\r\n      logger.error('Permission check error:', error);\r\n      res.status(500).json({\r\n        success: false,\r\n        error: 'Permission check failed'\r\n      });\r\n    }\r\n  };\r\n};\r\n\r\nconst requirePermission = (permission) => {\r\n  return async (req, res, next) => {\r\n    try {\r\n      if (!req.session?.user) {\r\n        return res.status(401).json({\r\n          success: false,\r\n          error: 'Authentication required'\r\n        });\r\n      }\r\n      \r\n      const userRole = req.session.user.role;\r\n      const userPermissions = ROLE_PERMISSIONS[userRole] || [];\r\n      \r\n      if (!userPermissions.includes(permission)) {\r\n        await logSecurityEvent('PERMISSION_DENIED', {\r\n          userId: req.session.user.id,\r\n          userRole: userRole,\r\n          permission: permission,\r\n          resource: req.path,\r\n          ip: req.ip\r\n        });\r\n        \r\n        return res.status(403).json({\r\n          success: false,\r\n          error: 'Permission denied'\r\n        });\r\n      }\r\n      \r\n      next();\r\n    } catch (error) {\r\n      logger.error('Permission check error:', error);\r\n      res.status(500).json({\r\n        success: false,\r\n        error: 'Permission check failed'\r\n      });\r\n    }\r\n  };\r\n};\r\n```\r\n\r\n### 2. Resource-Based Access Control\r\n\r\n#### Resource Ownership Check\r\n```javascript\r\n// middleware/resourceAuth.js\r\nconst requireOwnership = (resourceType) => {\r\n  return async (req, res, next) => {\r\n    try {\r\n      const resourceId = req.params.id;\r\n      const userId = req.session.user.id;\r\n      const userRole = req.session.user.role;\r\n      \r\n      // Admins can access any resource\r\n      if (userRole === 'admin' || userRole === 'super_admin') {\r\n        return next();\r\n      }\r\n      \r\n      // Check resource ownership\r\n      let ownershipQuery;\r\n      \r\n      switch (resourceType) {\r\n        case 'user':\r\n          // Users can only access their own profile\r\n          if (resourceId != userId) {\r\n            return res.status(403).json({\r\n              success: false,\r\n              error: 'Access denied'\r\n            });\r\n          }\r\n          break;\r\n          \r\n        case 'church':\r\n          // Check if user is assigned to this church\r\n          ownershipQuery = 'SELECT id FROM user_churches WHERE user_id = ? AND church_id = ?';\r\n          break;\r\n          \r\n        case 'notification':\r\n          // Check if notification belongs to user\r\n          ownershipQuery = 'SELECT id FROM notifications WHERE user_id = ? AND id = ?';\r\n          break;\r\n          \r\n        default:\r\n          return res.status(400).json({\r\n            success: false,\r\n            error: 'Invalid resource type'\r\n          });\r\n      }\r\n      \r\n      if (ownershipQuery) {\r\n        const [results] = await db.execute(ownershipQuery, [userId, resourceId]);\r\n        \r\n        if (results.length === 0) {\r\n          return res.status(403).json({\r\n            success: false,\r\n            error: 'Access denied'\r\n          });\r\n        }\r\n      }\r\n      \r\n      next();\r\n    } catch (error) {\r\n      logger.error('Resource auth error:', error);\r\n      res.status(500).json({\r\n        success: false,\r\n        error: 'Authorization check failed'\r\n      });\r\n    }\r\n  };\r\n};\r\n```\r\n\r\n## 🔄 Password Change Flow\r\n\r\n### 1. Password Change Process\r\n\r\n#### Frontend Password Change\r\n```typescript\r\n// ChangePassword component\r\nconst handlePasswordChange = async (passwordData: PasswordChangeData) => {\r\n  try {\r\n    const response = await fetch('/api/auth/change-password', {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json'\r\n      },\r\n      credentials: 'include',\r\n      body: JSON.stringify(passwordData)\r\n    });\r\n    \r\n    const data = await response.json();\r\n    \r\n    if (data.success) {\r\n      setMessage('Password changed successfully');\r\n      setPasswordData({\r\n        currentPassword: '',\r\n        newPassword: '',\r\n        confirmPassword: ''\r\n      });\r\n    } else {\r\n      setError(data.error);\r\n    }\r\n  } catch (error) {\r\n    setError('Failed to change password');\r\n  }\r\n};\r\n```\r\n\r\n#### Backend Password Change Handler\r\n```javascript\r\n// controllers/authController.js\r\nconst changePassword = async (req, res) => {\r\n  try {\r\n    const { currentPassword, newPassword } = req.body;\r\n    const userId = req.session.user.id;\r\n    \r\n    // Validate input\r\n    if (!currentPassword || !newPassword) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        error: 'Current and new passwords are required'\r\n      });\r\n    }\r\n    \r\n    // Validate new password strength\r\n    const passwordValidation = validatePassword(newPassword);\r\n    if (!passwordValidation.isValid) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        error: 'Password does not meet requirements',\r\n        requirements: passwordValidation.requirements\r\n      });\r\n    }\r\n    \r\n    // Get current user\r\n    const [users] = await db.execute(\r\n      'SELECT password FROM users WHERE id = ?',\r\n      [userId]\r\n    );\r\n    \r\n    if (users.length === 0) {\r\n      return res.status(404).json({\r\n        success: false,\r\n        error: 'User not found'\r\n      });\r\n    }\r\n    \r\n    // Verify current password\r\n    const isValidPassword = await bcrypt.compare(currentPassword, users[0].password);\r\n    \r\n    if (!isValidPassword) {\r\n      await logSecurityEvent('PASSWORD_CHANGE_FAILED', {\r\n        userId: userId,\r\n        reason: 'Invalid current password',\r\n        ip: req.ip\r\n      });\r\n      \r\n      return res.status(401).json({\r\n        success: false,\r\n        error: 'Current password is incorrect'\r\n      });\r\n    }\r\n    \r\n    // Check password history\r\n    const isPasswordReused = await checkPasswordHistory(userId, newPassword);\r\n    \r\n    if (isPasswordReused) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        error: 'Cannot reuse recent passwords'\r\n      });\r\n    }\r\n    \r\n    // Hash new password\r\n    const hashedPassword = await bcrypt.hash(newPassword, 12);\r\n    \r\n    // Update password\r\n    await db.execute(\r\n      'UPDATE users SET password = ?, password_changed_at = CURRENT_TIMESTAMP WHERE id = ?',\r\n      [hashedPassword, userId]\r\n    );\r\n    \r\n    // Add to password history\r\n    await db.execute(\r\n      'INSERT INTO password_history (user_id, password_hash, created_at) VALUES (?, ?, CURRENT_TIMESTAMP)',\r\n      [userId, hashedPassword]\r\n    );\r\n    \r\n    // Clean old password history (keep last 5)\r\n    await db.execute(\r\n      'DELETE FROM password_history WHERE user_id = ? AND id NOT IN (SELECT id FROM (SELECT id FROM password_history WHERE user_id = ? ORDER BY created_at DESC LIMIT 5) AS t)',\r\n      [userId, userId]\r\n    );\r\n    \r\n    // Log successful password change\r\n    await logSecurityEvent('PASSWORD_CHANGED', {\r\n      userId: userId,\r\n      ip: req.ip\r\n    });\r\n    \r\n    res.json({\r\n      success: true,\r\n      message: 'Password changed successfully'\r\n    });\r\n    \r\n  } catch (error) {\r\n    logger.error('Change password error:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      error: 'Password change failed'\r\n    });\r\n  }\r\n};\r\n```\r\n\r\n## 🚪 Logout Flow\r\n\r\n### 1. Logout Process\r\n\r\n#### Frontend Logout\r\n```typescript\r\n// Logout function\r\nconst handleLogout = async () => {\r\n  try {\r\n    const response = await fetch('/api/auth/logout', {\r\n      method: 'POST',\r\n      credentials: 'include'\r\n    });\r\n    \r\n    const data = await response.json();\r\n    \r\n    if (data.success) {\r\n      // Clear auth context\r\n      setUser(null);\r\n      setIsAuthenticated(false);\r\n      \r\n      // Redirect to login\r\n      navigate('/login');\r\n    }\r\n  } catch (error) {\r\n    console.error('Logout error:', error);\r\n    // Force logout on error\r\n    setUser(null);\r\n    setIsAuthenticated(false);\r\n    navigate('/login');\r\n  }\r\n};\r\n```\r\n\r\n#### Backend Logout Handler\r\n```javascript\r\n// controllers/authController.js\r\nconst logout = async (req, res) => {\r\n  try {\r\n    const userId = req.session?.user?.id;\r\n    const sessionId = req.sessionID;\r\n    \r\n    // Log logout event\r\n    if (userId) {\r\n      await logSecurityEvent('LOGOUT', {\r\n        userId: userId,\r\n        sessionId: sessionId,\r\n        ip: req.ip\r\n      });\r\n    }\r\n    \r\n    // Destroy session\r\n    req.session.destroy((err) => {\r\n      if (err) {\r\n        logger.error('Session destroy error:', err);\r\n        return res.status(500).json({\r\n          success: false,\r\n          error: 'Logout failed'\r\n        });\r\n      }\r\n      \r\n      // Clear session cookie\r\n      res.clearCookie('orthodox.sid');\r\n      \r\n      res.json({\r\n        success: true,\r\n        message: 'Logout successful'\r\n      });\r\n    });\r\n    \r\n  } catch (error) {\r\n    logger.error('Logout error:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      error: 'Logout failed'\r\n    });\r\n  }\r\n};\r\n```\r\n\r\n## 🔍 Session Debugging\r\n\r\n### 1. Session Debug Endpoint\r\n\r\n#### Debug Session Information\r\n```javascript\r\n// routes/debug.js\r\nrouter.get('/session', (req, res) => {\r\n  try {\r\n    const sessionInfo = {\r\n      sessionId: req.sessionID,\r\n      hasSession: !!req.session,\r\n      user: req.session?.user || null,\r\n      isAuthenticated: !!req.session?.user,\r\n      loginTime: req.session?.loginTime || null,\r\n      lastActivity: req.session?.lastActivity || null,\r\n      cookie: req.session?.cookie || null\r\n    };\r\n    \r\n    res.json({\r\n      success: true,\r\n      session: sessionInfo\r\n    });\r\n  } catch (error) {\r\n    res.status(500).json({\r\n      success: false,\r\n      error: 'Session debug failed'\r\n    });\r\n  }\r\n});\r\n```\r\n\r\n### 2. Authentication Flow Testing\r\n\r\n#### Test Authentication Endpoints\r\n```javascript\r\n// Test script for authentication flows\r\nconst testAuthentication = async () => {\r\n  try {\r\n    // Test login\r\n    const loginResponse = await fetch('/api/auth/login', {\r\n      method: 'POST',\r\n      headers: { 'Content-Type': 'application/json' },\r\n      credentials: 'include',\r\n      body: JSON.stringify({\r\n        email: 'admin@example.com',\r\n        password: '[REDACTED]'\r\n      })\r\n    });\r\n    \r\n    console.log('Login:', await loginResponse.json());\r\n    \r\n    // Test session\r\n    const sessionResponse = await fetch('/api/debug/session', {\r\n      credentials: 'include'\r\n    });\r\n    \r\n    console.log('Session:', await sessionResponse.json());\r\n    \r\n    // Test protected route\r\n    const protectedResponse = await fetch('/api/admin/users', {\r\n      credentials: 'include'\r\n    });\r\n    \r\n    console.log('Protected route:', await protectedResponse.json());\r\n    \r\n    // Test logout\r\n    const logoutResponse = await fetch('/api/auth/logout', {\r\n      method: 'POST',\r\n      credentials: 'include'\r\n    });\r\n    \r\n    console.log('Logout:', await logoutResponse.json());\r\n    \r\n  } catch (error) {\r\n    console.error('Test error:', error);\r\n  }\r\n};\r\n```\r\n\r\n## 📊 Authentication Metrics\r\n\r\n### 1. Security Metrics Tracking\r\n\r\n#### Failed Login Attempts\r\n```javascript\r\n// utils/loginAttempts.js\r\nconst redis = require('redis');\r\nconst client = redis.createClient();\r\n\r\nconst incrementFailedAttempts = async (ip) => {\r\n  const key = `failed_attempts:${ip}`;\r\n  await client.incr(key);\r\n  await client.expire(key, 900); // 15 minutes\r\n};\r\n\r\nconst getFailedAttempts = async (ip) => {\r\n  const key = `failed_attempts:${ip}`;\r\n  const attempts = await client.get(key);\r\n  return parseInt(attempts) || 0;\r\n};\r\n\r\nconst clearFailedAttempts = async (ip) => {\r\n  const key = `failed_attempts:${ip}`;\r\n  await client.del(key);\r\n};\r\n```\r\n\r\n#### Session Statistics\r\n```javascript\r\n// utils/sessionStats.js\r\nconst getSessionStats = async () => {\r\n  const [results] = await db.execute(`\r\n    SELECT \r\n      COUNT(*) as total_sessions,\r\n      COUNT(DISTINCT JSON_EXTRACT(data, '$.user.id')) as active_users,\r\n      AVG(TIMESTAMPDIFF(MINUTE, FROM_UNIXTIME(JSON_EXTRACT(data, '$.loginTime')/1000), NOW())) as avg_session_length\r\n    FROM sessions \r\n    WHERE expires > NOW()\r\n  `);\r\n  \r\n  return results[0];\r\n};\r\n```\r\n\r\n---\r\n\r\n*This authentication flow documentation provides comprehensive coverage of the Orthodox Metrics authentication system. It should be updated whenever authentication flows are modified or enhanced.*\r\n"
    },
    "complexity": {
      "totalLines": 927,
      "codeLines": 690,
      "commentLines": 101,
      "commentRatio": 0.1276864728192162,
      "averageLineLength": 29.268015170670036
    },
    "lastAnalyzed": "2025-07-28T07:19:58.139Z"
  },
  "contentHash": "1426d9720f45d480bcc0d878d1adfac28298427a40c2fbcdfa308a34ef29fb9b",
  "discoveredAt": "2025-07-28T07:19:58.139Z"
}