{
  "id": "911e9c1052c9",
  "originalPath": "/var/www/orthodox-church-mgmt/orthodoxmetrics/prod/server/routes/notifications.js",
  "relativePath": "server/routes/notifications.js",
  "name": "notifications.js",
  "extension": ".js",
  "size": 39903,
  "modified": "2025-07-22T14:44:35.263Z",
  "created": "2025-07-09T00:48:38.478Z",
  "classification": {
    "type": "Server Scripts",
    "category": "Backend > Server",
    "confidence": 7
  },
  "metadata": {
    "fileStats": {
      "lines": 962,
      "characters": 39887,
      "words": 3535
    },
    "classification": {
      "type": "Server Scripts",
      "category": "Backend > Server",
      "confidence": 7
    },
    "dependencies": [
      {
        "type": "npm_package",
        "name": "express",
        "line": 1
      },
      {
        "type": "npm_package",
        "name": "mysql2/promise",
        "line": 3
      },
      {
        "type": "npm_package",
        "name": "nodemailer",
        "line": 8
      }
    ],
    "security": {
      "findings": [
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 19,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 20,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 24,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 25,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 26,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 28,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 29,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 315,
          "redacted": true
        }
      ],
      "hasSecurityIssues": true,
      "redactedContent": "const express = require('express');\r\nconst router = express.Router();\r\nconst mysql = require('mysql2/promise');\r\nconst { requireAuth, requireRole } = require('../middleware/auth');\r\nconst { promisePool } = require('../../config/db');\r\n\r\n// Email service (you might want to use nodemailer or another service)\r\nconst nodemailer = require('nodemailer');\r\n\r\n// Use the existing connection pool instead of creating new connections\r\nconst getConnection = () => promisePool;\r\n\r\n// Initialize email transporter (configure with your email service)\r\nconst emailTransporter = nodemailer.createTransport({\r\n    // Configure your email service here\r\n    // Example for Gmail:\r\n    // service: 'gmail',\r\n    // auth: {\r\n    //     user: process.env.[REDACTED],\r\n    //     pass: process.env.[REDACTED]\r\n    // }\r\n\r\n    // Example for SMTP:\r\n    host: process.env.[REDACTED] || 'localhost',\r\n    port: process.env.[REDACTED] || 587,\r\n    secure: process.env.[REDACTED] === 'true',\r\n    auth: {\r\n        user: process.env.[REDACTED],\r\n        pass: process.env.[REDACTED]\r\n    }\r\n});\r\n\r\n// ============================================================================\r\n// Notification Service Class\r\n// ============================================================================\r\nclass NotificationService {\r\n    // Create a new notification\r\n    async createNotification(userId, typeName, title, message, options = {}) {\r\n        try {\r\n            const {\r\n                data = null,\r\n                priority = 'normal',\r\n                actionUrl = null,\r\n                actionText = null,\r\n                expiresAt = null,\r\n                icon = null,\r\n                imageUrl = null\r\n            } = options;\r\n\r\n            // Get notification type\r\n            const [typeRows] = await promisePool.execute(\r\n                'SELECT id FROM notification_types WHERE name = ? AND is_active = TRUE',\r\n                [typeName]\r\n            );\r\n\r\n            if (typeRows.length === 0) {\r\n                throw new Error(`Notification type '${typeName}' not found or inactive`);\r\n            }\r\n\r\n            const typeId = typeRows[0].id;\r\n\r\n            // Create notification\r\n            const [result] = await promisePool.execute(`\r\n                INSERT INTO notifications (\r\n                    user_id, notification_type_id, title, message, data, \r\n                    priority, action_url, action_text, expires_at, icon, image_url\r\n                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\r\n            `, [userId, typeId, title, message, JSON.stringify(data), priority, actionUrl, actionText, expiresAt, icon, imageUrl]);\r\n\r\n            return result.insertId;\r\n        } catch (error) {\r\n            console.error('Error creating notification:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    // Get user notifications\r\n    async getUserNotifications(userId, options = {}) {\r\n        const connection = getConnection();\r\n\r\n        try {\r\n            const {\r\n                limit = 20,\r\n                offset = 0,\r\n                unreadOnly = false,\r\n                category = null,\r\n                priority = null\r\n            } = options;\r\n\r\n            let query = `\r\n                SELECT n.*, nt.name as type_name, nt.category\r\n                FROM notifications n\r\n                JOIN notification_types nt ON n.notification_type_id = nt.id\r\n                WHERE n.user_id = ? \r\n                AND n.is_dismissed = FALSE\r\n                AND (n.expires_at IS NULL OR n.expires_at > NOW())\r\n            `;\r\n\r\n            const params = [userId];\r\n\r\n            if (unreadOnly) {\r\n                query += ' AND n.is_read = FALSE';\r\n            }\r\n\r\n            if (category) {\r\n                query += ' AND nt.category = ?';\r\n                params.push(category);\r\n            }\r\n\r\n            if (priority) {\r\n                query += ' AND n.priority = ?';\r\n                params.push(priority);\r\n            }\r\n\r\n            query += ' ORDER BY n.priority DESC, n.created_at DESC LIMIT ? OFFSET ?';\r\n            params.push(limit, offset);\r\n\r\n            const [notifications] = await connection.execute(query, params);\r\n\r\n            // Parse JSON data\r\n            notifications.forEach(notification => {\r\n                if (notification.data) {\r\n                    try {\r\n                        notification.data = JSON.parse(notification.data);\r\n                    } catch (e) {\r\n                        notification.data = null;\r\n                    }\r\n                }\r\n            });\r\n\r\n            return notifications;\r\n        } catch (error) {\r\n            console.error('Error getting user notifications:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    // Mark notification as read\r\n    async markAsRead(notificationId, userId) {\r\n        const connection = getConnection();\r\n\r\n        try {\r\n            const [result] = await connection.execute(`\r\n                UPDATE notifications \r\n                SET is_read = TRUE, read_at = NOW() \r\n                WHERE id = ? AND user_id = ?\r\n            `, [notificationId, userId]);\r\n\r\n            return result.affectedRows > 0;\r\n        } catch (error) {\r\n            console.error('Error marking notification as read:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    // Mark all notifications as read\r\n    async markAllAsRead(userId) {\r\n        const connection = getConnection();\r\n\r\n        try {\r\n            const [result] = await connection.execute(`\r\n                UPDATE notifications \r\n                SET is_read = TRUE, read_at = NOW() \r\n                WHERE user_id = ? AND is_read = FALSE\r\n            `, [userId]);\r\n\r\n            return result.affectedRows;\r\n        } catch (error) {\r\n            console.error('Error marking all notifications as read:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    // Dismiss notification\r\n    async dismissNotification(notificationId, userId) {\r\n        const connection = getConnection();\r\n\r\n        try {\r\n            const [result] = await connection.execute(`\r\n                UPDATE notifications \r\n                SET is_dismissed = TRUE, dismissed_at = NOW() \r\n                WHERE id = ? AND user_id = ?\r\n            `, [notificationId, userId]);\r\n\r\n            return result.affectedRows > 0;\r\n        } catch (error) {\r\n            console.error('Error dismissing notification:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    // Get notification counts\r\n    async getNotificationCounts(userId) {\r\n        const connection = getConnection();\r\n\r\n        try {\r\n            const [countRows] = await connection.execute(`\r\n                SELECT \r\n                    COUNT(*) as total,\r\n                    SUM(CASE WHEN is_read = FALSE THEN 1 ELSE 0 END) as unread,\r\n                    SUM(CASE WHEN priority = 'urgent' AND is_read = FALSE THEN 1 ELSE 0 END) as urgent,\r\n                    SUM(CASE WHEN priority = 'high' AND is_read = FALSE THEN 1 ELSE 0 END) as high\r\n                FROM notifications \r\n                WHERE user_id = ? \r\n                AND is_dismissed = FALSE\r\n                AND (expires_at IS NULL OR expires_at > NOW())\r\n            `, [userId]);\r\n\r\n            return countRows[0];\r\n        } catch (error) {\r\n            console.error('Error getting notification counts:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    // Queue email notification\r\n    async queueEmailNotification(userId, typeName, templateData, options = {}) {\r\n        const connection = getConnection();\r\n\r\n        try {\r\n            const {\r\n                priority = 'normal',\r\n                scheduledAt = null,\r\n                recipientEmail = null\r\n            } = options;\r\n\r\n            // Get notification type and template\r\n            const [typeRows] = await connection.execute(`\r\n                SELECT nt.id, nt.name, ntp.id as template_id, ntp.subject, ntp.body_html, ntp.body_text\r\n                FROM notification_types nt\r\n                LEFT JOIN notification_templates ntp ON nt.id = ntp.notification_type_id\r\n                WHERE nt.name = ? AND nt.is_active = TRUE\r\n                ORDER BY ntp.language = 'en' DESC\r\n                LIMIT 1\r\n            `, [typeName]);\r\n\r\n            if (typeRows.length === 0) {\r\n                throw new Error(`Notification type '${typeName}' not found`);\r\n            }\r\n\r\n            const type = typeRows[0];\r\n            let emailBody = type.body_html || type.body_text;\r\n            let subject = type.subject;\r\n\r\n            // Replace template variables\r\n            if (emailBody && templateData) {\r\n                Object.keys(templateData).forEach(key => {\r\n                    const regex = new RegExp(`{{${key}}}`, 'g');\r\n                    emailBody = emailBody.replace(regex, templateData[key]);\r\n                    if (subject) {\r\n                        subject = subject.replace(regex, templateData[key]);\r\n                    }\r\n                });\r\n            }\r\n\r\n            // Get recipient email if not provided\r\n            if (!recipientEmail) {\r\n                const [userRows] = await connection.execute(\r\n                    'SELECT email FROM users WHERE id = ?',\r\n                    [userId]\r\n                );\r\n\r\n                if (userRows.length === 0) {\r\n                    throw new Error('User not found');\r\n                }\r\n                recipientEmail = userRows[0].email;\r\n            }\r\n\r\n            // Queue the email\r\n            const [result] = await connection.execute(`\r\n                INSERT INTO notification_queue (\r\n                    user_id, notification_type_id, template_id, recipient_email,\r\n                    subject, message, html_message, data, priority, delivery_method,\r\n                    scheduled_at\r\n                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, 'email', ?)\r\n            `, [\r\n                userId, type.id, type.template_id, recipientEmail,\r\n                subject, type.body_text, emailBody, JSON.stringify(templateData),\r\n                priority, scheduledAt || new Date()\r\n            ]);\r\n\r\n            return result.insertId;\r\n        } catch (error) {\r\n            console.error('Error queuing email notification:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    // Process email queue\r\n    async processEmailQueue() {\r\n        const connection = getConnection();\r\n\r\n        try {\r\n            // Get pending emails\r\n            const [pendingEmails] = await connection.execute(`\r\n                SELECT * FROM notification_queue\r\n                WHERE delivery_method = 'email' \r\n                AND status = 'pending'\r\n                AND scheduled_at <= NOW()\r\n                AND attempts < max_attempts\r\n                ORDER BY priority DESC, scheduled_at ASC\r\n                LIMIT 50\r\n            `);\r\n\r\n            for (const email of pendingEmails) {\r\n                try {\r\n                    // Update status to processing\r\n                    await connection.execute(\r\n                        'UPDATE notification_queue SET status = \"processing\", attempts = attempts + 1 WHERE id = ?',\r\n                        [email.id]\r\n                    );\r\n\r\n                    // Send email\r\n                    const mailOptions = {\r\n                        from: process.env.[REDACTED] || 'noreply@orthodoxmetrics.com',\r\n                        to: email.recipient_email,\r\n                        subject: email.subject,\r\n                        text: email.message,\r\n                        html: email.html_message\r\n                    };\r\n\r\n                    await emailTransporter.sendMail(mailOptions);\r\n\r\n                    // Mark as sent\r\n                    await connection.execute(\r\n                        'UPDATE notification_queue SET status = \"sent\", sent_at = NOW() WHERE id = ?',\r\n                        [email.id]\r\n                    );\r\n\r\n                    // Record in history\r\n                    await connection.execute(`\r\n                        INSERT INTO notification_history (\r\n                            user_id, notification_type_id, template_id, delivery_method,\r\n                            recipient, subject, message, status, sent_at\r\n                        ) VALUES (?, ?, ?, 'email', ?, ?, ?, 'sent', NOW())\r\n                    `, [\r\n                        email.user_id, email.notification_type_id, email.template_id,\r\n                        email.recipient_email, email.subject, email.message\r\n                    ]);\r\n\r\n                    console.log(`Email sent successfully to ${email.recipient_email}`);\r\n                } catch (error) {\r\n                    console.error(`Error sending email to ${email.recipient_email}:`, error);\r\n\r\n                    // Mark as failed if max attempts reached\r\n                    if (email.attempts >= email.max_attempts - 1) {\r\n                        await connection.execute(\r\n                            'UPDATE notification_queue SET status = \"failed\", failed_at = NOW(), error_message = ? WHERE id = ?',\r\n                            [error.message, email.id]\r\n                        );\r\n                    } else {\r\n                        await connection.execute(\r\n                            'UPDATE notification_queue SET status = \"pending\" WHERE id = ?',\r\n                            [email.id]\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n\r\n            return pendingEmails.length;\r\n        } catch (error) {\r\n            console.error('Error processing email queue:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    // Get user notification preferences\r\n    async getUserPreferences(userId) {\r\n        const connection = getConnection();\r\n\r\n        try {\r\n            const [preferences] = await connection.execute(`\r\n                SELECT \r\n                    nt.name as type_name,\r\n                    nt.category,\r\n                    COALESCE(unp.email_enabled, nt.default_enabled) as email_enabled,\r\n                    COALESCE(unp.push_enabled, nt.default_enabled) as push_enabled,\r\n                    COALESCE(unp.in_app_enabled, nt.default_enabled) as in_app_enabled,\r\n                    COALESCE(unp.sms_enabled, FALSE) as sms_enabled,\r\n                    COALESCE(unp.frequency, 'immediate') as frequency\r\n                FROM notification_types nt\r\n                LEFT JOIN user_notification_preferences unp ON nt.id = unp.notification_type_id AND unp.user_id = ?\r\n                WHERE nt.is_active = TRUE\r\n                ORDER BY nt.category, nt.name\r\n            `, [userId]);\r\n\r\n            return preferences;\r\n        } catch (error) {\r\n            console.error('Error getting user preferences:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    // Update user notification preferences\r\n    async updateUserPreferences(userId, preferences) {\r\n        const connection = getConnection();\r\n\r\n        try {\r\n            for (const pref of preferences) {\r\n                const [typeRows] = await connection.execute(\r\n                    'SELECT id FROM notification_types WHERE name = ?',\r\n                    [pref.type_name]\r\n                );\r\n\r\n                if (typeRows.length > 0) {\r\n                    await connection.execute(`\r\n                        INSERT INTO user_notification_preferences (\r\n                            user_id, notification_type_id, email_enabled, push_enabled, \r\n                            in_app_enabled, sms_enabled, frequency\r\n                        ) VALUES (?, ?, ?, ?, ?, ?, ?)\r\n                        ON DUPLICATE KEY UPDATE\r\n                        email_enabled = VALUES(email_enabled),\r\n                        push_enabled = VALUES(push_enabled),\r\n                        in_app_enabled = VALUES(in_app_enabled),\r\n                        sms_enabled = VALUES(sms_enabled),\r\n                        frequency = VALUES(frequency),\r\n                        updated_at = NOW()\r\n                    `, [\r\n                        userId, typeRows[0].id, pref.email_enabled, pref.push_enabled,\r\n                        pref.in_app_enabled, pref.sms_enabled, pref.frequency\r\n                    ]);\r\n                }\r\n            }\r\n\r\n            return true;\r\n        } catch (error) {\r\n            console.error('Error updating user preferences:', error);\r\n            throw error;\r\n        }\r\n    }\r\n}\r\n\r\n// Create notification service instance\r\nconst notificationService = new NotificationService();\r\n\r\n// Initialize notification types if they don't exist (only run on first API call)\r\nlet initializationAttempted = false;\r\n\r\nasync function initializeNotificationTypes() {\r\n    if (initializationAttempted) return;\r\n    initializationAttempted = true;\r\n    \r\n    try {\r\n        console.log('📢 Checking notification types...');\r\n        const [types] = await promisePool.execute('SELECT COUNT(*) as count FROM notification_types');\r\n        console.log(`✅ Found ${types[0].count} notification types in database`);\r\n        \r\n        if (types[0].count === 0) {\r\n            console.log('📢 No notification types found, creating defaults...');\r\n            await promisePool.execute(`\r\n                INSERT INTO notification_types (name, description, category, default_enabled) VALUES\r\n                ('welcome', 'Welcome message for new users', 'user', TRUE),\r\n                ('password_reset', 'Password reset notifications', 'security', TRUE),\r\n                ('login_alert', 'Login alert notifications', 'security', TRUE),\r\n                ('profile_updated', 'Profile update confirmations', 'user', TRUE),\r\n                ('backup_completed', 'Backup completion notifications', 'backup', TRUE),\r\n                ('backup_failed', 'Backup failure notifications', 'backup', TRUE),\r\n                ('certificate_ready', 'Certificate ready notifications', 'certificates', TRUE),\r\n                ('certificate_expiring', 'Certificate expiring reminders', 'certificates', TRUE),\r\n                ('invoice_created', 'New invoice notifications', 'billing', TRUE),\r\n                ('invoice_paid', 'Invoice payment confirmations', 'billing', TRUE),\r\n                ('invoice_overdue', 'Overdue invoice reminders', 'billing', TRUE),\r\n                ('system_maintenance', 'System maintenance notifications', 'system', TRUE),\r\n                ('system_alert', 'System alert notifications', 'system', TRUE),\r\n                ('user_activity', 'User activity notifications', 'admin', FALSE),\r\n                ('data_export_ready', 'Data export ready notifications', 'system', TRUE),\r\n                ('reminder_baptism', 'Baptism anniversary reminders', 'reminders', TRUE),\r\n                ('reminder_marriage', 'Marriage anniversary reminders', 'reminders', TRUE),\r\n                ('reminder_funeral', 'Memorial service reminders', 'reminders', TRUE),\r\n                ('note_shared', 'Note sharing notifications', 'user', TRUE),\r\n                ('note_comment', 'Note comment notifications', 'user', TRUE),\r\n                ('church_invitation', 'Church invitation notifications', 'user', TRUE),\r\n                ('role_changed', 'Role change notifications', 'admin', TRUE),\r\n                ('account_locked', 'Account security notifications', 'security', TRUE),\r\n                ('weekly_digest', 'Weekly activity digest', 'user', FALSE),\r\n                ('monthly_report', 'Monthly report notifications', 'admin', FALSE)\r\n            `);\r\n            console.log('✅ Default notification types created');\r\n        }\r\n    } catch (error) {\r\n        console.error('Warning: Could not initialize notification types:', error.message);\r\n        // Don't throw error - let the system continue working\r\n    }\r\n}\r\n\r\n// ============================================================================\r\n// API Routes\r\n// ============================================================================\r\n\r\n// Get user notifications\r\nrouter.get('/notifications', requireAuth, async (req, res) => {\r\n    try {\r\n        // Initialize notification types on first API call (when database connection is established)\r\n        await initializeNotificationTypes();\r\n        \r\n        const { limit = 20, offset = 0, unread_only = false, category, priority } = req.query;\r\n        const userId = req.session?.user?.id || req.user?.id;\r\n        if (!userId) {\r\n            return res.status(401).json({ success: false, message: 'User not authenticated' });\r\n        }\r\n\r\n        const notifications = await notificationService.getUserNotifications(userId, {\r\n            limit: parseInt(limit),\r\n            offset: parseInt(offset),\r\n            unreadOnly: unread_only === 'true',\r\n            category,\r\n            priority\r\n        });\r\n\r\n        res.json({\r\n            success: true,\r\n            notifications,\r\n            pagination: {\r\n                limit: parseInt(limit),\r\n                offset: parseInt(offset),\r\n                total: notifications.length\r\n            }\r\n        });\r\n    } catch (error) {\r\n        console.error('Error fetching notifications:', error);\r\n        \r\n        // If it's a database connection issue, return empty notifications instead of error\r\n        if (error.code === 'ER_ACCESS_DENIED_NO_PASSWORD_ERROR' || error.code === 'ECONNREFUSED') {\r\n            console.log('Database connection issue, returning empty notifications');\r\n            res.json({\r\n                success: true,\r\n                notifications: [],\r\n                pagination: { limit: 20, offset: 0, total: 0 },\r\n                message: 'Notifications temporarily unavailable'\r\n            });\r\n        } else {\r\n            res.status(500).json({ success: false, message: 'Failed to fetch notifications' });\r\n        }\r\n    }\r\n});\r\n\r\n// Get notification counts - /api/notifications/counts\r\nrouter.get('/notifications/counts', requireAuth, async (req, res) => {\r\n    try {\r\n        const userId = req.session?.user?.id || req.user?.id;\r\n        if (!userId) {\r\n            return res.status(401).json({ success: false, message: 'User not authenticated' });\r\n        }\r\n        const counts = await notificationService.getNotificationCounts(userId);\r\n        res.json({ success: true, counts });\r\n    } catch (error) {\r\n        console.error('Error fetching notification counts:', error);\r\n        \r\n        // If it's a database connection issue, return zero counts instead of error\r\n        if (error.code === 'ER_ACCESS_DENIED_NO_PASSWORD_ERROR' || error.code === 'ECONNREFUSED') {\r\n            console.log('Database connection issue, returning zero counts');\r\n            res.json({\r\n                success: true,\r\n                counts: { total: 0, unread: 0, urgent: 0, high: 0 }\r\n            });\r\n        } else {\r\n            res.status(500).json({ success: false, message: 'Failed to fetch notification counts' });\r\n        }\r\n    }\r\n});\r\n\r\n// Get notification counts - /notifications/counts (direct route for proxy compatibility)\r\nrouter.get('/counts', requireAuth, async (req, res) => {\r\n    try {\r\n        const userId = req.session?.user?.id || req.user?.id;\r\n        if (!userId) {\r\n            return res.status(401).json({ success: false, message: 'User not authenticated' });\r\n        }\r\n        const counts = await notificationService.getNotificationCounts(userId);\r\n        res.json({ success: true, counts });\r\n    } catch (error) {\r\n        console.error('Error fetching notification counts:', error);\r\n        \r\n        // If it's a database connection issue, return zero counts instead of error\r\n        if (error.code === 'ER_ACCESS_DENIED_NO_PASSWORD_ERROR' || error.code === 'ECONNREFUSED') {\r\n            console.log('Database connection issue, returning zero counts');\r\n            res.json({\r\n                success: true,\r\n                counts: { total: 0, unread: 0, urgent: 0, high: 0 }\r\n            });\r\n        } else {\r\n            res.status(500).json({ success: false, message: 'Failed to fetch notification counts' });\r\n        }\r\n    }\r\n});\r\n\r\n// Mark notification as read\r\nrouter.put('/notifications/:id/read', requireAuth, async (req, res) => {\r\n    try {\r\n        const { id } = req.params;\r\n        const userId = req.session?.user?.id || req.user?.id;\r\n        if (!userId) {\r\n            return res.status(401).json({ success: false, message: 'User not authenticated' });\r\n        }\r\n        const success = await notificationService.markAsRead(id, userId);\r\n\r\n        if (success) {\r\n            res.json({ success: true, message: 'Notification marked as read' });\r\n        } else {\r\n            res.status(404).json({ success: false, message: 'Notification not found' });\r\n        }\r\n    } catch (error) {\r\n        console.error('Error marking notification as read:', error);\r\n        res.status(500).json({ success: false, message: 'Failed to mark notification as read' });\r\n    }\r\n});\r\n\r\n// Mark all notifications as read\r\nrouter.put('/notifications/read-all', requireAuth, async (req, res) => {\r\n    try {\r\n        const userId = req.session?.user?.id || req.user?.id;\r\n        if (!userId) {\r\n            return res.status(401).json({ success: false, message: 'User not authenticated' });\r\n        }\r\n        const updatedCount = await notificationService.markAllAsRead(userId);\r\n        res.json({ success: true, message: `${updatedCount} notifications marked as read` });\r\n    } catch (error) {\r\n        console.error('Error marking all notifications as read:', error);\r\n        res.status(500).json({ success: false, message: 'Failed to mark all notifications as read' });\r\n    }\r\n});\r\n\r\n// Dismiss notification\r\nrouter.delete('/notifications/:id', requireAuth, async (req, res) => {\r\n    try {\r\n        const { id } = req.params;\r\n        const userId = req.session?.user?.id || req.user?.id;\r\n        if (!userId) {\r\n            return res.status(401).json({ success: false, message: 'User not authenticated' });\r\n        }\r\n        const success = await notificationService.dismissNotification(id, userId);\r\n\r\n        if (success) {\r\n            res.json({ success: true, message: 'Notification dismissed' });\r\n        } else {\r\n            res.status(404).json({ success: false, message: 'Notification not found' });\r\n        }\r\n    } catch (error) {\r\n        console.error('Error dismissing notification:', error);\r\n        res.status(500).json({ success: false, message: 'Failed to dismiss notification' });\r\n    }\r\n});\r\n\r\n// Get user notification preferences\r\nrouter.get('/notifications/preferences', requireAuth, async (req, res) => {\r\n    try {\r\n        const userId = req.session?.user?.id || req.user?.id;\r\n        if (!userId) {\r\n            return res.status(401).json({ success: false, message: 'User not authenticated' });\r\n        }\r\n        const preferences = await notificationService.getUserPreferences(userId);\r\n        res.json({ success: true, preferences });\r\n    } catch (error) {\r\n        console.error('Error fetching notification preferences:', error);\r\n        res.status(500).json({ success: false, message: 'Failed to fetch notification preferences' });\r\n    }\r\n});\r\n\r\n// Update user notification preferences\r\nrouter.put('/notifications/preferences', requireAuth, async (req, res) => {\r\n    try {\r\n        const { preferences } = req.body;\r\n        const userId = req.session?.user?.id || req.user?.id;\r\n        if (!userId) {\r\n            return res.status(401).json({ success: false, message: 'User not authenticated' });\r\n        }\r\n        await notificationService.updateUserPreferences(userId, preferences);\r\n        res.json({ success: true, message: 'Notification preferences updated' });\r\n    } catch (error) {\r\n        console.error('Error updating notification preferences:', error);\r\n        res.status(500).json({ success: false, message: 'Failed to update notification preferences' });\r\n    }\r\n});\r\n\r\n// Admin routes\r\nrouter.get('/admin/notifications/types', requireRole(['super_admin']), async (req, res) => {\r\n    try {\r\n        const connection = getConnection();\r\n        const [types] = await connection.execute('SELECT * FROM notification_types ORDER BY category, name');\r\n        res.json({ success: true, types });\r\n    } catch (error) {\r\n        console.error('Error fetching notification types:', error);\r\n        res.status(500).json({ success: false, message: 'Failed to fetch notification types' });\r\n    }\r\n});\r\n\r\nrouter.get('/admin/notifications/templates', requireRole(['super_admin']), async (req, res) => {\r\n    try {\r\n        const connection = getConnection();\r\n        const [templates] = await connection.execute(`\r\n            SELECT nt.*, ntp.name as type_name, ntp.category\r\n            FROM notification_templates nt\r\n            JOIN notification_types ntp ON nt.notification_type_id = ntp.id\r\n            ORDER BY ntp.category, ntp.name, nt.language\r\n        `);\r\n        res.json({ success: true, templates });\r\n    } catch (error) {\r\n        console.error('Error fetching notification templates:', error);\r\n        res.status(500).json({ success: false, message: 'Failed to fetch notification templates' });\r\n    }\r\n});\r\n\r\nrouter.get('/admin/notifications/queue', requireRole(['super_admin']), async (req, res) => {\r\n    try {\r\n        const connection = getConnection();\r\n        \r\n        // Get custom notifications (drafts and scheduled)\r\n        const [customNotifications] = await connection.execute(`\r\n            SELECT \r\n                n.id,\r\n                n.title,\r\n                n.message,\r\n                n.priority,\r\n                n.created_at,\r\n                n.data,\r\n                CASE \r\n                    WHEN JSON_EXTRACT(n.data, '$.is_draft') = true THEN 'draft'\r\n                    WHEN JSON_EXTRACT(n.data, '$.scheduled_at') IS NOT NULL THEN 'pending'\r\n                    ELSE 'sent'\r\n                END as status,\r\n                COALESCE(JSON_EXTRACT(n.data, '$.scheduled_at'), n.created_at) as scheduled_at,\r\n                COALESCE(JSON_EXTRACT(n.data, '$.target_audience'), 'unknown') as target_audience,\r\n                COALESCE(JSON_EXTRACT(n.data, '$.target_user_count'), 1) as user_count\r\n            FROM notifications n\r\n            WHERE JSON_EXTRACT(n.data, '$.custom_notification') = true\r\n            ORDER BY n.created_at DESC\r\n            LIMIT 50\r\n        `);\r\n        \r\n        // Also get email queue if it exists\r\n        let emailQueue = [];\r\n        try {\r\n            const [emailResults] = await connection.execute(`\r\n                SELECT nq.*, nt.name as type_name, u.email as user_email\r\n                FROM notification_queue nq\r\n                JOIN notification_types nt ON nq.notification_type_id = nt.id\r\n                JOIN users u ON nq.user_id = u.id\r\n                ORDER BY nq.priority DESC, nq.scheduled_at ASC\r\n                LIMIT 50\r\n            `);\r\n            emailQueue = emailResults;\r\n        } catch (emailError) {\r\n            // Email queue table might not exist, that's okay\r\n            console.log('Email queue table not found, skipping...');\r\n        }\r\n        \r\n        // Process custom notifications to clean up the data\r\n        const processedCustom = customNotifications.map(notif => ({\r\n            id: notif.id,\r\n            title: notif.title,\r\n            message: notif.message,\r\n            priority: notif.priority,\r\n            scheduled_at: notif.scheduled_at,\r\n            target_audience: notif.target_audience?.replace(/\"/g, '') || 'all',\r\n            status: notif.status,\r\n            created_at: notif.created_at,\r\n            user_count: parseInt(notif.user_count) || 0\r\n        }));\r\n        \r\n        res.json({ \r\n            success: true, \r\n            queue: processedCustom,\r\n            emailQueue: emailQueue \r\n        });\r\n    } catch (error) {\r\n        console.error('Error fetching notification queue:', error);\r\n        res.status(500).json({ success: false, message: 'Failed to fetch notification queue' });\r\n    }\r\n});\r\n\r\n// Process email queue manually (for testing)\r\nrouter.post('/admin/notifications/process-queue', requireRole(['super_admin']), async (req, res) => {\r\n    try {\r\n        const processedCount = await notificationService.processEmailQueue();\r\n        res.json({ success: true, message: `Processed ${processedCount} emails` });\r\n    } catch (error) {\r\n        console.error('Error processing email queue:', error);\r\n        res.status(500).json({ success: false, message: 'Failed to process email queue' });\r\n    }\r\n});\r\n\r\n// Get all notification types for admin management\r\nrouter.get('/admin/notifications/types', requireRole(['super_admin']), async (req, res) => {\r\n    try {\r\n        const connection = getConnection();\r\n        const [types] = await connection.execute(`\r\n            SELECT id, name, description, category, default_enabled, is_active\r\n            FROM notification_types\r\n            ORDER BY category, name\r\n        `);\r\n        res.json({ success: true, types });\r\n    } catch (error) {\r\n        console.error('Error fetching notification types:', error);\r\n        res.status(500).json({ success: false, message: 'Failed to fetch notification types' });\r\n    }\r\n});\r\n\r\n// Toggle notification type system-wide\r\nrouter.put('/admin/notifications/types/:id/toggle', requireRole(['super_admin']), async (req, res) => {\r\n    try {\r\n        const { id } = req.params;\r\n        const { enabled } = req.body;\r\n        \r\n        const connection = getConnection();\r\n        const [result] = await connection.execute(`\r\n            UPDATE notification_types \r\n            SET default_enabled = ?\r\n            WHERE id = ?\r\n        `, [enabled, id]);\r\n        \r\n        if (result.affectedRows === 0) {\r\n            return res.status(404).json({ success: false, message: 'Notification type not found' });\r\n        }\r\n        \r\n        console.log(`📢 Notification type ${id} ${enabled ? 'enabled' : 'disabled'} system-wide by ${req.session.user?.email}`);\r\n        res.json({ success: true, message: `Notification type ${enabled ? 'enabled' : 'disabled'} system-wide` });\r\n    } catch (error) {\r\n        console.error('Error toggling notification type:', error);\r\n        res.status(500).json({ success: false, message: 'Failed to update notification type' });\r\n    }\r\n});\r\n\r\n// Create custom system-wide notification\r\nrouter.post('/admin/notifications/custom', requireRole(['super_admin']), async (req, res) => {\r\n    try {\r\n        const {\r\n            title,\r\n            message,\r\n            priority = 'normal',\r\n            scheduled_at = null,\r\n            target_audience = 'all',\r\n            church_id = null,\r\n            icon = '📢',\r\n            action_url = null,\r\n            action_text = null,\r\n            is_draft = false\r\n        } = req.body;\r\n        \r\n        if (!title || !message) {\r\n            return res.status(400).json({ success: false, message: 'Title and message are required' });\r\n        }\r\n        \r\n        const connection = getConnection();\r\n        \r\n        // If not a draft and no scheduled time, send immediately\r\n        const shouldSendNow = !is_draft && !scheduled_at;\r\n        const scheduledDate = scheduled_at ? new Date(scheduled_at) : (shouldSendNow ? new Date() : null);\r\n        \r\n        // Get target users based on audience\r\n        let userQuery = '';\r\n        let userParams = [];\r\n        \r\n        switch (target_audience) {\r\n            case 'all':\r\n                userQuery = 'SELECT id FROM users WHERE is_active = 1';\r\n                break;\r\n            case 'admins':\r\n                userQuery = \"SELECT id FROM users WHERE role IN ('admin', 'super_admin') AND is_active = 1\";\r\n                break;\r\n            case 'users':\r\n                userQuery = \"SELECT id FROM users WHERE role NOT IN ('admin', 'super_admin') AND is_active = 1\";\r\n                break;\r\n            case 'church_specific':\r\n                if (!church_id) {\r\n                    return res.status(400).json({ success: false, message: 'Church ID required for church-specific notifications' });\r\n                }\r\n                userQuery = 'SELECT id FROM users WHERE church_id = ? AND is_active = 1';\r\n                userParams = [church_id];\r\n                break;\r\n            default:\r\n                return res.status(400).json({ success: false, message: 'Invalid target audience' });\r\n        }\r\n        \r\n        // Get target user IDs\r\n        const [users] = await connection.execute(userQuery, userParams);\r\n        \r\n        if (users.length === 0) {\r\n            return res.status(400).json({ success: false, message: 'No target users found for this audience' });\r\n        }\r\n        \r\n        // If sending now, create notifications for all target users\r\n        if (shouldSendNow) {\r\n            const notifications = users.map(user => [\r\n                user.id,\r\n                1, // Use 'system_alert' notification type\r\n                title,\r\n                message,\r\n                JSON.stringify({\r\n                    target_audience,\r\n                    church_id,\r\n                    custom_notification: true,\r\n                    created_by: req.session.user?.email\r\n                }),\r\n                priority,\r\n                action_url,\r\n                action_text,\r\n                null, // expires_at\r\n                icon,\r\n                null // image_url\r\n            ]);\r\n            \r\n            await connection.execute(`\r\n                INSERT INTO notifications (\r\n                    user_id, notification_type_id, title, message, data, \r\n                    priority, action_url, action_text, expires_at, icon, image_url\r\n                ) VALUES ?\r\n            `, [notifications]);\r\n            \r\n            console.log(`📢 Custom notification \"${title}\" sent to ${users.length} users by ${req.session.user?.email}`);\r\n            res.json({ \r\n                success: true, \r\n                message: `Notification sent to ${users.length} users`,\r\n                recipients: users.length\r\n            });\r\n        } else {\r\n            // Store in custom notifications queue/history table (you may need to create this table)\r\n            // For now, we'll create a single notification record to track the custom notification\r\n            const [result] = await connection.execute(`\r\n                INSERT INTO notifications (\r\n                    user_id, notification_type_id, title, message, data, \r\n                    priority, action_url, action_text, expires_at, icon, image_url\r\n                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\r\n            `, [\r\n                req.session.user.id, // Store under the creator's ID for drafts\r\n                1, // system_alert type\r\n                title,\r\n                message,\r\n                JSON.stringify({\r\n                    target_audience,\r\n                    church_id,\r\n                    scheduled_at: scheduledDate?.toISOString(),\r\n                    is_draft,\r\n                    target_user_count: users.length,\r\n                    custom_notification: true,\r\n                    created_by: req.session.user?.email\r\n                }),\r\n                priority,\r\n                action_url,\r\n                action_text,\r\n                null,\r\n                icon,\r\n                null\r\n            ]);\r\n            \r\n            const status = is_draft ? 'saved as draft' : 'scheduled';\r\n            console.log(`📢 Custom notification \"${title}\" ${status} by ${req.session.user?.email}`);\r\n            res.json({ \r\n                success: true, \r\n                message: `Notification ${status} successfully`,\r\n                id: result.insertId,\r\n                scheduled_recipients: users.length\r\n            });\r\n        }\r\n    } catch (error) {\r\n        console.error('Error creating custom notification:', error);\r\n        res.status(500).json({ success: false, message: 'Failed to create custom notification' });\r\n    }\r\n});\r\n\r\n// Export the service and router\r\nmodule.exports = { router, notificationService };\r\n"
    },
    "complexity": {
      "totalLines": 962,
      "codeLines": 782,
      "commentLines": 71,
      "commentRatio": 0.08323563892145369,
      "averageLineLength": 45.273153575615474
    },
    "lastAnalyzed": "2025-07-28T07:20:00.521Z"
  },
  "contentHash": "8de4a161b5336325e444e087767a939ac7e575c2dfe5922d645c94c14d0c9fd2",
  "discoveredAt": "2025-07-28T07:20:00.521Z"
}