{
  "id": "7813c6d92732",
  "originalPath": "/var/www/orthodox-church-mgmt/orthodoxmetrics/prod/server/routes/churchSetupWizard.js",
  "relativePath": "server/routes/churchSetupWizard.js",
  "name": "churchSetupWizard.js",
  "extension": ".js",
  "size": 30664,
  "modified": "2025-07-19T14:45:09.439Z",
  "created": "2025-07-13T23:32:43.145Z",
  "classification": {
    "type": "Server Scripts",
    "category": "Backend > Server",
    "confidence": 7
  },
  "metadata": {
    "fileStats": {
      "lines": 857,
      "characters": 28888,
      "words": 2511
    },
    "classification": {
      "type": "Server Scripts",
      "category": "Backend > Server",
      "confidence": 7
    },
    "dependencies": [
      {
        "type": "npm_package",
        "name": "express",
        "line": 2
      },
      {
        "type": "npm_package",
        "name": "mysql2/promise",
        "line": 3
      },
      {
        "type": "npm_package",
        "name": "bcrypt",
        "line": 4
      },
      {
        "type": "npm_package",
        "name": "multer",
        "line": 5
      },
      {
        "type": "npm_package",
        "name": "path",
        "line": 6
      },
      {
        "type": "npm_package",
        "name": "fs",
        "line": 7
      }
    ],
    "security": {
      "findings": [
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 41,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 42,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 43,
          "redacted": true
        }
      ],
      "hasSecurityIssues": true,
      "redactedContent": "// Backend API routes for Church Setup Wizard\r\nconst express = require('express');\r\nconst mysql = require('mysql2/promise');\r\nconst bcrypt = require('bcrypt');\r\nconst multer = require('multer');\r\nconst path = require('path');\r\nconst fs = require('fs').promises;\r\nconst ChurchProvisioner = require('../church-provisioner');\r\nconst TestChurchDataGenerator = require('../services/testChurchDataGenerator');\r\n\r\nconst router = express.Router();\r\n\r\n// Configure multer for logo uploads\r\nconst storage = multer.diskStorage({\r\n  destination: async (req, file, cb) => {\r\n    const uploadDir = path.join(__dirname, '../uploads/logos');\r\n    await fs.mkdir(uploadDir, { recursive: true });\r\n    cb(null, uploadDir);\r\n  },\r\n  filename: (req, file, cb) => {\r\n    const churchId = req.params.church_id || 'temp';\r\n    const extension = path.extname(file.originalname);\r\n    cb(null, `church-${churchId}-logo${extension}`);\r\n  }\r\n});\r\n\r\nconst upload = multer({\r\n  storage,\r\n  fileFilter: (req, file, cb) => {\r\n    if (file.mimetype === 'image/png' || file.mimetype === 'image/svg+xml') {\r\n      cb(null, true);\r\n    } else {\r\n      cb(new Error('Only PNG and SVG files are allowed'), false);\r\n    }\r\n  },\r\n  limits: { fileSize: 5 * 1024 * 1024 } // 5MB limit\r\n});\r\n\r\n// Database configuration\r\nconst getDbConfig = () => ({\r\n  host: process.env.[REDACTED] || 'localhost',\r\n  user: process.env.[REDACTED] || 'root',\r\n  password: process.env.[REDACTED] || '',\r\n  multipleStatements: true\r\n});\r\n\r\n// Generate unique church ID\r\nconst generateChurchId = (name) => {\r\n  const prefix = name\r\n    .split(' ')\r\n    .map(word => word.charAt(0).toUpperCase())\r\n    .join('')\r\n    .substring(0, 6);\r\n  \r\n  const timestamp = Date.now().toString().slice(-6);\r\n  return `${prefix}_${timestamp}`;\r\n};\r\n\r\n// Generate database name\r\nconst generateDbName = (name) => {\r\n  return name\r\n    .toLowerCase()\r\n    .replace(/[^a-z0-9\\s]/g, '')\r\n    .replace(/\\s+/g, '_')\r\n    .replace(/_+/g, '_')\r\n    .replace(/^_|_$/g, '')\r\n    .substring(0, 50) + '_db';\r\n};\r\n\r\n// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\r\n// CHURCH CREATION API\r\n// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\r\n\r\n// POST /api/churches - Create new church\r\nrouter.post('/', async (req, res) => {\r\n  try {\r\n    const churchData = req.body;\r\n    \r\n    // Validate required fields\r\n    if (!churchData.name || !churchData.email) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        error: 'Church name and email are required'\r\n      });\r\n    }\r\n\r\n    // Generate church ID and database name\r\n    const church_id = generateChurchId(churchData.name);\r\n    const database_name = generateDbName(churchData.name);\r\n    const slug = church_id.toLowerCase();\r\n\r\n    // Extract template setup options\r\n    const templateOptions = {\r\n      setup_templates: churchData.setup_templates === 'true' || churchData.setup_templates === true,\r\n      auto_setup_standard: churchData.auto_setup_standard === 'true' || churchData.auto_setup_standard === true,\r\n      generate_components: churchData.generate_components === 'true' || churchData.generate_components === true,\r\n      record_types: churchData.record_types ? JSON.parse(churchData.record_types) : ['baptism', 'marriage', 'funeral'],\r\n      template_style: churchData.template_style || 'orthodox_traditional'\r\n    };\r\n\r\n    // Extract test church options\r\n    const testChurchOptions = {\r\n      is_test_church: churchData.is_test_church === 'true' || churchData.is_test_church === true,\r\n      auto_populate_data: churchData.auto_populate_data === 'true' || churchData.auto_populate_data === true,\r\n      include_sample_records: churchData.include_sample_records === 'true' || churchData.include_sample_records === true,\r\n      sample_record_count: parseInt(churchData.sample_record_count) || 50\r\n    };\r\n\r\n    console.log('üìã Church creation request:', {\r\n      name: churchData.name,\r\n      email: churchData.email,\r\n      template_options: templateOptions,\r\n      test_church_options: testChurchOptions\r\n    });\r\n\r\n    // Use the church provisioner to create the database\r\n    const provisioner = new ChurchProvisioner();\r\n    const result = await provisioner.createChurchDatabase({\r\n      ...churchData,\r\n      church_id,\r\n      database_name,\r\n      slug,\r\n      is_test_church: testChurchOptions.is_test_church\r\n    });\r\n\r\n    if (result.success) {\r\n      let templateResult = null;\r\n      let testDataResult = null;\r\n      \r\n      // If template setup is requested, configure templates\r\n      if (templateOptions.setup_templates) {\r\n        try {\r\n          console.log('üéØ Setting up templates for church:', church_id);\r\n          \r\n          // Here you would integrate with your template service\r\n          // For now, we'll create a mock response\r\n          templateResult = {\r\n            success: true,\r\n            templates_created: templateOptions.record_types.length,\r\n            record_types: templateOptions.record_types,\r\n            style: templateOptions.template_style,\r\n            components_generated: templateOptions.generate_components\r\n          };\r\n          \r\n          console.log('‚úÖ Templates configured successfully');\r\n        } catch (templateError) {\r\n          console.error('‚ö†Ô∏è  Template setup failed, but church was created:', templateError);\r\n          // Don't fail the entire process if templates fail\r\n          templateResult = {\r\n            success: false,\r\n            error: templateError.message,\r\n            note: 'Church created successfully, but template setup failed'\r\n          };\r\n        }\r\n      }\r\n\r\n      // If test church, populate with sample data\r\n      if (testChurchOptions.is_test_church && testChurchOptions.auto_populate_data) {\r\n        try {\r\n          console.log('üß™ Generating test data for church:', church_id);\r\n          \r\n          const dataGenerator = new TestChurchDataGenerator();\r\n          const sampleData = await dataGenerator.generateCompleteTestData({\r\n            baptismCount: testChurchOptions.include_sample_records ? \r\n              Math.floor(testChurchOptions.sample_record_count * 0.6) : 0,\r\n            marriageCount: testChurchOptions.include_sample_records ? \r\n              Math.floor(testChurchOptions.sample_record_count * 0.3) : 0,\r\n            funeralCount: testChurchOptions.include_sample_records ? \r\n              Math.floor(testChurchOptions.sample_record_count * 0.1) : 0,\r\n            clergyCount: 5,\r\n            userCount: 8\r\n          });\r\n\r\n          // Insert sample data into church database\r\n          await insertTestDataIntoDatabase(database_name, sampleData);\r\n          \r\n          testDataResult = {\r\n            success: true,\r\n            records_created: {\r\n              baptisms: sampleData.baptismRecords.length,\r\n              marriages: sampleData.marriageRecords.length,\r\n              funerals: sampleData.funeralRecords.length,\r\n              clergy: sampleData.clergy.length,\r\n              users: sampleData.users.length\r\n            },\r\n            total_records: sampleData.baptismRecords.length + \r\n                          sampleData.marriageRecords.length + \r\n                          sampleData.funeralRecords.length\r\n          };\r\n          \r\n          console.log('‚úÖ Test data populated successfully');\r\n        } catch (testDataError) {\r\n          console.error('‚ö†Ô∏è  Test data population failed:', testDataError);\r\n          testDataResult = {\r\n            success: false,\r\n            error: testDataError.message,\r\n            note: 'Church created successfully, but test data population failed'\r\n          };\r\n        }\r\n      }\r\n\r\n      const response = {\r\n        success: true,\r\n        church_id: result.churchId,\r\n        slug: slug,\r\n        database_name: result.databaseName,\r\n        message: testChurchOptions.is_test_church ? \r\n          'Test church created successfully with sample data' : \r\n          'Church created successfully',\r\n        template_setup: templateResult,\r\n        test_data: testDataResult\r\n      };\r\n\r\n      // Add setup status information\r\n      if (templateResult) {\r\n        response.setup_status = {\r\n          church_created: true,\r\n          admin_user_created: true,\r\n          templates_setup: templateResult.success,\r\n          setup_step: templateResult.success ? 'complete' : 'templates_pending'\r\n        };\r\n      } else {\r\n        response.setup_status = {\r\n          church_created: true,\r\n          admin_user_created: true,\r\n          templates_setup: false,\r\n          setup_step: 'templates_pending'\r\n        };\r\n      }\r\n\r\n      res.json(response);\r\n    } else {\r\n      throw new Error(result.message || 'Failed to create church');\r\n    }\r\n\r\n  } catch (error) {\r\n    console.error('Church creation error:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      error: error.message || 'Failed to create church'\r\n    });\r\n  }\r\n});\r\n\r\n// GET /api/churches/recent - Get recently added churches\r\nrouter.get('/recent', async (req, res) => {\r\n  try {\r\n    const limit = parseInt(req.query.limit) || 10;\r\n    const connection = await mysql.createConnection({\r\n      ...getDbConfig(),\r\n      database: 'orthodoxmetrics_main'\r\n    });\r\n\r\n    try {\r\n      const [churches] = await connection.execute(`\r\n        SELECT id, church_id, name, email, database_name, created_at\r\n        FROM churches \r\n        WHERE is_active = TRUE\r\n        ORDER BY created_at DESC \r\n        LIMIT ?\r\n      `, [limit]);\r\n\r\n      res.json({\r\n        success: true,\r\n        churches: churches\r\n      });\r\n    } finally {\r\n      await connection.end();\r\n    }\r\n\r\n  } catch (error) {\r\n    console.error('Failed to load recent churches:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      error: 'Failed to load recent churches'\r\n    });\r\n  }\r\n});\r\n\r\n// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\r\n// CHURCH SETUP WIZARD API\r\n// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\r\n\r\n// POST /api/churches/test-connection/:church_id - Test database connection\r\nrouter.post('/test-connection/:church_id', async (req, res) => {\r\n  try {\r\n    const { church_id } = req.params;\r\n    \r\n    // Get church database name from main registry\r\n    const mainConnection = await mysql.createConnection({\r\n      ...getDbConfig(),\r\n      database: 'orthodoxmetrics_main'\r\n    });\r\n\r\n    try {\r\n      const [churches] = await mainConnection.execute(\r\n        'SELECT database_name FROM churches WHERE church_id = ?',\r\n        [church_id]\r\n      );\r\n\r\n      if (churches.length === 0) {\r\n        return res.status(404).json({\r\n          success: false,\r\n          error: 'Church not found'\r\n        });\r\n      }\r\n\r\n      const database_name = churches[0].database_name;\r\n\r\n      // Test connection to church database\r\n      const churchConnection = await mysql.createConnection({\r\n        ...getDbConfig(),\r\n        database: database_name\r\n      });\r\n\r\n      try {\r\n        // Test basic query\r\n        await churchConnection.execute('SELECT 1');\r\n        \r\n        res.json({\r\n          success: true,\r\n          message: 'Database connection successful',\r\n          database_name\r\n        });\r\n      } finally {\r\n        await churchConnection.end();\r\n      }\r\n\r\n    } finally {\r\n      await mainConnection.end();\r\n    }\r\n\r\n  } catch (error) {\r\n    console.error('Database connection test failed:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      error: 'Database connection failed: ' + error.message\r\n    });\r\n  }\r\n});\r\n\r\n// GET /api/churches/:church_id/details - Get church details and record counts\r\nrouter.get('/:church_id/details', async (req, res) => {\r\n  try {\r\n    const { church_id } = req.params;\r\n    \r\n    // Get church database name\r\n    const mainConnection = await mysql.createConnection({\r\n      ...getDbConfig(),\r\n      database: 'orthodoxmetrics_main'\r\n    });\r\n\r\n    let database_name;\r\n    try {\r\n      const [churches] = await mainConnection.execute(\r\n        'SELECT database_name FROM churches WHERE church_id = ?',\r\n        [church_id]\r\n      );\r\n\r\n      if (churches.length === 0) {\r\n        return res.status(404).json({\r\n          success: false,\r\n          error: 'Church not found'\r\n        });\r\n      }\r\n\r\n      database_name = churches[0].database_name;\r\n    } finally {\r\n      await mainConnection.end();\r\n    }\r\n\r\n    // Get church details from church database\r\n    const churchConnection = await mysql.createConnection({\r\n      ...getDbConfig(),\r\n      database: database_name\r\n    });\r\n\r\n    try {\r\n      // Get church info from platform database\r\n      const [churchInfo] = await promisePool.query(\r\n        'SELECT * FROM churches WHERE id = ?',\r\n        [req.params.id || 1]\r\n      );\r\n\r\n      if (churchInfo.length === 0) {\r\n        return res.status(404).json({\r\n          success: false,\r\n          error: 'Church information not found'\r\n        });\r\n      }\r\n\r\n      const church = churchInfo[0];\r\n\r\n      // Get record counts\r\n      const [baptismCount] = await churchConnection.execute('SELECT COUNT(*) as count FROM baptism_records');\r\n      const [marriageCount] = await churchConnection.execute('SELECT COUNT(*) as count FROM marriage_records');\r\n      const [funeralCount] = await churchConnection.execute('SELECT COUNT(*) as count FROM funeral_records');\r\n\r\n      const details = {\r\n        name: church.name,\r\n        email: church.email,\r\n        language: church.language_preference || 'en',\r\n        timezone: church.timezone || 'UTC',\r\n        city: church.city || '',\r\n        country: church.country || '',\r\n        address: church.address || '',\r\n        phone: church.phone || '',\r\n        tax_id: church.tax_id || '',\r\n        recordCounts: {\r\n          baptism: baptismCount[0].count,\r\n          marriage: marriageCount[0].count,\r\n          funeral: funeralCount[0].count\r\n        }\r\n      };\r\n\r\n      res.json({\r\n        success: true,\r\n        details\r\n      });\r\n\r\n    } finally {\r\n      await churchConnection.end();\r\n    }\r\n\r\n  } catch (error) {\r\n    console.error('Failed to load church details:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      error: 'Failed to load church details'\r\n    });\r\n  }\r\n});\r\n\r\n// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\r\n// CLERGY MANAGEMENT API\r\n// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\r\n\r\n// GET /api/churches/:church_id/clergy - Get clergy members\r\nrouter.get('/:church_id/clergy', async (req, res) => {\r\n  try {\r\n    const { church_id } = req.params;\r\n    const database_name = await getChurchDatabase(church_id);\r\n    \r\n    const connection = await mysql.createConnection({\r\n      ...getDbConfig(),\r\n      database: database_name\r\n    });\r\n\r\n    try {\r\n      // Create clergy table if it doesn't exist\r\n      await connection.execute(`\r\n        CREATE TABLE IF NOT EXISTS clergy (\r\n          id INT AUTO_INCREMENT PRIMARY KEY,\r\n          church_id INT NOT NULL DEFAULT 1,\r\n          name VARCHAR(255) NOT NULL,\r\n          title VARCHAR(100) DEFAULT '',\r\n          email VARCHAR(255) NOT NULL,\r\n          phone VARCHAR(50) DEFAULT '',\r\n          role VARCHAR(100) NOT NULL,\r\n          is_active BOOLEAN DEFAULT TRUE,\r\n          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\r\n          updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\r\n          \r\n          INDEX idx_clergy_church_id (church_id),\r\n          INDEX idx_clergy_active (is_active)\r\n        )\r\n      `);\r\n\r\n      const [clergy] = await connection.execute(\r\n        'SELECT * FROM clergy WHERE church_id = 1 AND is_active = TRUE ORDER BY name'\r\n      );\r\n\r\n      res.json({\r\n        success: true,\r\n        clergy\r\n      });\r\n\r\n    } finally {\r\n      await connection.end();\r\n    }\r\n\r\n  } catch (error) {\r\n    console.error('Failed to load clergy:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      error: 'Failed to load clergy members'\r\n    });\r\n  }\r\n});\r\n\r\n// POST /api/churches/:church_id/clergy - Add clergy member\r\nrouter.post('/:church_id/clergy', async (req, res) => {\r\n  try {\r\n    const { church_id } = req.params;\r\n    const { name, title, email, phone, role } = req.body;\r\n\r\n    if (!name || !email || !role) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        error: 'Name, email, and role are required'\r\n      });\r\n    }\r\n\r\n    const database_name = await getChurchDatabase(church_id);\r\n    const connection = await mysql.createConnection({\r\n      ...getDbConfig(),\r\n      database: database_name\r\n    });\r\n\r\n    try {\r\n      const [result] = await connection.execute(`\r\n        INSERT INTO clergy (church_id, name, title, email, phone, role)\r\n        VALUES (1, ?, ?, ?, ?, ?)\r\n      `, [name, title, email, phone, role]);\r\n\r\n      const [newClergy] = await connection.execute(\r\n        'SELECT * FROM clergy WHERE id = ?',\r\n        [result.insertId]\r\n      );\r\n\r\n      res.json({\r\n        success: true,\r\n        clergy: newClergy[0],\r\n        message: 'Clergy member added successfully'\r\n      });\r\n\r\n    } finally {\r\n      await connection.end();\r\n    }\r\n\r\n  } catch (error) {\r\n    console.error('Failed to add clergy member:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      error: 'Failed to add clergy member'\r\n    });\r\n  }\r\n});\r\n\r\n// DELETE /api/churches/:church_id/clergy/:clergy_id - Remove clergy member\r\nrouter.delete('/:church_id/clergy/:clergy_id', async (req, res) => {\r\n  try {\r\n    const { church_id, clergy_id } = req.params;\r\n    const database_name = await getChurchDatabase(church_id);\r\n    \r\n    const connection = await mysql.createConnection({\r\n      ...getDbConfig(),\r\n      database: database_name\r\n    });\r\n\r\n    try {\r\n      await connection.execute(\r\n        'UPDATE clergy SET is_active = FALSE WHERE id = ? AND church_id = 1',\r\n        [clergy_id]\r\n      );\r\n\r\n      res.json({\r\n        success: true,\r\n        message: 'Clergy member removed successfully'\r\n      });\r\n\r\n    } finally {\r\n      await connection.end();\r\n    }\r\n\r\n  } catch (error) {\r\n    console.error('Failed to remove clergy member:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      error: 'Failed to remove clergy member'\r\n    });\r\n  }\r\n});\r\n\r\n// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\r\n// BRANDING & CUSTOMIZATION API\r\n// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\r\n\r\n// POST /api/churches/:church_id/branding - Save branding settings\r\nrouter.post('/:church_id/branding', upload.single('logo'), async (req, res) => {\r\n  try {\r\n    const { church_id } = req.params;\r\n    const { primaryColor, secondaryColor, agGridTheme } = req.body;\r\n    const logoPath = req.file ? req.file.path : null;\r\n\r\n    const database_name = await getChurchDatabase(church_id);\r\n    const connection = await mysql.createConnection({\r\n      ...getDbConfig(),\r\n      database: database_name\r\n    });\r\n\r\n    try {\r\n      // Create branding table if it doesn't exist\r\n      await connection.execute(`\r\n        CREATE TABLE IF NOT EXISTS branding (\r\n          id INT AUTO_INCREMENT PRIMARY KEY,\r\n          church_id INT NOT NULL DEFAULT 1,\r\n          logo_path VARCHAR(500) DEFAULT NULL,\r\n          primary_color VARCHAR(7) DEFAULT '#1976d2',\r\n          secondary_color VARCHAR(7) DEFAULT '#dc004e',\r\n          ag_grid_theme VARCHAR(50) DEFAULT 'ag-theme-alpine',\r\n          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\r\n          updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\r\n          \r\n          UNIQUE KEY uk_branding_church (church_id)\r\n        )\r\n      `);\r\n\r\n      // Insert or update branding settings\r\n      await connection.execute(`\r\n        INSERT INTO branding (church_id, logo_path, primary_color, secondary_color, ag_grid_theme)\r\n        VALUES (1, ?, ?, ?, ?)\r\n        ON DUPLICATE KEY UPDATE\r\n          logo_path = VALUES(logo_path),\r\n          primary_color = VALUES(primary_color),\r\n          secondary_color = VALUES(secondaryColor),\r\n          ag_grid_theme = VALUES(ag_grid_theme),\r\n          updated_at = CURRENT_TIMESTAMP\r\n      `, [logoPath, primaryColor, secondaryColor, agGridTheme]);\r\n\r\n      res.json({\r\n        success: true,\r\n        message: 'Branding settings saved successfully'\r\n      });\r\n\r\n    } finally {\r\n      await connection.end();\r\n    }\r\n\r\n  } catch (error) {\r\n    console.error('Failed to save branding settings:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      error: 'Failed to save branding settings'\r\n    });\r\n  }\r\n});\r\n\r\n// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\r\n// HELPER FUNCTIONS\r\n// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\r\n\r\nasync function getChurchDatabase(church_id) {\r\n  const mainConnection = await mysql.createConnection({\r\n    ...getDbConfig(),\r\n    database: 'orthodoxmetrics_main'\r\n  });\r\n\r\n  try {\r\n    const [churches] = await mainConnection.execute(\r\n      'SELECT database_name FROM churches WHERE church_id = ?',\r\n      [church_id]\r\n    );\r\n\r\n    if (churches.length === 0) {\r\n      throw new Error('Church not found');\r\n    }\r\n\r\n    return churches[0].database_name;\r\n  } finally {\r\n    await mainConnection.end();\r\n  }\r\n}\r\n\r\n/**\r\n * Insert test data into church database\r\n */\r\nasync function insertTestDataIntoDatabase(database_name, sampleData) {\r\n  const connection = await mysql.createConnection({\r\n    ...getDbConfig(),\r\n    database: database_name\r\n  });\r\n\r\n  try {\r\n    console.log(`üß™ Inserting test data into database: ${database_name}`);\r\n\r\n    // Insert clergy members\r\n    if (sampleData.clergy && sampleData.clergy.length > 0) {\r\n      console.log(`üìã Inserting ${sampleData.clergy.length} clergy members`);\r\n      \r\n      // Create clergy table if it doesn't exist\r\n      await connection.execute(`\r\n        CREATE TABLE IF NOT EXISTS clergy (\r\n          id INT AUTO_INCREMENT PRIMARY KEY,\r\n          church_id INT NOT NULL DEFAULT 1,\r\n          name VARCHAR(255) NOT NULL,\r\n          title VARCHAR(100) DEFAULT '',\r\n          email VARCHAR(255) NOT NULL,\r\n          phone VARCHAR(50) DEFAULT '',\r\n          role VARCHAR(100) NOT NULL,\r\n          is_active BOOLEAN DEFAULT TRUE,\r\n          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\r\n          updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP\r\n        )\r\n      `);\r\n\r\n      const clergyValues = sampleData.clergy.map(member => [\r\n        member.church_id, member.name, member.title, member.email, \r\n        member.phone, member.role, member.is_active\r\n      ]);\r\n\r\n      await connection.query(\r\n        'INSERT INTO clergy (church_id, name, title, email, phone, role, is_active) VALUES ?',\r\n        [clergyValues]\r\n      );\r\n    }\r\n\r\n    // Insert baptism records\r\n    if (sampleData.baptismRecords && sampleData.baptismRecords.length > 0) {\r\n      console.log(`üìã Inserting ${sampleData.baptismRecords.length} baptism records`);\r\n      \r\n      const baptismValues = sampleData.baptismRecords.map(record => [\r\n        record.church_id, record.first_name, record.last_name, record.date_of_birth,\r\n        record.date_of_baptism, record.place_of_birth, record.place_of_baptism,\r\n        record.father_name, record.mother_name, record.godparents, record.priest_name, record.notes\r\n      ]);\r\n\r\n      await connection.query(\r\n        `INSERT INTO baptism_records \r\n         (church_id, first_name, last_name, date_of_birth, date_of_baptism, \r\n          place_of_birth, place_of_baptism, father_name, mother_name, godparents, priest_name, notes) \r\n         VALUES ?`,\r\n        [baptismValues]\r\n      );\r\n    }\r\n\r\n    // Insert marriage records\r\n    if (sampleData.marriageRecords && sampleData.marriageRecords.length > 0) {\r\n      console.log(`üìã Inserting ${sampleData.marriageRecords.length} marriage records`);\r\n      \r\n      const marriageValues = sampleData.marriageRecords.map(record => [\r\n        record.church_id, record.groom_first_name, record.groom_last_name,\r\n        record.bride_first_name, record.bride_last_name, record.marriage_date,\r\n        record.place_of_marriage, record.priest_name, record.witness1_name,\r\n        record.witness2_name, record.license_number, record.notes\r\n      ]);\r\n\r\n      await connection.query(\r\n        `INSERT INTO marriage_records \r\n         (church_id, groom_first_name, groom_last_name, bride_first_name, bride_last_name,\r\n          marriage_date, place_of_marriage, priest_name, witness1_name, witness2_name,\r\n          license_number, notes) \r\n         VALUES ?`,\r\n        [marriageValues]\r\n      );\r\n    }\r\n\r\n    // Insert funeral records\r\n    if (sampleData.funeralRecords && sampleData.funeralRecords.length > 0) {\r\n      console.log(`üìã Inserting ${sampleData.funeralRecords.length} funeral records`);\r\n      \r\n      const funeralValues = sampleData.funeralRecords.map(record => [\r\n        record.church_id, record.first_name, record.last_name, record.date_of_birth,\r\n        record.date_of_death, record.date_of_funeral, record.place_of_death,\r\n        record.place_of_funeral, record.priest_name, record.burial_location,\r\n        record.cause_of_death, record.notes\r\n      ]);\r\n\r\n      await connection.query(\r\n        `INSERT INTO funeral_records \r\n         (church_id, first_name, last_name, date_of_birth, date_of_death, date_of_funeral,\r\n          place_of_death, place_of_funeral, priest_name, burial_location, cause_of_death, notes) \r\n         VALUES ?`,\r\n        [funeralValues]\r\n      );\r\n    }\r\n\r\n    // Insert users\r\n    if (sampleData.users && sampleData.users.length > 0) {\r\n      console.log(`üìã Inserting ${sampleData.users.length} users`);\r\n      \r\n      const userValues = sampleData.users.map(user => [\r\n        user.church_id, user.username, user.email, user.password,\r\n        user.full_name, user.role, user.is_active\r\n      ]);\r\n\r\n      await connection.query(\r\n        `INSERT INTO users \r\n         (church_id, username, email, password, full_name, role, is_active) \r\n         VALUES ?`,\r\n        [userValues]\r\n      );\r\n    }\r\n\r\n    // Insert branding\r\n    if (sampleData.branding) {\r\n      console.log(`üìã Inserting branding settings`);\r\n      \r\n      await connection.execute(`\r\n        CREATE TABLE IF NOT EXISTS branding (\r\n          id INT AUTO_INCREMENT PRIMARY KEY,\r\n          church_id INT NOT NULL DEFAULT 1,\r\n          logo_path VARCHAR(500) DEFAULT NULL,\r\n          primary_color VARCHAR(7) DEFAULT '#1976d2',\r\n          secondary_color VARCHAR(7) DEFAULT '#dc004e',\r\n          ag_grid_theme VARCHAR(50) DEFAULT 'ag-theme-alpine',\r\n          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\r\n          updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\r\n          UNIQUE KEY uk_branding_church (church_id)\r\n        )\r\n      `);\r\n\r\n      await connection.execute(\r\n        `INSERT INTO branding (church_id, logo_path, primary_color, secondary_color, ag_grid_theme) \r\n         VALUES (?, ?, ?, ?, ?) ON DUPLICATE KEY UPDATE\r\n         primary_color = VALUES(primary_color),\r\n         secondary_color = VALUES(secondaryColor),\r\n         ag_grid_theme = VALUES(ag_grid_theme)`,\r\n        [\r\n          sampleData.branding.church_id,\r\n          sampleData.branding.logo_path,\r\n          sampleData.branding.primary_color,\r\n          sampleData.branding.secondary_color,\r\n          sampleData.branding.ag_grid_theme\r\n        ]\r\n      );\r\n    }\r\n\r\n    // Insert church settings\r\n    if (sampleData.settings && sampleData.settings.length > 0) {\r\n      console.log(`üìã Inserting ${sampleData.settings.length} church settings`);\r\n      \r\n      await connection.execute(`\r\n        CREATE TABLE IF NOT EXISTS church_settings (\r\n          id INT AUTO_INCREMENT PRIMARY KEY,\r\n          church_id INT NOT NULL DEFAULT 1,\r\n          setting_key VARCHAR(100) NOT NULL,\r\n          setting_value TEXT DEFAULT NULL,\r\n          setting_type ENUM('string', 'number', 'boolean', 'json') DEFAULT 'string',\r\n          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\r\n          updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\r\n          UNIQUE KEY uk_settings_church_key (church_id, setting_key)\r\n        )\r\n      `);\r\n\r\n      const settingsValues = sampleData.settings.map(setting => [\r\n        setting.church_id, setting.setting_key, setting.setting_value, setting.setting_type\r\n      ]);\r\n\r\n      await connection.query(\r\n        `INSERT INTO church_settings (church_id, setting_key, setting_value, setting_type) \r\n         VALUES ? ON DUPLICATE KEY UPDATE\r\n         setting_value = VALUES(setting_value),\r\n         setting_type = VALUES(setting_type)`,\r\n        [settingsValues]\r\n      );\r\n    }\r\n\r\n    console.log('‚úÖ Test data insertion completed successfully');\r\n\r\n  } finally {\r\n    await connection.end();\r\n  }\r\n}\r\n\r\nmodule.exports = router;\r\n"
    },
    "complexity": {
      "totalLines": 857,
      "codeLines": 673,
      "commentLines": 61,
      "commentRatio": 0.08310626702997276,
      "averageLineLength": 37.822888283378745
    },
    "lastAnalyzed": "2025-07-28T07:20:00.435Z"
  },
  "contentHash": "bde2775af2cddebb350ceb716850128284d80005508518a7fd8c612a026c4e14",
  "discoveredAt": "2025-07-28T07:20:00.435Z"
}