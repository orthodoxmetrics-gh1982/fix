{
  "id": "3e52f4244a0b",
  "originalPath": "/var/www/orthodox-church-mgmt/orthodoxmetrics/prod/server/routes/public/ocr.js",
  "relativePath": "server/routes/public/ocr.js",
  "name": "ocr.js",
  "extension": ".js",
  "size": 9852,
  "modified": "2025-07-11T10:49:29.382Z",
  "created": "2025-07-11T00:30:47.160Z",
  "classification": {
    "type": "Server Scripts",
    "category": "Backend > Server",
    "confidence": 7
  },
  "metadata": {
    "fileStats": {
      "lines": 262,
      "characters": 9760,
      "words": 958
    },
    "classification": {
      "type": "Server Scripts",
      "category": "Backend > Server",
      "confidence": 7
    },
    "dependencies": [
      {
        "type": "npm_package",
        "name": "express",
        "line": 2
      },
      {
        "type": "npm_package",
        "name": "multer",
        "line": 4
      },
      {
        "type": "npm_package",
        "name": "path",
        "line": 5
      },
      {
        "type": "npm_package",
        "name": "fs",
        "line": 6
      },
      {
        "type": "npm_package",
        "name": "uuid",
        "line": 7
      }
    ],
    "security": {
      "findings": [
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 194,
          "redacted": true
        }
      ],
      "hasSecurityIssues": true,
      "redactedContent": "// Public OCR API Routes - No authentication required\r\nconst express = require('express');\r\nconst router = express.Router();\r\nconst multer = require('multer');\r\nconst path = require('path');\r\nconst fs = require('fs').promises;\r\nconst { v4: uuidv4 } = require('uuid');\r\n\r\n// Import the OCR processing service\r\nconst ocrService = require('../../services/ocrProcessingService');\r\n\r\n// Import cost monitoring for translation\r\nconst TranslationCostMonitor = require('../../utils/translationCostMonitor');\r\nconst costMonitor = new TranslationCostMonitor();\r\n\r\n// Import entity extraction routes\r\nconst entityExtractionRoutes = require('./entityExtraction');\r\n\r\n// Configure multer for file uploads\r\nconst storage = multer.memoryStorage();\r\nconst upload = multer({\r\n  storage: storage,\r\n  limits: {\r\n    fileSize: 10 * 1024 * 1024, // 10MB limit\r\n    files: 5 // Maximum 5 files\r\n  },\r\n  fileFilter: (req, file, cb) => {\r\n    const allowedTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/gif', 'image/bmp', 'image/tiff', 'application/pdf'];\r\n    if (allowedTypes.includes(file.mimetype)) {\r\n      cb(null, true);\r\n    } else {\r\n      cb(new Error('Invalid file type. Only images and PDFs are allowed.'), false);\r\n    }\r\n  }\r\n});\r\n\r\n// Process OCR for uploaded file\r\nrouter.post('/process', upload.single('image'), async (req, res) => {\r\n  try {\r\n    if (!req.file) {\r\n      return res.status(400).json({ error: 'No file uploaded' });\r\n    }\r\n\r\n    const { \r\n      language = 'auto', \r\n      enableTranslation = false,  // Translation is now opt-in\r\n      targetLanguage = 'en'       // Target language for translation\r\n    } = req.body;\r\n    const jobId = uuidv4();\r\n\r\n    console.log(`üîç Processing public OCR job ${jobId} for file: ${req.file.originalname}`);\r\n    console.log(`   - Translation enabled: ${enableTranslation}`);\r\n    console.log(`   - Target language: ${targetLanguage}`);\r\n\r\n    // Create a temporary file path\r\n    const tempDir = path.join(__dirname, '../../temp');\r\n    await fs.mkdir(tempDir, { recursive: true });\r\n    \r\n    const tempFilePath = path.join(tempDir, `${jobId}_${req.file.originalname}`);\r\n    await fs.writeFile(tempFilePath, req.file.buffer);\r\n\r\n    try {\r\n      // Process OCR\r\n      const ocrResult = await ocrService.performOcr(tempFilePath, language);\r\n      \r\n      // Extract text and confidence from Google Vision result\r\n      let extractedText = '';\r\n      let averageConfidence = 0;\r\n      let detectedLanguage = language;\r\n      \r\n      if (ocrResult.textAnnotations && ocrResult.textAnnotations.length > 0) {\r\n        // First annotation contains the full text\r\n        extractedText = ocrResult.textAnnotations[0].description || '';\r\n        \r\n        // Calculate average confidence from all text annotations\r\n        const confidences = ocrResult.textAnnotations\r\n          .filter(annotation => annotation.confidence !== undefined)\r\n          .map(annotation => annotation.confidence);\r\n        \r\n        if (confidences.length > 0) {\r\n          averageConfidence = confidences.reduce((sum, conf) => sum + conf, 0) / confidences.length;\r\n        } else {\r\n          averageConfidence = 0.8; // Default confidence if not provided\r\n        }\r\n        \r\n        // Try to detect language from the text\r\n        if (ocrResult.textAnnotations[0].locale) {\r\n          detectedLanguage = ocrResult.textAnnotations[0].locale;\r\n        }\r\n      } else {\r\n        throw new Error('No text detected in image');\r\n      }\r\n      \r\n      let translationResult = null;\r\n      let translationCost = 0;\r\n      \r\n      // Only translate if explicitly requested by the user\r\n      if (enableTranslation && extractedText && extractedText.trim().length > 0) {\r\n        // Check cost limits before translation\r\n        const characterCount = extractedText.length;\r\n        const limitCheck = await costMonitor.checkLimits(characterCount);\r\n        \r\n        if (!limitCheck.allowed) {\r\n          console.warn(`‚ö†Ô∏è Translation blocked: ${limitCheck.reason}`);\r\n        } else {\r\n          const estimatedCost = costMonitor.calculateCost(characterCount);\r\n          console.log(`üí∞ Translation approved: $${estimatedCost.formattedCost} for ${characterCount} characters`);\r\n          \r\n          // Check if we need to translate (don't translate if already in target language)\r\n          const shouldTranslate = detectedLanguage && \r\n                                 detectedLanguage !== targetLanguage && \r\n                                 detectedLanguage !== targetLanguage.substring(0, 2); // Handle 'en' vs 'eng'\r\n          \r\n          if (shouldTranslate) {\r\n            try {\r\n              translationResult = await ocrService.translateText(extractedText, detectedLanguage, targetLanguage);\r\n              translationCost = estimatedCost.cost;\r\n              \r\n              // Log the actual cost\r\n              await costMonitor.logCost(jobId, characterCount, translationCost, detectedLanguage, targetLanguage);\r\n              \r\n              console.log(`üìù Translated from ${detectedLanguage} to ${targetLanguage} (Cost: $${translationCost.toFixed(4)})`);\r\n            } catch (translateError) {\r\n              console.warn('‚ö†Ô∏è Translation failed:', translateError.message);\r\n              // Continue without translation - not a critical error\r\n            }\r\n          } else {\r\n            console.log(`‚ÑπÔ∏è Skipping translation - text is already in ${targetLanguage}`);\r\n          }\r\n        }\r\n      } else if (!enableTranslation) {\r\n        console.log('‚ÑπÔ∏è Translation disabled by user request');\r\n      }\r\n\r\n      // Clean up temporary file\r\n      try {\r\n        await fs.unlink(tempFilePath);\r\n      } catch (cleanupError) {\r\n        console.warn('‚ö†Ô∏è Failed to clean up temp file:', cleanupError.message);\r\n      }\r\n\r\n      // Return results\r\n      const response = {\r\n        id: jobId,\r\n        filename: req.file.originalname,\r\n        text: extractedText,\r\n        confidence: averageConfidence,\r\n        detectedLanguage: detectedLanguage,\r\n        language: language,\r\n        translatedText: translationResult?.translation || null,\r\n        translationConfidence: translationResult?.confidence || null,\r\n        translationEnabled: enableTranslation,\r\n        translationCost: translationCost,\r\n        processedAt: new Date().toISOString(),\r\n        status: 'completed'\r\n      };\r\n\r\n      console.log(`‚úÖ Public OCR job ${jobId} completed successfully`);\r\n      console.log(`   - Original text length: ${extractedText?.length || 0} characters`);\r\n      console.log(`   - Confidence: ${(averageConfidence * 100).toFixed(1)}%`);\r\n      console.log(`   - Language: ${detectedLanguage || language}`);\r\n      console.log(`   - Translation: ${translationResult ? 'Yes' : 'No'}`);\r\n      console.log(`   - Translation cost: $${translationCost.toFixed(4)}`);\r\n\r\n      res.json(response);\r\n\r\n    } catch (ocrError) {\r\n      // Clean up temporary file on error\r\n      try {\r\n        await fs.unlink(tempFilePath);\r\n      } catch (cleanupError) {\r\n        console.warn('‚ö†Ô∏è Failed to clean up temp file after error:', cleanupError.message);\r\n      }\r\n      throw ocrError;\r\n    }\r\n\r\n  } catch (error) {\r\n    console.error('‚ùå Public OCR processing error:', error);\r\n    \r\n    if (error.message.includes('Invalid file type')) {\r\n      return res.status(400).json({ \r\n        error: 'Invalid file type. Only images (JPEG, PNG, GIF, BMP, TIFF) and PDFs are supported.' \r\n      });\r\n    }\r\n    \r\n    if (error.message.includes('File too large')) {\r\n      return res.status(400).json({ \r\n        error: 'File too large. Maximum file size is 10MB.' \r\n      });\r\n    }\r\n\r\n    res.status(500).json({ \r\n      error: 'OCR processing failed',\r\n      details: process.env.[REDACTED] === 'development' ? error.message : undefined\r\n    });\r\n  }\r\n});\r\n\r\n// Health check endpoint\r\nrouter.get('/health', (req, res) => {\r\n  res.json({\r\n    status: 'healthy',\r\n    service: 'Public OCR API',\r\n    timestamp: new Date().toISOString(),\r\n    supportedLanguages: [\r\n      'auto', 'en', 'el', 'ro', 'ka', 'ru', 'sr', 'bg', 'mk'\r\n    ],\r\n    maxFileSize: '10MB',\r\n    maxFiles: 5\r\n  });\r\n});\r\n\r\n// Get supported languages\r\nrouter.get('/languages', (req, res) => {\r\n  const languages = [\r\n    { code: 'auto', name: 'Auto-detect', native: 'Auto-detect' },\r\n    { code: 'en', name: 'English', native: 'English' },\r\n    { code: 'el', name: 'Greek', native: 'ŒïŒªŒªŒ∑ŒΩŒπŒ∫Œ¨' },\r\n    { code: 'ro', name: 'Romanian', native: 'Rom√¢nƒÉ' },\r\n    { code: 'ka', name: 'Georgian', native: '·É•·Éê·É†·Éó·É£·Éö·Éò' },\r\n    { code: 'ru', name: 'Russian', native: '–†—É—Å—Å–∫–∏–π' },\r\n    { code: 'sr', name: 'Serbian', native: '–°—Ä–ø—Å–∫–∏' },\r\n    { code: 'bg', name: 'Bulgarian', native: '–ë—ä–ª–≥–∞—Ä—Å–∫–∏' },\r\n    { code: 'mk', name: 'Macedonian', native: '–ú–∞–∫–µ–¥–æ–Ω—Å–∫–∏' }\r\n  ];\r\n  \r\n  res.json({ languages });\r\n});\r\n\r\n// Get translation cost usage statistics\r\nrouter.get('/translation-stats', async (req, res) => {\r\n  try {\r\n    const stats = await costMonitor.getUsageStats();\r\n    \r\n    if (!stats) {\r\n      return res.status(500).json({ error: 'Failed to retrieve usage statistics' });\r\n    }\r\n\r\n    res.json({\r\n      usage: stats,\r\n      limits: stats.limits,\r\n      recommendations: {\r\n        dailyRemaining: Math.max(0, stats.limits.daily - stats.dailyCost),\r\n        monthlyRemaining: Math.max(0, stats.limits.monthly - stats.monthlyCost),\r\n        averageCostPerTranslation: stats.totalTranslations > 0 ? stats.totalCost / stats.totalTranslations : 0\r\n      }\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('‚ùå Translation stats error:', error);\r\n    res.status(500).json({ \r\n      error: 'Failed to get translation statistics',\r\n      details: error.message \r\n    });\r\n  }\r\n});\r\n\r\n// Mount entity extraction routes\r\nrouter.use('/', entityExtractionRoutes);\r\n\r\nmodule.exports = router;\r\n"
    },
    "complexity": {
      "totalLines": 262,
      "codeLines": 197,
      "commentLines": 24,
      "commentRatio": 0.1085972850678733,
      "averageLineLength": 42.248868778280546
    },
    "lastAnalyzed": "2025-07-28T07:20:00.551Z"
  },
  "contentHash": "c5f209586684ce1f545ecb5f27cb2ba17b6433a06e80e7153845bbc18d3547a5",
  "discoveredAt": "2025-07-28T07:20:00.551Z"
}