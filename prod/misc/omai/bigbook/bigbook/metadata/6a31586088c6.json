{
  "id": "6a31586088c6",
  "originalPath": "/var/www/orthodox-church-mgmt/orthodoxmetrics/prod/server/utils/translationCostMonitor.js",
  "relativePath": "server/utils/translationCostMonitor.js",
  "name": "translationCostMonitor.js",
  "extension": ".js",
  "size": 6448,
  "modified": "2025-07-11T10:49:29.375Z",
  "created": "2025-07-11T01:13:23.696Z",
  "classification": {
    "type": "Server Scripts",
    "category": "Backend > Server",
    "confidence": 3
  },
  "metadata": {
    "fileStats": {
      "lines": 205,
      "characters": 6448,
      "words": 639
    },
    "classification": {
      "type": "Server Scripts",
      "category": "Backend > Server",
      "confidence": 3
    },
    "dependencies": [
      {
        "type": "npm_package",
        "name": "fs",
        "line": 4
      },
      {
        "type": "npm_package",
        "name": "path",
        "line": 5
      }
    ],
    "security": {
      "findings": [
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 10,
          "redacted": true
        },
        {
          "type": "sensitive_data",
          "pattern": "process\\.env\\.([A-Z_]+)",
          "line": 11,
          "redacted": true
        }
      ],
      "hasSecurityIssues": true,
      "redactedContent": "#!/usr/bin/env node\r\n\r\n// Cost monitoring utilities for Google Cloud Translation API\r\nconst fs = require('fs').promises;\r\nconst path = require('path');\r\n\r\nclass TranslationCostMonitor {\r\n  constructor() {\r\n    this.costLogFile = path.join(__dirname, 'translation-costs.json');\r\n    this.monthlyLimit = parseFloat(process.env.[REDACTED]) || 10.0; // $10/month default\r\n    this.dailyLimit = parseFloat(process.env.[REDACTED]) || 2.0;     // $2/day default\r\n  }\r\n\r\n  // Calculate cost for character count\r\n  calculateCost(characterCount) {\r\n    // Google Cloud Translation API: $20 per million characters\r\n    // First 500,000 characters per month are free\r\n    const freeCharacters = 500000;\r\n    const costPerMillion = 20;\r\n    \r\n    const chargeableCharacters = Math.max(0, characterCount - freeCharacters);\r\n    const cost = (chargeableCharacters / 1000000) * costPerMillion;\r\n    \r\n    return {\r\n      totalCharacters: characterCount,\r\n      freeCharacters: Math.min(characterCount, freeCharacters),\r\n      chargeableCharacters,\r\n      cost: cost,\r\n      formattedCost: `$${cost.toFixed(4)}`\r\n    };\r\n  }\r\n\r\n  // Log translation cost\r\n  async logCost(jobId, characterCount, actualCost, sourceLanguage, targetLanguage) {\r\n    try {\r\n      let costLog = [];\r\n      \r\n      // Load existing log\r\n      try {\r\n        const logData = await fs.readFile(this.costLogFile, 'utf8');\r\n        costLog = JSON.parse(logData);\r\n      } catch (error) {\r\n        // File doesn't exist yet, start with empty array\r\n      }\r\n\r\n      // Add new entry\r\n      const entry = {\r\n        timestamp: new Date().toISOString(),\r\n        jobId,\r\n        characterCount,\r\n        cost: actualCost,\r\n        sourceLanguage,\r\n        targetLanguage,\r\n        date: new Date().toISOString().split('T')[0] // YYYY-MM-DD\r\n      };\r\n\r\n      costLog.push(entry);\r\n\r\n      // Keep only last 1000 entries\r\n      if (costLog.length > 1000) {\r\n        costLog = costLog.slice(-1000);\r\n      }\r\n\r\n      // Save log\r\n      await fs.writeFile(this.costLogFile, JSON.stringify(costLog, null, 2));\r\n      \r\n      return entry;\r\n    } catch (error) {\r\n      console.error('Failed to log translation cost:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  // Check if translation is within limits\r\n  async checkLimits(proposedCharacterCount) {\r\n    try {\r\n      const proposedCost = this.calculateCost(proposedCharacterCount).cost;\r\n      \r\n      // Load cost log\r\n      let costLog = [];\r\n      try {\r\n        const logData = await fs.readFile(this.costLogFile, 'utf8');\r\n        costLog = JSON.parse(logData);\r\n      } catch (error) {\r\n        // No existing log, limits not exceeded\r\n        return { allowed: true, reason: 'No previous usage' };\r\n      }\r\n\r\n      const today = new Date().toISOString().split('T')[0];\r\n      const thisMonth = new Date().toISOString().substring(0, 7); // YYYY-MM\r\n\r\n      // Calculate daily usage\r\n      const todayCosts = costLog\r\n        .filter(entry => entry.date === today)\r\n        .reduce((sum, entry) => sum + entry.cost, 0);\r\n\r\n      // Calculate monthly usage  \r\n      const monthCosts = costLog\r\n        .filter(entry => entry.timestamp.startsWith(thisMonth))\r\n        .reduce((sum, entry) => sum + entry.cost, 0);\r\n\r\n      // Check limits\r\n      if (todayCosts + proposedCost > this.dailyLimit) {\r\n        return {\r\n          allowed: false,\r\n          reason: `Daily limit exceeded. Used: $${todayCosts.toFixed(4)}, Proposed: $${proposedCost.toFixed(4)}, Limit: $${this.dailyLimit}`,\r\n          usage: { daily: todayCosts, monthly: monthCosts }\r\n        };\r\n      }\r\n\r\n      if (monthCosts + proposedCost > this.monthlyLimit) {\r\n        return {\r\n          allowed: false,\r\n          reason: `Monthly limit exceeded. Used: $${monthCosts.toFixed(4)}, Proposed: $${proposedCost.toFixed(4)}, Limit: $${this.monthlyLimit}`,\r\n          usage: { daily: todayCosts, monthly: monthCosts }\r\n        };\r\n      }\r\n\r\n      return {\r\n        allowed: true,\r\n        reason: 'Within limits',\r\n        usage: { daily: todayCosts, monthly: monthCosts },\r\n        proposedCost\r\n      };\r\n\r\n    } catch (error) {\r\n      console.error('Failed to check translation limits:', error);\r\n      // Fail safe - allow translation if we can't check limits\r\n      return { allowed: true, reason: 'Limit check failed, allowing' };\r\n    }\r\n  }\r\n\r\n  // Get usage statistics\r\n  async getUsageStats() {\r\n    try {\r\n      let costLog = [];\r\n      try {\r\n        const logData = await fs.readFile(this.costLogFile, 'utf8');\r\n        costLog = JSON.parse(logData);\r\n      } catch (error) {\r\n        return {\r\n          totalCost: 0,\r\n          totalCharacters: 0,\r\n          totalTranslations: 0,\r\n          dailyCost: 0,\r\n          monthlyCost: 0,\r\n          lastMonth: []\r\n        };\r\n      }\r\n\r\n      const today = new Date().toISOString().split('T')[0];\r\n      const thisMonth = new Date().toISOString().substring(0, 7);\r\n\r\n      const totalCost = costLog.reduce((sum, entry) => sum + entry.cost, 0);\r\n      const totalCharacters = costLog.reduce((sum, entry) => sum + entry.characterCount, 0);\r\n      const totalTranslations = costLog.length;\r\n\r\n      const dailyCost = costLog\r\n        .filter(entry => entry.date === today)\r\n        .reduce((sum, entry) => sum + entry.cost, 0);\r\n\r\n      const monthlyCost = costLog\r\n        .filter(entry => entry.timestamp.startsWith(thisMonth))\r\n        .reduce((sum, entry) => sum + entry.cost, 0);\r\n\r\n      // Last 30 days by day\r\n      const lastMonth = [];\r\n      for (let i = 29; i >= 0; i--) {\r\n        const date = new Date();\r\n        date.setDate(date.getDate() - i);\r\n        const dateStr = date.toISOString().split('T')[0];\r\n        \r\n        const dayCost = costLog\r\n          .filter(entry => entry.date === dateStr)\r\n          .reduce((sum, entry) => sum + entry.cost, 0);\r\n        \r\n        lastMonth.push({\r\n          date: dateStr,\r\n          cost: dayCost,\r\n          translations: costLog.filter(entry => entry.date === dateStr).length\r\n        });\r\n      }\r\n\r\n      return {\r\n        totalCost,\r\n        totalCharacters,\r\n        totalTranslations,\r\n        dailyCost,\r\n        monthlyCost,\r\n        lastMonth,\r\n        limits: {\r\n          daily: this.dailyLimit,\r\n          monthly: this.monthlyLimit\r\n        }\r\n      };\r\n\r\n    } catch (error) {\r\n      console.error('Failed to get usage stats:', error);\r\n      return null;\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = TranslationCostMonitor;\r\n"
    },
    "complexity": {
      "totalLines": 205,
      "codeLines": 152,
      "commentLines": 20,
      "commentRatio": 0.11627906976744186,
      "averageLineLength": 35.872093023255815
    },
    "lastAnalyzed": "2025-07-28T07:20:01.360Z"
  },
  "contentHash": "3208cd5302e705bff8140b98feb89a199b3503748ce2049d89dcdcc04acfcb66",
  "discoveredAt": "2025-07-28T07:20:01.360Z"
}