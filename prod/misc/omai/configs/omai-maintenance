#!/usr/bin/env node

/**
 * OMAI Maintenance CLI Tool
 * Command-line interface for maintenance mode control
 */

const OMAIMaintenanceInterface = require('./server/utils/omaiMaintenanceInterface');
const path = require('path');

class OMAIMaintenanceCLI {
  constructor() {
    this.maintenance = OMAIMaintenanceInterface;
  }

  /**
   * Show help information
   */
  showHelp() {
    console.log(`
🔧 OMAI Maintenance CLI - Orthodox Metrics AI Maintenance Control

USAGE:
  omai-maintenance <command> [options]

COMMANDS:
  on                     Activate maintenance mode
  off                    Deactivate maintenance mode
  status                 Show current maintenance status
  emergency             Activate emergency shutdown
  schedule              Schedule maintenance for future
  logs                  Show maintenance event logs
  stats                 Show maintenance statistics
  check-exempt          Check if IP/user is exempt

OPTIONS:
  --message <text>      Custom maintenance message
  --eta <time>          Estimated completion time (ISO 8601)
  --reason <text>       Reason for maintenance
  --time <time>         Scheduled time (for schedule command)
  --limit <number>      Limit for logs (default: 20)
  --help, -h            Show this help

EXAMPLES:
  # Activate maintenance
  omai-maintenance on --message="Database upgrade" --eta="2025-01-27T03:00:00Z"
  
  # Deactivate maintenance
  omai-maintenance off --reason="Upgrade completed"
  
  # Emergency shutdown
  omai-maintenance emergency --reason="Critical security issue"
  
  # Schedule maintenance
  omai-maintenance schedule --time="2025-01-27T02:00:00Z" --message="Scheduled upgrade"
  
  # Check status
  omai-maintenance status
  
  # View logs
  omai-maintenance logs --limit=50

SECURITY:
  - Maintenance mode affects all non-exempt users
  - Super admins and dev admins are exempt by default
  - Emergency shutdown immediately activates maintenance
  - All actions are logged to Big Book

For more information: https://orthodoxmetrics.com/docs/omai-maintenance
`);
  }

  /**
   * Parse command line arguments
   */
  parseArgs(args) {
    const options = {
      command: '',
      message: '',
      eta: '',
      reason: '',
      time: '',
      limit: 20,
      help: false
    };

    // Get command
    if (args.length > 0 && !args[0].startsWith('-')) {
      options.command = args[0];
      args = args.slice(1);
    }

    // Parse options
    for (let i = 0; i < args.length; i++) {
      const arg = args[i];
      
      switch (arg) {
        case '--message':
          options.message = args[++i] || '';
          break;
          
        case '--eta':
          options.eta = args[++i] || '';
          break;
          
        case '--reason':
          options.reason = args[++i] || '';
          break;
          
        case '--time':
          options.time = args[++i] || '';
          break;
          
        case '--limit':
          options.limit = parseInt(args[++i]) || 20;
          break;
          
        case '--help':
        case '-h':
          options.help = true;
          break;
          
        default:
          if (arg.startsWith('-')) {
            console.warn(`Unknown option: ${arg}`);
          }
          break;
      }
    }

    return options;
  }

  /**
   * Format duration for display
   */
  formatDuration(milliseconds) {
    if (!milliseconds) return 'N/A';
    
    const seconds = Math.floor(milliseconds / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    const days = Math.floor(hours / 24);
    
    if (days > 0) {
      return `${days}d ${hours % 24}h ${minutes % 60}m`;
    } else if (hours > 0) {
      return `${hours}h ${minutes % 60}m`;
    } else if (minutes > 0) {
      return `${minutes}m ${seconds % 60}s`;
    } else {
      return `${seconds}s`;
    }
  }

  /**
   * Format timestamp for display
   */
  formatTimestamp(isoString) {
    if (!isoString) return 'N/A';
    
    const date = new Date(isoString);
    return date.toLocaleString();
  }

  /**
   * Activate maintenance mode
   */
  async activateMaintenanceMode(options) {
    try {
      console.log('🔧 Activating maintenance mode...');
      
      const result = await this.maintenance.activate(
        options.message || null,
        options.eta || null,
        options.reason || 'CLI activation'
      );
      
      console.log('✅ Maintenance mode activated successfully!');
      console.log(`   Activated at: ${this.formatTimestamp(result.activatedAt)}`);
      
      if (options.eta) {
        console.log(`   Estimated completion: ${this.formatTimestamp(options.eta)}`);
      }
      
      if (options.message) {
        console.log(`   Message: ${options.message}`);
      }
      
    } catch (error) {
      console.error('❌ Failed to activate maintenance mode:', error.message);
      process.exit(1);
    }
  }

  /**
   * Deactivate maintenance mode
   */
  async deactivateMaintenanceMode(options) {
    try {
      console.log('🔧 Deactivating maintenance mode...');
      
      const result = await this.maintenance.deactivate(
        options.reason || 'CLI deactivation'
      );
      
      console.log('✅ Maintenance mode deactivated successfully!');
      console.log(`   Deactivated at: ${this.formatTimestamp(result.deactivatedAt)}`);
      console.log(`   Total duration: ${this.formatDuration(result.duration)}`);
      
      if (options.reason) {
        console.log(`   Reason: ${options.reason}`);
      }
      
    } catch (error) {
      console.error('❌ Failed to deactivate maintenance mode:', error.message);
      process.exit(1);
    }
  }

  /**
   * Show maintenance status
   */
  async showStatus() {
    try {
      const result = await this.maintenance.status();
      const status = result.data;
      
      console.log('\n🔧 Maintenance Mode Status:\n');
      
      if (status.isActive) {
        console.log('Status: 🔴 ACTIVE');
        console.log(`Activated at: ${this.formatTimestamp(status.activatedAt)}`);
        console.log(`Activated by: ${status.activatedBy}`);
        console.log(`Reason: ${status.reason}`);
        console.log(`Duration: ${this.formatDuration(status.duration)}`);
        
        if (status.eta) {
          console.log(`Estimated completion: ${this.formatTimestamp(status.eta)}`);
          console.log(`Time remaining: ${this.formatDuration(status.timeRemaining)}`);
        }
        
        console.log(`Message: ${status.message}`);
        console.log(`Status text: ${status.status}`);
        
        if (status.exemptRoles.length > 0) {
          console.log(`Exempt roles: ${status.exemptRoles.join(', ')}`);
        }
        
        if (status.allowlist.length > 0) {
          console.log(`Allowlist: ${status.allowlist.join(', ')}`);
        }
        
      } else {
        console.log('Status: 🟢 INACTIVE');
        console.log('System is operating normally.');
      }
      
    } catch (error) {
      console.error('❌ Failed to get maintenance status:', error.message);
      process.exit(1);
    }
  }

  /**
   * Activate emergency shutdown
   */
  async emergencyShutdown(options) {
    try {
      console.log('🚨 Activating emergency shutdown...');
      
      const result = await this.maintenance.emergency(
        options.reason || 'CLI emergency shutdown'
      );
      
      console.log('🚨 Emergency shutdown activated!');
      console.log(`   Activated at: ${this.formatTimestamp(result.timestamp)}`);
      console.log(`   Reason: ${result.reason}`);
      console.log('⚠️  All non-exempt users are now blocked from accessing the system.');
      
    } catch (error) {
      console.error('❌ Failed to activate emergency shutdown:', error.message);
      process.exit(1);
    }
  }

  /**
   * Schedule maintenance
   */
  async scheduleMaintenanceMode(options) {
    try {
      if (!options.time) {
        console.error('❌ Scheduled time is required for schedule command');
        console.log('   Use: --time="2025-01-27T02:00:00Z"');
        process.exit(1);
      }
      
      console.log('⏰ Scheduling maintenance...');
      
      const scheduleOptions = {};
      if (options.message) scheduleOptions.message = options.message;
      if (options.eta) scheduleOptions.eta = options.eta;
      if (options.reason) scheduleOptions.reason = options.reason;
      
      const result = await this.maintenance.schedule(options.time, scheduleOptions);
      
      console.log('✅ Maintenance scheduled successfully!');
      console.log(`   Scheduled for: ${this.formatTimestamp(result.scheduledFor)}`);
      console.log(`   Delay: ${this.formatDuration(result.data.delay)}`);
      
      if (options.message) {
        console.log(`   Message: ${options.message}`);
      }
      
      if (options.eta) {
        console.log(`   Estimated completion: ${this.formatTimestamp(options.eta)}`);
      }
      
    } catch (error) {
      console.error('❌ Failed to schedule maintenance:', error.message);
      process.exit(1);
    }
  }

  /**
   * Show maintenance logs
   */
  async showLogs(options) {
    try {
      console.log(`📋 Fetching maintenance logs (last ${options.limit})...\n`);
      
      const result = await this.maintenance.logs(options.limit);
      const logs = result.logs;
      
      if (logs.length === 0) {
        console.log('No maintenance logs found.');
        return;
      }
      
      console.log(`Found ${logs.length} log entries:\n`);
      
      logs.forEach((log, index) => {
        const timestamp = this.formatTimestamp(log.timestamp);
        const action = log.action;
        const actionIcon = action === 'ACTIVATED' ? '🔴' : '🟢';
        
        console.log(`${actionIcon} [${timestamp}] ${action}`);
        
        if (log.details) {
          if (log.details.activatedBy || log.details.deactivatedBy) {
            const by = log.details.activatedBy || log.details.deactivatedBy;
            console.log(`   By: ${by}`);
          }
          
          if (log.details.reason) {
            console.log(`   Reason: ${log.details.reason}`);
          }
          
          if (log.details.duration) {
            console.log(`   Duration: ${this.formatDuration(log.details.duration * 1000)}`);
          }
          
          if (log.details.eta) {
            console.log(`   ETA: ${this.formatTimestamp(log.details.eta)}`);
          }
        }
        
        console.log('');
      });
      
    } catch (error) {
      console.error('❌ Failed to get maintenance logs:', error.message);
      process.exit(1);
    }
  }

  /**
   * Show maintenance statistics
   */
  async showStatistics() {
    try {
      console.log('📊 Fetching maintenance statistics...\n');
      
      const result = await this.maintenance.statistics();
      const stats = result.statistics;
      
      if (!stats) {
        console.log('No maintenance statistics available.');
        return;
      }
      
      console.log('📈 Maintenance Statistics:\n');
      console.log(`Total activations: ${stats.totalActivations}`);
      console.log(`Total downtime: ${this.formatDuration(stats.totalDowntime * 1000)}`);
      
      if (stats.totalActivations > 0) {
        console.log(`Average downtime: ${this.formatDuration(stats.averageDowntime * 1000)}`);
        console.log(`Longest downtime: ${this.formatDuration(stats.longestDowntime * 1000)}`);
        console.log(`Shortest downtime: ${this.formatDuration(stats.shortestDowntime * 1000)}`);
      }
      
      if (Object.keys(stats.activationsByUser).length > 0) {
        console.log('\n👥 Activations by user:');
        Object.entries(stats.activationsByUser)
          .sort(([,a], [,b]) => b - a)
          .forEach(([user, count]) => {
            console.log(`   ${user}: ${count}`);
          });
      }
      
      if (Object.keys(stats.activationsByReason).length > 0) {
        console.log('\n📝 Activations by reason:');
        Object.entries(stats.activationsByReason)
          .sort(([,a], [,b]) => b - a)
          .forEach(([reason, count]) => {
            console.log(`   ${reason}: ${count}`);
          });
      }
      
      if (stats.recentActivations.length > 0) {
        console.log('\n⏰ Recent activations:');
        stats.recentActivations.forEach((activation, index) => {
          console.log(`   ${index + 1}. ${this.formatTimestamp(activation.activatedAt)} - ${activation.reason}`);
          console.log(`      Duration: ${this.formatDuration(activation.duration * 1000)}`);
        });
      }
      
    } catch (error) {
      console.error('❌ Failed to get maintenance statistics:', error.message);
      process.exit(1);
    }
  }

  /**
   * Check exemption status
   */
  async checkExemption() {
    try {
      // Get current user from session (simplified for CLI)
      console.log('🔍 Checking exemption status...\n');
      
      const status = await this.maintenance.status();
      
      if (!status.data.isActive) {
        console.log('🟢 Maintenance mode is not active - no exemption needed.');
        return;
      }
      
      console.log('🔴 Maintenance mode is active.');
      console.log('📋 Exempt roles:', status.data.exemptRoles.join(', '));
      console.log('📋 Allowlist:', status.data.allowlist.join(', ') || 'Empty');
      
      // Note: CLI cannot easily determine current user/IP context
      console.log('\n💡 To check specific exemption status, use the web interface or API.');
      
    } catch (error) {
      console.error('❌ Failed to check exemption status:', error.message);
      process.exit(1);
    }
  }

  /**
   * Main CLI entry point
   */
  async run(argv) {
    const args = argv.slice(2); // Remove 'node' and script name
    const options = this.parseArgs(args);
    
    if (options.help || !options.command) {
      this.showHelp();
      return;
    }
    
    try {
      switch (options.command) {
        case 'on':
        case 'activate':
          await this.activateMaintenanceMode(options);
          break;
          
        case 'off':
        case 'deactivate':
          await this.deactivateMaintenanceMode(options);
          break;
          
        case 'status':
          await this.showStatus();
          break;
          
        case 'emergency':
          await this.emergencyShutdown(options);
          break;
          
        case 'schedule':
          await this.scheduleMaintenanceMode(options);
          break;
          
        case 'logs':
          await this.showLogs(options);
          break;
          
        case 'stats':
        case 'statistics':
          await this.showStatistics();
          break;
          
        case 'check-exempt':
          await this.checkExemption();
          break;
          
        default:
          console.error(`❌ Unknown command: ${options.command}`);
          console.log('Use --help for available commands.');
          process.exit(1);
      }
    } catch (error) {
      console.error('❌ Command failed:', error.message);
      process.exit(1);
    }
  }
}

// Run CLI if called directly
if (require.main === module) {
  const cli = new OMAIMaintenanceCLI();
  cli.run(process.argv).catch(error => {
    console.error('❌ Unexpected error:', error.message);
    process.exit(1);
  });
}

module.exports = OMAIMaintenanceCLI; 