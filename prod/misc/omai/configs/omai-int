#!/usr/bin/env node

/**
 * OMAI Command Line Interface
 * Natural language command execution for Orthodox Metrics AI
 */

const OMAICommandExecutor = require('./server/utils/omaiCommandExecutor');
const path = require('path');

class OMAICLI {
  constructor() {
    this.executor = new OMAICommandExecutor();
    this.handsonMode = false;
    this.verbose = false;
  }

  /**
   * Parse command line arguments
   */
  parseArgs(args) {
    const options = {
      mode: 'safe',
      force: false,
      confirmSudo: false,
      instruction: '',
      command: '',
      verbose: false,
      help: false,
      listCommands: false,
      history: false,
      stats: false,
      timeout: null
    };

    for (let i = 0; i < args.length; i++) {
      const arg = args[i];
      
      switch (arg) {
        case '--mode':
        case '-m':
          options.mode = args[++i];
          if (options.mode === 'hands-on') {
            this.handsonMode = true;
          }
          break;
          
        case '--force':
        case '-f':
          options.force = true;
          break;
          
        case '--confirm-sudo':
          options.confirmSudo = true;
          break;
          
        case '--verbose':
        case '-v':
          options.verbose = true;
          this.verbose = true;
          break;
          
        case '--help':
        case '-h':
          options.help = true;
          break;
          
        case '--list':
        case '-l':
          options.listCommands = true;
          break;
          
        case '--history':
          options.history = true;
          break;
          
        case '--stats':
        case '-s':
          options.stats = true;
          break;
          
        case '--timeout':
        case '-t':
          options.timeout = parseInt(args[++i]);
          break;
          
        case '--command':
        case '-c':
          options.command = args[++i];
          break;
          
        default:
          if (!arg.startsWith('-')) {
            options.instruction += (options.instruction ? ' ' : '') + arg;
          }
          break;
      }
    }

    return options;
  }

  /**
   * Show help information
   */
  showHelp() {
    console.log(`
ü§ñ OMAI - Orthodox Metrics AI Command Interface
Natural language command execution for system administration

USAGE:
  omai [OPTIONS] <instruction>
  omai --mode hands-on "restart the server"
  omai --list
  omai --stats

OPTIONS:
  -m, --mode <mode>     Set execution mode (safe, hands-on)
  -f, --force          Force execution of dangerous commands
  --confirm-sudo       Confirm sudo command execution
  -v, --verbose        Verbose output
  -l, --list           List available commands
  --history            Show command execution history
  -s, --stats          Show memory cache statistics
  -t, --timeout <sec>  Command timeout in seconds
  -c, --command <cmd>  Execute specific command directly
  -h, --help           Show this help

MODES:
  safe       Parse and show commands without executing (default)
  hands-on   Enable actual command execution

EXAMPLES:
  omai "check server status"
  omai --mode hands-on "restart the server"
  omai --mode hands-on --force "emergency restart"
  omai --mode hands-on --confirm-sudo "backup the database"
  omai --list
  omai --history
  omai --stats

SAFETY:
  - Commands are classified as safe, moderate, dangerous
  - Dangerous commands require --force flag
  - Sudo commands require --confirm-sudo flag
  - All commands are logged to /var/log/omai/executed.log
  - Memory system learns from frequently used commands

CONFIGURATION:
  Commands are defined in: omai_commands.yaml
  Logs are stored in: /var/log/omai/
  
For more information, see: https://orthodoxmetrics.com/docs/omai
`);
  }

  /**
   * List available commands
   */
  async listCommands() {
    try {
      await this.executor.initialize();
      const commands = this.executor.listCommands();
      
      console.log('\nü§ñ Available OMAI Commands:\n');
      
      const categories = {};
      commands.forEach(cmd => {
        if (!categories[cmd.category]) {
          categories[cmd.category] = [];
        }
        categories[cmd.category].push(cmd);
      });
      
      for (const [category, cmds] of Object.entries(categories)) {
        console.log(`üìÅ ${category.toUpperCase()}`);
        cmds.forEach(cmd => {
          const safety = this.getSafetyIcon(cmd.safety);
          const sudo = cmd.requires_sudo ? 'üîí' : '  ';
          const trusted = cmd.trusted ? '‚úÖ' : '  ';
          
          console.log(`  ${safety} ${sudo} ${trusted} ${cmd.name.padEnd(20)} - ${cmd.description}`);
          if (this.verbose && cmd.patterns) {
            console.log(`      Patterns: ${cmd.patterns.join(', ')}`);
          }
        });
        console.log('');
      }
      
      console.log('Legend:');
      console.log('  üü¢ Safe    üü° Moderate    üî¥ Dangerous');
      console.log('  üîí Requires sudo    ‚úÖ Trusted command');
      
    } catch (error) {
      console.error('‚ùå Error listing commands:', error.message);
      process.exit(1);
    }
  }

  /**
   * Get safety level icon
   */
  getSafetyIcon(safety) {
    switch (safety) {
      case 'safe': return 'üü¢';
      case 'moderate': return 'üü°';
      case 'dangerous': return 'üî¥';
      default: return '‚ö™';
    }
  }

  /**
   * Show command execution history
   */
  async showHistory() {
    try {
      await this.executor.initialize();
      const history = await this.executor.getCommandHistory(20);
      
      console.log('\nüìã Command Execution History (Last 20):\n');
      
      if (history.length === 0) {
        console.log('No command history found.');
        return;
      }
      
      history.forEach((entry, index) => {
        const status = entry.status === 'success' ? '‚úÖ' : 
                      entry.status === 'failed' ? '‚ùå' : '‚è≥';
        const timestamp = new Date(entry.timestamp).toLocaleString();
        
        console.log(`${status} [${timestamp}] ${entry.name}`);
        console.log(`   Command: ${entry.command}`);
        if (entry.status === 'failed' && entry.error) {
          console.log(`   Error: ${entry.error}`);
        }
        console.log('');
      });
      
    } catch (error) {
      console.error('‚ùå Error showing history:', error.message);
      process.exit(1);
    }
  }

  /**
   * Show memory cache statistics
   */
  async showStats() {
    try {
      await this.executor.initialize();
      const stats = this.executor.getMemoryStats();
      
      console.log('\nüìä OMAI Memory Cache Statistics:\n');
      console.log(`Total cached commands: ${stats.total_cached_commands}`);
      console.log(`Cache file: ${stats.cache_file}`);
      
      if (stats.most_used_commands.length > 0) {
        console.log('\nüî• Most Used Commands:');
        stats.most_used_commands.forEach((cmd, index) => {
          console.log(`  ${index + 1}. ${cmd.command} (${cmd.frequency} times)`);
          console.log(`     "${cmd.instruction}"`);
          console.log(`     Last used: ${new Date(cmd.last_used).toLocaleString()}`);
        });
      }
      
      if (stats.recent_commands.length > 0) {
        console.log('\n‚è∞ Recent Commands:');
        stats.recent_commands.forEach((cmd, index) => {
          console.log(`  ${index + 1}. ${cmd.command}`);
          console.log(`     "${cmd.instruction}"`);
          console.log(`     Used: ${new Date(cmd.last_used).toLocaleString()}`);
        });
      }
      
    } catch (error) {
      console.error('‚ùå Error showing stats:', error.message);
      process.exit(1);
    }
  }

  /**
   * Process natural language instruction
   */
  async processInstruction(instruction, options) {
    try {
      if (this.handsonMode) {
        this.executor.enableHandsOnMode();
      }
      
      await this.executor.initialize();
      
      console.log(`ü§ñ Processing: "${instruction}"`);
      console.log(`Mode: ${options.mode}`);
      
      const result = await this.executor.processInstruction(instruction, {
        force: options.force,
        confirmSudo: options.confirmSudo,
        timeout: options.timeout
      });
      
      if (result.found && !result.stdout) {
        // Command found but not executed
        console.log(`\n‚úÖ Found command: ${result.command.name}`);
        console.log(`Description: ${result.command.description}`);
        console.log(`Safety level: ${result.command.safety}`);
        console.log(`Command: ${result.command.command}`);
        
        if (result.message) {
          console.log(`\nüí° ${result.message}`);
        }
        if (result.suggestion) {
          console.log(`   ${result.suggestion}`);
        }
      } else if (result.stdout !== undefined) {
        // Command executed
        console.log('\n‚úÖ Command executed successfully!');
        if (result.stdout) {
          console.log('\nOutput:');
          console.log(result.stdout);
        }
        if (result.stderr) {
          console.log('\nWarnings:');
          console.log(result.stderr);
        }
      }
      
    } catch (error) {
      console.error('\n‚ùå Error:', error.message);
      
      if (error.message.includes('hands-on mode')) {
        console.log('\nüí° Tip: Use --mode hands-on to enable command execution');
      } else if (error.message.includes('--force flag')) {
        console.log('\nüí° Tip: Use --force to execute dangerous commands');
      } else if (error.message.includes('sudo confirmation')) {
        console.log('\nüí° Tip: Use --confirm-sudo to execute sudo commands');
      }
      
      process.exit(1);
    }
  }

  /**
   * Main CLI entry point
   */
  async run(argv) {
    const args = argv.slice(2); // Remove 'node' and script name
    const options = this.parseArgs(args);
    
    // Handle special commands first
    if (options.help) {
      this.showHelp();
      return;
    }
    
    if (options.listCommands) {
      await this.listCommands();
      return;
    }
    
    if (options.history) {
      await this.showHistory();
      return;
    }
    
    if (options.stats) {
      await this.showStats();
      return;
    }
    
    // Process instruction
    if (options.instruction || options.command) {
      const instruction = options.command || options.instruction;
      await this.processInstruction(instruction, options);
    } else {
      console.log('‚ùå No instruction provided. Use --help for usage information.');
      process.exit(1);
    }
  }
}

// Run CLI if called directly
if (require.main === module) {
  const cli = new OMAICLI();
  cli.run(process.argv).catch(error => {
    console.error('‚ùå Unexpected error:', error.message);
    if (cli.verbose) {
      console.error(error.stack);
    }
    process.exit(1);
  });
}

module.exports = OMAICLI; 