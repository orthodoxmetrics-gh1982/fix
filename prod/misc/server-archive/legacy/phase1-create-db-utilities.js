#!/usr/bin/env node

/**
 * Phase 1: Database Schema & Core Infrastructure
 * Step 4: Create cross-database connection utilities
 */

const fs = require('fs').promises;
const path = require('path');

const DB_UTILITIES_CODE = `/**
 * Cross-Database Connection Utilities for OCR System
 * Handles connections between orthodoxmetrics_db ↔ ssppoc_records_db ↔ saints_peter_and_paul_orthodox_church_db
 * Generated by Phase 1 setup script
 */

import mysql from 'mysql2/promise';
import { promisePool as centralPool } from '../config/db';

// Database Configuration
const DB_CONFIG = {
  host: 'localhost',
  user: 'orthodoxapps',
  password: 'Summerof1982@!',
  charset: 'utf8mb4',
  connectionLimit: 10,
  acquireTimeout: 60000,
  timeout: 60000
};

// Connection pools for each database
let recordsPool: mysql.Pool | null = null;
let ocrPool: mysql.Pool | null = null;

/**
 * Get connection pool for Records Database (ssppoc_records_db)
 */
export function getRecordsDbPool(): mysql.Pool {
  if (!recordsPool) {
    recordsPool = mysql.createPool({
      ...DB_CONFIG,
      database: 'ssppoc_records_db'
    });
  }
  return recordsPool;
}

/**
 * Get connection pool for OCR Processing Database (saints_peter_and_paul_orthodox_church_db)
 */
export function getOcrDbPool(): mysql.Pool {
  if (!ocrPool) {
    ocrPool = mysql.createPool({
      ...DB_CONFIG,
      database: 'saints_peter_and_paul_orthodox_church_db'
    });
  }
  return ocrPool;
}

/**
 * Get single connection to Records Database
 */
export async function getRecordsDbConnection(): Promise<mysql.PoolConnection> {
  const pool = getRecordsDbPool();
  return await pool.getConnection();
}

/**
 * Get single connection to OCR Database  
 */
export async function getOcrDbConnection(): Promise<mysql.PoolConnection> {
  const pool = getOcrDbPool();
  return await pool.getConnection();
}

/**
 * Execute query on Records Database
 */
export async function executeRecordsQuery<T = any>(
  query: string, 
  params: any[] = []
): Promise<[T[], mysql.FieldPacket[]]> {
  const pool = getRecordsDbPool();
  return await pool.execute(query, params) as [T[], mysql.FieldPacket[]];
}

/**
 * Execute query on OCR Database
 */
export async function executeOcrQuery<T = any>(
  query: string,
  params: any[] = []
): Promise<[T[], mysql.FieldPacket[]]> {
  const pool = getOcrDbPool();
  return await pool.execute(query, params) as [T[], mysql.FieldPacket[]];
}

/**
 * Execute query on Central Database (orthodoxmetrics_db)
 */
export async function executeCentralQuery<T = any>(
  query: string,
  params: any[] = []
): Promise<[T[], mysql.FieldPacket[]]> {
  return await centralPool.execute(query, params) as [T[], mysql.FieldPacket[]];
}

/**
 * Transaction wrapper for Records Database
 */
export async function withRecordsTransaction<T>(
  callback: (connection: mysql.PoolConnection) => Promise<T>
): Promise<T> {
  const connection = await getRecordsDbConnection();
  
  try {
    await connection.beginTransaction();
    const result = await callback(connection);
    await connection.commit();
    return result;
  } catch (error) {
    await connection.rollback();
    throw error;
  } finally {
    connection.release();
  }
}

/**
 * Transaction wrapper for OCR Database
 */
export async function withOcrTransaction<T>(
  callback: (connection: mysql.PoolConnection) => Promise<T>
): Promise<T> {
  const connection = await getOcrDbConnection();
  
  try {
    await connection.beginTransaction();
    const result = await callback(connection);
    await connection.commit();
    return result;
  } catch (error) {
    await connection.rollback();
    throw error;
  } finally {
    connection.release();
  }
}

/**
 * Cross-database transaction (Records + OCR)
 */
export async function withCrossDbTransaction<T>(
  callback: (recordsConn: mysql.PoolConnection, ocrConn: mysql.PoolConnection) => Promise<T>
): Promise<T> {
  const recordsConnection = await getRecordsDbConnection();
  const ocrConnection = await getOcrDbConnection();
  
  try {
    await recordsConnection.beginTransaction();
    await ocrConnection.beginTransaction();
    
    const result = await callback(recordsConnection, ocrConnection);
    
    await recordsConnection.commit();
    await ocrConnection.commit();
    
    return result;
  } catch (error) {
    await recordsConnection.rollback();
    await ocrConnection.rollback();
    throw error;
  } finally {
    recordsConnection.release();
    ocrConnection.release();
  }
}

/**
 * Get church information from central database
 */
export async function getChurchInfo(churchId: number): Promise<any> {
  const [rows] = await executeCentralQuery(
    'SELECT * FROM churches WHERE id = ?',
    [churchId]
  );
  
  if (rows.length === 0) {
    throw new Error(\`Church not found: \${churchId}\`);
  }
  
  return rows[0];
}

/**
 * Validate user permissions for OCR operations
 */
export async function validateUserPermissions(
  userId: number, 
  action: string,
  churchId?: number
): Promise<boolean> {
  try {
    // Get user role and permissions
    const [userRows] = await executeCentralQuery(
      \`SELECT u.*, ur.role_name 
       FROM users u 
       LEFT JOIN user_roles ur ON u.role_id = ur.id 
       WHERE u.id = ?\`,
      [userId]
    );
    
    if (userRows.length === 0) {
      return false;
    }
    
    const user = userRows[0];
    
    // Super admin can do everything
    if (user.email === 'superadmin@orthodoxmetrics.com') {
      return true;
    }
    
    // Check church-specific permissions if churchId provided
    if (churchId) {
      const [permRows] = await executeCentralQuery(
        \`SELECT * FROM church_permissions 
         WHERE user_id = ? AND church_id = ? AND permission_type = ?\`,
        [userId, churchId, action]
      );
      
      if (permRows.length > 0) {
        return true;
      }
    }
    
    // Check role-based permissions
    const rolePermissions: Record<string, string[]> = {
      'admin': ['ocr_upload', 'ocr_review', 'ocr_approve', 'ocr_configure'],
      'clergy': ['ocr_upload', 'ocr_review', 'ocr_approve'],
      'volunteer': ['ocr_upload']
    };
    
    const allowedActions = rolePermissions[user.role_name] || [];
    return allowedActions.includes(action);
    
  } catch (error) {
    console.error('Permission validation error:', error);
    return false;
  }
}

/**
 * Test all database connections
 */
export async function testConnections(): Promise<{ success: boolean; results: any }> {
  const results = {
    central: { connected: false, error: null },
    records: { connected: false, error: null },
    ocr: { connected: false, error: null }
  };
  
  try {
    // Test central database
    const [centralRows] = await executeCentralQuery('SELECT 1 as test');
    results.central.connected = true;
  } catch (error) {
    results.central.error = error.message;
  }
  
  try {
    // Test records database
    const [recordsRows] = await executeRecordsQuery('SELECT 1 as test');
    results.records.connected = true;
  } catch (error) {
    results.records.error = error.message;
  }
  
  try {
    // Test OCR database
    const [ocrRows] = await executeOcrQuery('SELECT 1 as test');
    results.ocr.connected = true;
  } catch (error) {
    results.ocr.error = error.message;
  }
  
  const success = results.central.connected && results.records.connected && results.ocr.connected;
  
  return { success, results };
}

/**
 * Close all database connections
 */
export async function closeAllConnections(): Promise<void> {
  const promises = [];
  
  if (recordsPool) {
    promises.push(recordsPool.end());
    recordsPool = null;
  }
  
  if (ocrPool) {
    promises.push(ocrPool.end());
    ocrPool = null;
  }
  
  await Promise.all(promises);
}

// Graceful shutdown
process.on('SIGINT', async () => {
  await closeAllConnections();
  process.exit(0);
});

process.on('SIGTERM', async () => {
  await closeAllConnections(); 
  process.exit(0);
});
`;

const FIELD_CONFIG_SERVICE_CODE = `/**
 * Field Configuration Service
 * Handles OCR field mapping configurations for churches
 * Generated by Phase 1 setup script
 */

import {
  FieldConfig,
  RecordFieldConfig,
  FieldConfigResponse,
  CreateFieldConfigRequest,
  RecordType,
  TABLE_NAMES
} from '../types/ocrTypes';
import { executeRecordsQuery, withRecordsTransaction } from './dbConnections';

/**
 * Get field configuration for a church and record type
 */
export async function getFieldConfig(
  churchId: number,
  recordType: RecordType
): Promise<RecordFieldConfig | null> {
  try {
    const [rows] = await executeRecordsQuery<FieldConfigResponse>(
      \`SELECT * FROM \${TABLE_NAMES.OCR_FIELD_CONFIGURATIONS} 
       WHERE church_id = ? AND record_type = ? AND is_active = TRUE
       ORDER BY version DESC LIMIT 1\`,
      [churchId, recordType]
    );
    
    if (rows.length === 0) {
      return null;
    }
    
    return rows[0].field_config;
  } catch (error) {
    console.error('Error getting field config:', error);
    throw error;
  }
}

/**
 * Create or update field configuration
 */
export async function saveFieldConfig(
  request: CreateFieldConfigRequest
): Promise<number> {
  return await withRecordsTransaction(async (connection) => {
    // Deactivate existing configs for this church/record type
    await connection.execute(
      \`UPDATE \${TABLE_NAMES.OCR_FIELD_CONFIGURATIONS} 
       SET is_active = FALSE, updated_at = CURRENT_TIMESTAMP
       WHERE church_id = ? AND record_type = ?\`,
      [request.church_id, request.record_type]
    );
    
    // Get next version number
    const [versionRows] = await connection.execute(
      \`SELECT COALESCE(MAX(version), 0) + 1 as next_version 
       FROM \${TABLE_NAMES.OCR_FIELD_CONFIGURATIONS}
       WHERE church_id = ? AND record_type = ?\`,
      [request.church_id, request.record_type]
    );
    
    const nextVersion = versionRows[0].next_version;
    
    // Insert new configuration
    const [result] = await connection.execute(
      \`INSERT INTO \${TABLE_NAMES.OCR_FIELD_CONFIGURATIONS} 
       (church_id, record_type, field_config, description, version, is_active) 
       VALUES (?, ?, ?, ?, ?, TRUE)\`,
      [
        request.church_id,
        request.record_type,
        JSON.stringify(request.field_config),
        request.description,
        nextVersion
      ]
    );
    
    return result.insertId;
  });
}

/**
 * Get all field configurations for a church
 */
export async function getChurchFieldConfigs(churchId: number): Promise<FieldConfigResponse[]> {
  const [rows] = await executeRecordsQuery<FieldConfigResponse>(
    \`SELECT * FROM \${TABLE_NAMES.OCR_FIELD_CONFIGURATIONS}
     WHERE church_id = ? AND is_active = TRUE
     ORDER BY record_type, version DESC\`,
    [churchId]
  );
  
  return rows;
}

/**
 * Get field configuration history
 */
export async function getFieldConfigHistory(
  churchId: number,
  recordType: RecordType
): Promise<FieldConfigResponse[]> {
  const [rows] = await executeRecordsQuery<FieldConfigResponse>(
    \`SELECT * FROM \${TABLE_NAMES.OCR_FIELD_CONFIGURATIONS}
     WHERE church_id = ? AND record_type = ?
     ORDER BY version DESC\`,
    [churchId, recordType]
  );
  
  return rows;
}

/**
 * Delete field configuration (soft delete - mark as inactive)
 */
export async function deleteFieldConfig(configId: number): Promise<void> {
  await executeRecordsQuery(
    \`UPDATE \${TABLE_NAMES.OCR_FIELD_CONFIGURATIONS}
     SET is_active = FALSE, updated_at = CURRENT_TIMESTAMP
     WHERE id = ?\`,
    [configId]
  );
}
`;

async function createDbUtilities() {
  try {
    console.log('🔌 PHASE 1 - Step 4: Creating database connection utilities...');
    console.log('================================================================================');
    
    // Create utils directory if it doesn't exist
    const utilsDir = path.join(__dirname, '..', 'utils');
    
    try {
      await fs.access(utilsDir);
      console.log('📁 Utils directory exists');
    } catch {
      await fs.mkdir(utilsDir, { recursive: true });
      console.log('📁 Created utils directory');
    }
    
    // Create services directory
    const servicesDir = path.join(__dirname, '..', 'services');
    
    try {
      await fs.access(servicesDir);
      console.log('📁 Services directory exists');
    } catch {
      await fs.mkdir(servicesDir, { recursive: true });
      console.log('📁 Created services directory');
    }
    
    // Write database connections utility
    const dbConnectionsPath = path.join(utilsDir, 'dbConnections.ts');
    await fs.writeFile(dbConnectionsPath, DB_UTILITIES_CODE);
    console.log(`✅ Created database connections utility: ${dbConnectionsPath}`);
    
    // Write field configuration service
    const fieldConfigPath = path.join(servicesDir, 'fieldConfigService.ts');
    await fs.writeFile(fieldConfigPath, FIELD_CONFIG_SERVICE_CODE);
    console.log(`✅ Created field configuration service: ${fieldConfigPath}`);
    
    // Create a test script for the utilities
    const testUtilitiesCode = `#!/usr/bin/env node

/**
 * Test script for database utilities
 */

import { testConnections, getChurchInfo, validateUserPermissions } from '../utils/dbConnections';
import { getFieldConfig, getChurchFieldConfigs } from '../services/fieldConfigService';

async function testDbUtilities() {
  console.log('🧪 Testing database utilities...');
  
  try {
    // Test connections
    console.log('\\n🔌 Testing database connections...');
    const connectionTest = await testConnections();
    
    if (connectionTest.success) {
      console.log('✅ All database connections successful');
    } else {
      console.log('❌ Some database connections failed:');
      Object.entries(connectionTest.results).forEach(([db, result]) => {
        if (result.connected) {
          console.log(\`   ✅ \${db}: Connected\`);
        } else {
          console.log(\`   ❌ \${db}: \${result.error}\`);
        }
      });
    }
    
    // Test church info retrieval
    console.log('\\n🏛️ Testing church info retrieval...');
    try {
      const churchInfo = await getChurchInfo(14);
      console.log(\`✅ Church info retrieved: \${churchInfo.name}\`);
    } catch (error) {
      console.log(\`❌ Church info failed: \${error.message}\`);
    }
    
    // Test field configuration retrieval
    console.log('\\n📋 Testing field configuration retrieval...');
    try {
      const fieldConfig = await getFieldConfig(14, 'baptism');
      if (fieldConfig) {
        console.log(\`✅ Field config retrieved: \${fieldConfig.fields.length} fields\`);
      } else {
        console.log('ℹ️  No field config found (expected for new setup)');
      }
    } catch (error) {
      console.log(\`❌ Field config failed: \${error.message}\`);
    }
    
    // Test church field configs
    console.log('\\n📂 Testing church field configs...');
    try {
      const configs = await getChurchFieldConfigs(14);
      console.log(\`✅ Found \${configs.length} field configurations for church 14\`);
    } catch (error) {
      console.log(\`❌ Church field configs failed: \${error.message}\`);
    }
    
    console.log('\\n🎉 Database utilities test complete!');
    
  } catch (error) {
    console.error('❌ Test failed:', error.message);
    process.exit(1);
  }
}

testDbUtilities().catch(console.error);
`;
    
    const testPath = path.join(__dirname, 'test-db-utilities.ts');
    await fs.writeFile(testPath, testUtilitiesCode);
    console.log(`✅ Created test script: ${testPath}`);
    
    console.log('\n================================================================================');
    console.log('🔌 Database Utilities Creation Complete!');
    console.log('📁 Files created:');
    console.log(`   - ${dbConnectionsPath}`);
    console.log(`   - ${fieldConfigPath}`);
    console.log(`   - ${testPath}`);
    console.log('\n📝 Next step: Run phase1-complete.js to finalize Phase 1 setup');
    console.log('================================================================================');
    
  } catch (error) {
    console.error('❌ Database utilities creation failed:', error.message);
    process.exit(1);
  }
}

// Run utility creation
createDbUtilities().catch(console.error);
